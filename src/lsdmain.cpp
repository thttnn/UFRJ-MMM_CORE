/*************************************************************

	LSD 8.0 - May 2021
	written by Marco Valente, Universita' dell'Aquila
	and by Marcelo Pereira, University of Campinas

	Copyright Marco Valente and Marcelo Pereira
	LSD is distributed under the GNU General Public License
	
	See Readme.txt for copyright information of
	third parties' code used in LSD
	
 *************************************************************/

/*************************************************************
LSDMAIN.CPP 
Contains:
- early initialization (namely, of the Log windows)
- the main cycle: browse a model, run simulation, return to the browser.

The main functions contained here are:

- void run( )
Run the simulation model whose root is r. Running is not only the actual
simulation run, but also the initialization of result files. Of course, it has
also to manage the messages from user and from the model at run time.

- bool alloc_save_mem( );
Prepare variables to store saved data.

Relevant flags (when defined):

- FUN: user model equation file
- NW: No Window executable
- NP: no parallel (multi-task) processing
- NT: no signal trapping (better when debugging in GDB)
*************************************************************/

#include "decl.h"

// some program defaults
bool grandTotal = false;	// flag to produce or not grand total in batch processing
bool ignore_eq_file = true;	// flag to ignore equation file in configuration file
char err_file[ ] = "LSD.err";// error log file name
char nonavail[ ] = "NA";	// string for unavailable values (use R default)
char tabs[ ] = "5c 7.5c 10c 12.5c 15c 17.5c 20c";	// Log window tabs
double def_res = 0;			// default equation result
int add_to_tot = false;		// flag to append results to existing totals file (bool)
int dozip = true;			// compressed results file flag (bool)
int max_step = 100;			// default number of simulation runs
int overwConf = true;		// overwrite configuration on run flag (bool)
int saveConf = false;		// save configuration on results saving (bool)
int strWindowOn = true;		// control the presentation of the model structure window (bool)
unsigned seed = 1;			// random number generator initial seed

bool batch_sequential = false;// no-window multi configuration job running
bool brCovered = false;		// browser cover currently covered
bool eq_dum = false;		// current equation is dummy
bool error_hard_thread;		// flag to error_hard() called in worker thread
bool fast;					// safe copy of fast_mode flag
bool log_ok = false;		// control for log window available
bool message_logged = false;// new message posted in log window
bool no_more_memory = false;// memory overflow when setting data save structure	
bool no_saved = true;		// disable the usage of saved values as lagged ones
bool no_search;				// disable the standard variable search mechanism
bool no_window = false;		// no-window command line job
bool no_zero_instance = true;// flag to allow deleting last object instance
bool non_var = false;		// flag to indicate INTERACT macro condition
bool parallel_mode;			// parallel mode (multithreading) status
bool pause_run;				// pause running simulation
bool redrawRoot;			// control for redrawing root window (.)
bool redrawStruc;			// control for redrawing model structure window
bool running = false;		// simulation is running
bool save_alt_path = false;	// alternate save path flag
bool save_ok = true;		// control if saving model configuration is possible
bool scrollB = true;		// scroll box state in current runtime plot
bool struct_loaded = false;	// a valid configuration file is loaded
bool tk_ok = false;			// control for tk ready to operate
bool unsavedData = false;	// flag unsaved simulation results
bool unsavedSense = false;	// control for unsaved changes in sensitivity data
bool user_exception = false;// flag indicating exception was generated by user code
bool use_nan;				// flag to allow using Not a Number value
bool worker_ready;			// parallel worker ready flag
bool worker_crashed;		// parallel worker crash flag
char *alt_path = NULL;		// alternative output path
char *eq_file = NULL;		// equation file content
char *exec_file = NULL;		// name of executable file
char *exec_path = NULL;		// path of executable file
char *rootLsd = NULL;		// path of LSD root directory
char *path = NULL;			// path of current configuration
char *sens_file = NULL;		// current sensitivity analysis file
char *simul_name = NULL;	// name of current simulation configuration
char *struct_file = NULL;	// name of current configuration file
char equation_name[ MAX_PATH_LENGTH + 1 ] = "";// equation file name
char error_hard_msg1[ TCL_BUFF_STR + 1 ];	// buffer for parallel worker title msg
char error_hard_msg2[ TCL_BUFF_STR + 1 ];	// buffer for parallel worker log msg
char error_hard_msg3[ TCL_BUFF_STR + 1 ];	// buffer for parallel worker box msg
char lastObj[ MAX_ELEM_LENGTH + 1 ] = "";	// last shown object for quick reload
char lsd_eq_file[ MAX_FILE_SIZE + 1 ] = "";	// equations saved in configuration file
char msg[ TCL_BUFF_STR + 1 ] = "";			// auxiliary Tcl buffer
char name_rep[ MAX_PATH_LENGTH + 1 ];		// documentation report file name
char path_rep[ MAX_PATH_LENGTH + 1 ];		// documentation report file path
char tcl_dir[ MAX_PATH_LENGTH + 1 ];		// Tcl/Tk directory
description *descr = NULL;	// model description structure
eq_mapT eq_map;				// fast equation look-up map
int actual_steps = 0;		// number of executed time steps
int choice;					// Tcl menu control variable (main window)
int choice_g;               // Tcl menu control variable (structure window)
int cur_plt;				// current graph plot number
int cur_sim;				// current simulation run
int debug_flag = false;		// debug enable control (bool)
int docsv = false;			// produce .csv text results files (bool)
int done_in;				// Tcl menu control variable (log window)
int fast_mode;				// level of LOG messages & runtime plot
int fend;					// last multi configuration job to run
int findex;					// current multi configuration job
int findexSens = 0;			// index to sequential sensitivity configuration filenames
int log_start;				// first period to start logging to file
int log_stop;				// last period to log to file, if any
int macro;					// equations style (macros or C++) (bool)
int max_threads = 1;		// maximum number of parallel threads 
int no_res = false;			// do not produce .res results files (bool)
int parallel_disable = false;// flag to control parallel mode
int platform = 0;			// OS platform (1=Linux, 2=Mac, 3=Windows)
int prof_aggr_time = false;	// show aggregate profiling times
int prof_min_msecs = 0;		// profile only variables taking more than X msecs.
int prof_obs_only = false;	// profile only observed variables
int quit = 0;				// simulation interruption mode (0=none)
int series_saved = 0;		// number of series saved
int sim_num = 1;			// simulation number running
int stack;					// LSD stack call level
int stack_info = 0;			// LSD stack control
int stop;					// activity interruption flag (Tcl boolean)
int t;						// current time step
int when_debug;				// next debug stop time step (0 for none)
int wr_warn_cnt;			// invalid write operations warning counter
long nodesSerial = 1;		// network node's serial number global counter
lsdstack *stacklog = NULL;	// LSD stack
map < string, profile > prof;// set of saved profiling times
object *blueprint = NULL;	// LSD blueprint (effective model in use)
object *currObj = NULL;		// pointer to current object in browser
object *root = NULL;		// LSD root object
object *wait_delete = NULL;	// LSD object waiting for deletion
o_setT obj_list;			// set with all existing LSD objects
s_vecT res_list;			// list of results files last saved
sense *rsense = NULL;		// LSD sensitivity analysis structure
variable *cemetery = NULL;	// LSD saved data from deleted objects
variable *last_cemetery = NULL;	// LSD last saved data from deleted objects
FILE *log_file = NULL;		// log file, if any

// constant arrays
const char *lmm_options[ LMM_OPTIONS_NUM ] = LMM_OPTIONS_NAME;
const char *lmm_defaults[ LMM_OPTIONS_NUM ] = LMM_OPTIONS_DEFAULT;
const char *model_info[ MODEL_INFO_NUM ] = MODEL_INFO_NAME;
const char *model_defaults[ MODEL_INFO_NUM ] = MODEL_INFO_DEFAULT;
const char *signal_names[ REG_SIG_NUM ] = REG_SIG_NAME;
const char *wnd_names[ LSD_WIN_NUM ] = LSD_WIN_NAME;
const int signals[ REG_SIG_NUM ] = REG_SIG_CODE;

// conditional variables
#ifndef NW
int i_values[ 4 ];			// user temporary variables copy
double d_values[ USER_D_VARS ];
object *o_values[ 10 ];
netLink *n_values[ 10 ];
FILE *f_values[ 1 ];
p_mapT par_map;				// variable to parent name map for AoR
Tcl_Interp *inter = NULL;	// global Tcl interpreter in LSD
#endif

#ifndef NP
map < thread::id, worker * > thr_ptr;	// worker thread pointers
thread::id main_thread;		// LSD main thread ID
worker *workers = NULL;		// multi-thread parallel worker data
#endif


/*********************************
 LSDMAIN
 *********************************/
int lsdmain( int argn, char **argv )
{
	char *str;
	int i, j = 0, len;

	path = new char[ strlen( "" ) + 1 ];
	simul_name = new char[ strlen( DEF_CONF_FILE ) + 1 ];
	exec_path = new char[ MAX_PATH_LENGTH + 1 ]; 
	strcpy( path, "" );
	strcpy( tcl_dir, "" );
	strcpy( simul_name, DEF_CONF_FILE );
	exec_path = getcwd( exec_path, MAX_PATH_LENGTH );
	exec_file = clean_file( argv[ 0 ] );	// global pointer to the name of executable file
	exec_path = clean_path( exec_path );	// global pointer to path of executable file

#ifndef NP
	main_thread = this_thread::get_id( );
	max_threads = ( MAX_CORES <= 0 ) ? thread::hardware_concurrency( ) : MAX_CORES;
#else
	max_threads = ( MAX_CORES <= 0 ) ? 4 : MAX_CORES;
#endif	

	root = new object;
	root->init( NULL, "Root" );
	add_description( "Root" );
	reset_blueprint( NULL );

#ifdef NW
	
	no_window = true;
	findex = 1;
	fend = 0;							// no file number limit

	if ( exec_file == NULL || exec_path == NULL )
	{
		fprintf( stderr, "\nInvalid LSD executable name or path.\nThis is the No Window version of LSD.\nMake sure the LSD directory is not too deep into the disk directory tree (over %d chars).\n\n", MAX_PATH_LENGTH );
		myexit( 5 );
	}
	
	if ( argn < 3 )
	{
		fprintf( stderr, "\nThis is the No Window version of LSD.\nCommand line options:\n'-f FILENAME.lsd' to run a single configuration file\n'-f FILE_BASE_NAME -s FIRST_NUM [-e LAST_NUM]' for batch sequential mode\n'-o PATH' to save result file(s) to a different subdirectory\n'-t' to produce comma separated (.csv) text result file(s)\n'-r' for skipping the generation of intermediate result file(s)\n'-g' for the generation of a single grand total file\n'-z' for preventing the generation of compressed result file(s)\n'-c MAX_CORES' for defining the maximum number of CPU cores to use\n\n" );
		myexit( 0 );
	}
	else
	{
		for ( i = 1; i < argn; i += 2 )
		{
			// read -f parameter : file name or base name
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'f' && 1 + i < argn && strlen( argv[ 1 + i ] ) > 0 )
			{
				delete [ ] simul_name;
				simul_name = new char[ strlen( argv[ 1 + i ] ) + 1 ];
				strcpy( simul_name, argv[ 1 + i ] );
				continue;
			}
			// read -s parameter : first sequential file to process
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 's' && 1 + i < argn && strlen( argv[ 1 + i ] ) > 0 )
			{
				findex = atoi( argv[ i + 1 ] );
				batch_sequential = true;   
				continue;
			}
			// read -e parameter : last sequential file to process
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'e' && 1 + i < argn && strlen( argv[ 1 + i ] ) > 0 )
			{
				fend = atoi( argv[ i + 1 ] );
				continue;
			}
			// read -t parameter : produce .csv text results files
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 't' )
			{
				i--; 					// no parameter for this option
				docsv = true;
				continue;
			}
			// read -r parameter : do not produce intermediate .res files
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'r' )
			{
				i--; 					// no parameter for this option
				no_res = true;
				continue;
			}
			// read -g parameter : create grand total file (batch only)
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'g' )
			{
				i--; 					// no parameter for this option
				grandTotal = true;
				printf( "Grand total file requested ('-g'), please don't run another instance of 'lsdNW' in this folder!\n\n" );
				continue;
			}
			// read -g parameter : don't create compressed result files
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'z' )
			{
				i--; 					// no parameter for this option
				dozip = false;
				continue;
			}
			// change the path for the output of result files
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'o' && 1 + i < argn && strlen( argv[ 1 + i ] ) > 0 )
			{
				results_alt_path( argv[ 1 + i ] );
				continue;
			}
			// read -c parameter : max number of cores
			if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'c' && 1 + i < argn && strlen( argv[ 1 + i ] ) > 0 )
			{
				j = atoi( argv[ i + 1 ] );
				continue;
			}

			fprintf( stderr, "\nOption '%c%c' not recognized.\nThis is the No Window version of LSD.\nCommand line options:\n'-f FILENAME.lsd' to run a single configuration file\n'-f FILE_BASE_NAME -s FIRST_NUM [-e LAST_NUM]' for batch sequential mode\n'-o PATH' to save result file(s) to a different subdirectory\n'-t' to produce comma separated (.csv) text result file(s)\n'-r' for skipping the generation of intermediate result file(s)\n'-g' for the generation of a single grand total file\n'-c MAX_CORES' for defining the maximum number of CPU cores to use\n'-z' for preventing the generation of compressed result file(s)\n\n", argv[ i ][ 0 ], argv[ i ][ 1 ] );
			myexit( 6 );
		}
	} 

	if ( ! batch_sequential )
	{
		struct_file = new char[ strlen( simul_name ) + 1 ];
		sprintf( struct_file, "%s", simul_name );
		simul_name[ strlen( simul_name ) - 4 ] = '\0';
	} 
	else
	{
		sprintf( msg, "%s_%d.lsd", simul_name, findex );
		struct_file = new char[ strlen( msg ) + 1 ];
		strcpy( struct_file, msg );
	}
	 
	FILE *f = fopen( struct_file, "r" );
	if ( f == NULL )
	{
		fprintf( stderr, "\nFile '%s' not found.\nThis is the no window version of LSD.\nSpecify a -f FILENAME.lsd to run a simulation or -f FILE_BASE_NAME -s 1 for\nbatch sequential simulation mode (requires configuration files:\nFILE_BASE_NAME_1.lsd, FILE_BASE_NAME_2.lsd, etc).\n\n", struct_file );
		myexit( 7 );
	}
	
	fclose( f );

	if ( load_configuration( true ) != 0 )
	{
		fprintf( stderr, "\nFile '%s' is invalid.\nThis is the no window version of LSD.\nCheck if the file is a valid LSD configuration or regenerate it using the\nLSD Browser.\n\n", struct_file );
		myexit( 8 );
	}

#ifndef NP
	if ( j > 0 && j < max_threads )
		max_threads = j;
#endif	

#else 
	for ( i = 1; argv[ i ] != NULL; i++ )
	{
		if ( exec_file == NULL || exec_path == NULL )
		{
			log_tcl_error( "Invalid LSD executable name or path", "Make sure the LSD directory is not too deep into the disk directory tree" );
			myexit( 1 );
		}
		
		if ( argv[ i ][ 0 ] != '-' || ( argv[ i ][ 1 ] != 'f' && argv[ i ][ 1 ] != 'i' && argv[ i ][ 1 ] != 'c' ) )
		{
			log_tcl_error( "Command line parameters", "Invalid option, available options: -i TCL_DIRECTORY / -f MODEL_NAME / -c MAX_CORES" );
			myexit( 1 );
		}
		
		if ( argv[ i ][ 1 ] == 'f' )
		{
			delete [ ] simul_name;
			simul_name = new char[ strlen( argv[ i + 1 ] ) + 3 ];
			strcpy( simul_name, argv[ i + 1 ] );
			len = strlen( simul_name );
			if ( len > 4 && ! strcmp( ".lsd", simul_name + len - 4 ) )
				*( simul_name + len - 4 ) = '\0';
			i++;
		}
		if ( argv[ i ][ 1 ] == 'i' )
		{
			strcpy( tcl_dir, argv[ i + 1 ] + 2 );
			i++;
		} 
		// read -c parameter : max number of cores
		if ( argv[ i ][ 0 ] == '-' && argv[ i ][ 1 ] == 'c' )
		{
			j = atoi( argv[ i + 1 ] );
			continue;
		}
	}

#ifndef NP
	if ( j > 0 && j < max_threads )
		max_threads = j;
#endif	

	// initialize tcl/tk and set global bidirectional variables
	init_tcl_tk( argv[ 0 ], "lsd" );
	Tcl_LinkVar( inter, "choice", ( char * ) &choice, TCL_LINK_INT );
	Tcl_LinkVar( inter, "choice_g", ( char * ) &choice_g, TCL_LINK_INT );
	Tcl_LinkVar( inter, "stop", ( char * ) &stop, TCL_LINK_BOOLEAN );
	Tcl_LinkVar( inter, "debug_flag", ( char * ) &debug_flag, TCL_LINK_BOOLEAN );
	Tcl_LinkVar( inter, "when_debug", ( char * ) &when_debug, TCL_LINK_INT );

	// set system defaults in tcl
	cmd( "set LMM_OPTIONS \"%s\"", LMM_OPTIONS );
	cmd( "set SYSTEM_OPTIONS \"%s\"", SYSTEM_OPTIONS );
	cmd( "set MODEL_OPTIONS \"%s\"", MODEL_OPTIONS );
	cmd( "set GROUP_INFO \"%s\"", GROUP_INFO );
	cmd( "set MODEL_INFO \"%s\"", MODEL_INFO );
	cmd( "set MODEL_INFO_NUM %d", MODEL_INFO_NUM );
	cmd( "set DESCRIPTION \"%s\"", DESCRIPTION );
	cmd( "set DATE_FMT \"%s\"", DATE_FMT );

	// try to use exec_path to change to the model directory
	if ( strlen( exec_path ) == 0 || ! strcmp( exec_path, "/" ) )
	{	// try to get name from Tcl
		cmd( "if { [ info nameofexecutable ] != \"\" } { set path [ file dirname [ info nameofexecutable ] ] } { set path \"\" }" );
		str = ( char * ) Tcl_GetVar( inter, "path", 0 );
		if ( str != NULL && strlen( str ) > 0 )
		{
			delete [ ] exec_path;
			exec_path = new char[ strlen( str ) + 1 ];
			strcpy( exec_path, str );
		}
	}
	choice = 0;
	cmd( "set path [ file normalize \"%s\" ]", exec_path );
	
	// check if directory is ok and if executable is inside a macOS package
	cmd( "if [ file exists \"$path/$MODEL_INFO\" ] { \
			cd \"$path\" \
		} { \
			if [ file exists \"$path/../../../$MODEL_INFO\" ] { \
				cd \"$path/../../..\"; \
				set path \"[ pwd ]\" \
			} { \
				set path \"\"; \
				set choice 1 \
			} \
		}" );
	if ( choice )
	{
		log_tcl_error( "Model files check", "Required model file(s) missing or corrupted, check the model directory and recreate the model if the problem persists" );
		cmd( "ttk::messageBox -parent . -title Error -icon error -type ok -message \"File(s) missing or corrupted\" -detail \"Some model files are missing or corrupted.\nPlease recreate your model if the problem persists.\n\nLSD is aborting now.\"" );
		myexit( 200 );
	}
	str = ( char * ) Tcl_GetVar( inter, "path", 0 );
	delete [ ] path;
	path = new char[ strlen( str ) + 1 ];
	strcpy( path, str );
	delete [ ] exec_path;
	exec_path = new char[ strlen( str ) + 1 ];
	strcpy( exec_path, str );

	// check if LSDROOT already exists and use it if so, if not, search the current directory tree
	cmd( "if [ info exists env(LSDROOT) ] { set RootLsd [ file normalize $env(LSDROOT) ]; if { ! [ file exists \"$RootLsd/src/interf.cpp\" ] } { unset RootLsd } }" );

	// do some search for the right path to cope with Mac Acqua package
	choice = 0;
	cmd( "if { ! [ info exists RootLsd ] } { \
			set here [ pwd ]; \
			while { ! [ file exists \"src/interf.cpp\" ] && ! [ string equal [ pwd ] \"/\" ] && [ string length [ pwd ] ] > 3 } { \
				cd .. \
			}; \
			if [ file exists \"src/interf.cpp\" ] { \
				set RootLsd [ pwd ] \
			} { \
				set choice 1 \
			}; \
			cd $here; \
		}" );

	if ( choice )
	{
		log_tcl_error( "LSDROOT check", "LSDROOT not set, make sure the environment variable LSDROOT points to the directory where LSD is installed" );
		cmd( "ttk::messageBox -parent . -title Error -icon error -type ok -message \"LSDROOT not set\" -detail \"Please make sure the environment variable LSDROOT points to the directory where LSD is installed.\n\nLSD is aborting now.\"" );
		myexit( 9 );
	}
	
	cmd( "set env(LSDROOT) $RootLsd" );
	
	str = ( char * ) Tcl_GetVar( inter, "RootLsd", 0 );
	if ( str != NULL && strlen( str ) > 0 )
	{
		rootLsd = new char[ strlen( str ) + 1 ];
		strcpy( rootLsd, str );
		rootLsd = clean_path( rootLsd );
		cmd( "set RootLsd \"%s\"", rootLsd );
	}
	else
	{
		log_tcl_error( "LSD directory check", "Cannot locate LSD folder on disk, check the installation of LSD and reinstall LSD if the problem persists" );
		cmd( "ttk::messageBox -parent . -title Error -icon error -type ok -message \"LSD directory missing\" -detail \"Cannot locate the LSD installation folder on disk.\nPlease check your installation and reinstall LSD if the problem persists.\n\nLSD is aborting now.\"" );
		myexit( 9 );
	}

	// load/check LMM configuration file
	i = load_lmm_options( );

	// load required Tcl/Tk data, procedures and packages (error coded by file/bit position)
	choice = 0;

	// load native Tk procedures for graphical user interface management
	cmd( "if [ file exists \"$RootLsd/$LsdSrc/gui.tcl\" ] { if [ catch { source \"$RootLsd/$LsdSrc/gui.tcl\" } err0x01 ] { set choice [ expr { $choice + %d } ] } } { set choice [ expr { $choice + %d } ] }", 0x0100, 0x01 );

	// load native Tcl procedures for general utilities
	cmd( "if [ file exists \"$RootLsd/$LsdSrc/file.tcl\" ] { if [ catch { source \"$RootLsd/$LsdSrc/file.tcl\" } err0x02 ] { set choice [ expr { $choice + %d } ] } } { set choice [ expr { $choice + %d } ] }", 0x0200, 0x02 );

	// load additional native Tcl procedures for external files handling
	cmd( "if [ file exists \"$RootLsd/$LsdSrc/util.tcl\" ] { if [ catch { source \"$RootLsd/$LsdSrc/util.tcl\" } err0x04 ] { set choice [ expr { $choice + %d } ] } } { set choice [ expr { $choice + %d } ] }", 0x0400, 0x04 );

	if ( choice != 0 )
	{
		char *err0x01 = ( char * ) Tcl_GetVar( inter, "err0x01", 0 );
		char *err0x02 = ( char * ) Tcl_GetVar( inter, "err0x02", 0 );
		char *err0x04 = ( char * ) Tcl_GetVar( inter, "err0x04", 0 );
		snprintf( msg, TCL_BUFF_STR - 1, "Required Tcl/Tk source file(s) missing or corrupted (0x%04x), check your installation and reinstall LSD if the problem persists\n\n0x01: %s\n\n0x02: %s\n\n0x04: %s", choice, err0x01, err0x02, err0x04 );
		log_tcl_error( "Source files check failed", msg );
		cmd( "ttk::messageBox -parent . -title Error -icon error -type ok -message \"File(s) missing or corrupted\" -detail \"Some critical Tcl files (0x%04x) are missing or corrupted.\nPlease check your installation and reinstall LSD if the problem persists.\n\nLSD is aborting now.\"", choice );
		myexit( 200 + choice );
	}

	str = ( char * ) Tcl_GetVar( inter, "CurPlatform", 0 );
	if ( ! strcmp( str, "linux" ) )
		platform = LINUX;
	else
		if ( ! strcmp( str, "mac" ) )
			platform = MAC;
		else
			if ( ! strcmp( str, "windows" ) )
				platform = WINDOWS;
			else
			{
				log_tcl_error( "Unsupported platform", "Your computer operating system is not supported by this LSD version, you may try an older version compatible with legacy systems (Windows 32-bit, Mac OS X, etc.)" );
				cmd( "ttk::messageBox -parent . -type ok -icon error -title Error -message \"Unsupported platform\" -detail \"Your computer operating system is not supported by this LSD version,\nyou may try an older version compatible with legacy systems\n(Windows 32-bit, Mac OS X, etc.)\n\nLSD is aborting now.\"", choice );
				myexit( 200 );
			}

	// create a Tcl command that calls the C discard_change function before killing LSD
	Tcl_CreateCommand( inter, "discard_change", Tcl_discard_change, NULL, NULL );

	// create Tcl commands that get and set LSD object/variable properties
	Tcl_CreateCommand( inter, "get_obj_conf", Tcl_get_obj_conf, NULL, NULL );
	Tcl_CreateCommand( inter, "set_obj_conf", Tcl_set_obj_conf, NULL, NULL );
	Tcl_CreateCommand( inter, "get_var_conf", Tcl_get_var_conf, NULL, NULL );
	Tcl_CreateCommand( inter, "set_var_conf", Tcl_set_var_conf, NULL, NULL );

	// create a Tcl command to set a c variable when not in a Tcl idle loop
	Tcl_CreateCommand( inter, "set_c_var", Tcl_set_c_var, NULL, NULL );

	// create a Tcl command to get LSD variable description from equation file(s)
	Tcl_CreateCommand( inter, "get_var_descr", Tcl_get_var_descr, NULL, NULL );

	// create a Tcl command to set tooltip from LSD variable description
	Tcl_CreateCommand( inter, "set_ttip_descr", Tcl_set_ttip_descr, NULL, NULL );

	// create Tcl command to upload series data
	Tcl_CreateObjCommand( inter, "upload_series", Tcl_upload_series, NULL, NULL );

	// Tcl command to save message to LSD log
	Tcl_CreateCommand( inter, "log_tcl_error", Tcl_log_tcl_error, NULL, NULL );

	// fix non-existent or old options file for new options
	if ( i == 0 )
		update_lmm_options(  ); 		// update config file

	// load/check model configuration file
	i = load_model_info( exec_path );
	
	// Tcl global variables
	cmd( "set small_character [ expr { $dim_character - $deltaSize } ]" );
	cmd( "set gpterm $gnuplotTerm" );

	// configure main window
	cmd( ". configure -menu .m -background $colorsTheme(bg)" );
	cmd( "icontop . lsd" );
	cmd( "sizetop .lsd" );
	cmd( "setglobkeys ." );				// set global keys for main window
	cmd( "setstyles" );					// set ttk custom style
	cmd( "init_canvas_colors" );
	
	create_logwindow( );

	// load/check model configuration files
	read_eq_filename( equation_name );

	struct_file = new char[ strlen( simul_name ) + 5 ];
	sprintf( struct_file, "%s.lsd", simul_name );

	eq_file = upload_eqfile( );
	strcpy( lsd_eq_file, "" );
	sprintf( name_rep, "report_%s.html", simul_name );
	strcpy( path_rep, "" );

	// fix model configuration file
	if ( i == 0 )
		update_model_info( );
	
	grandTotal = true;				// not in parallel mode: use .tot headers
#endif

	// create fast equation look-up map if required
	if ( fast_lookup )
		init_map( );

	stacklog = new lsdstack;
	stacklog->prev = NULL;
	stacklog->next = NULL;
	stacklog->ns = 0;
	stacklog->vs = NULL;
	strcpy( stacklog->label, "LSD Simulation Manager" );
	stack = 0;

#ifndef NW

	while ( 1 )
	{
		create( );
		
		try 
		{
			run( );
		}
		catch( int p )           	// return point from error_hard() (in object.cpp)
		{		
			if ( p != 919293 )		// check throw signature
				throw;	
			quit = 0;
		}
		catch ( ... )            	// send the rest upward
		{
			throw;
		}
	}

	Tcl_UnlinkVar( inter, "choice" );
	Tcl_UnlinkVar( inter, "choice_g" );
	Tcl_UnlinkVar( inter, "stop" );
	Tcl_UnlinkVar( inter, "debug_flag" );
	Tcl_UnlinkVar( inter, "when_debug" );
	
	set_env( false );

#else

	run( );

#endif 

	empty_stack( );
	empty_lattice( );
	empty_sensitivity( rsense );
	empty_cemetery( );
	empty_blueprint( );
	empty_description( );
	root->delete_obj( );
	
	delete stacklog;
	delete [ ] path;
	delete [ ] rootLsd;
	delete [ ] exec_path;
	delete [ ] simul_name;
	delete [ ] struct_file;

	return 0;
}


/*********************************
RUN
*********************************/
void run( void )
{
	bool batch_sequential_loop = false;
	int i;
	FILE *f;
	clock_t start, end, last_update;
	result *rf;					// pointer for results files (may be zipped or not)

#ifndef NP
	// check if there are parallel computing variables
	if ( parallel_disable || max_threads < 2 )
		parallel_mode = parallel_ready = false;
	else
	{
		parallel_mode = search_parallel( root );
		parallel_ready = true;
	}

	// start multi-thread workers
	if ( parallel_mode )
		workers = new worker[ max_threads ];
#else
	if ( search_parallel( root ) )
		plog( "\nWarning: parallel mode is not supported under current configuration\n" );
	parallel_mode = false;
#endif	

#ifndef NW
	prof.clear( );			// reset profiling times

	cover_browser( "Running...", "Use the buttons to control the simulation:\n\n'Stop' :  aborts the simulation\n'Pause' / 'Resume' :  pauses and resumes the simulation\n'Fast' :  accelerates the simulation by hiding information\n'Observe' :  presents more run-time information\n'Debug' :  triggers the debugger at flagged variables", true );
#else
	plog( "\nProcessing configuration file %s ...\n", "", struct_file );
#endif

	set_fast( 0 );			// should always start on OBSERVE and switch to FAST later
	res_list.clear( );		// empty list of saved results files

	for ( i = 1, quit = 0; i <= sim_num && quit != 2; ++i )
	{
		running = true;		// signal simulation is running
		cur_sim = i;	 	// update the current run in the set of runs
		actual_steps = 0;	// no steps performed yet
		save_ok = true;		// valid structure to save
		
		empty_cemetery( ); 	// ensure that previous data are not erroneously mixed 

#ifndef NW
		par_map.clear( );	// restart variable to parent name map for AoR
		prepare_plot( root, i );
#endif
		if ( fast_mode < 2 )
		{
			if ( parallel_mode )
				plog( "\nSimulation %d of %d running (up to %d parallel threads)...", "", i, sim_num, max_threads );
			else
				plog( "\nSimulation %d of %d running...", "", i, sim_num );
		}
		
		// if new batch configuration file, reload all
		if ( batch_sequential_loop )
		{
			if ( load_configuration( true ) != 0 )
			{
#ifndef NW 
				log_tcl_error( "Load configuration", "Configuration file not found or corrupted" );	
				cmd( "ttk::messageBox -parent . -type ok -icon error -title Error -message \"Configuration file cannot be loaded\" -detail \"Check if LSD still has WRITE access to the model directory.\nLSD will close now.\"" );
#else
				fprintf( stderr, "\nFile '%s' not found or corrupted.\n", struct_file );	
#endif
				myexit( 10 );
			}
			batch_sequential_loop = false;
		}

		// if just another run seed, reload just structure & parameters
		if ( i > 1 )
			if ( load_configuration( true, true ) != 0 )
			{
#ifndef NW 
				log_tcl_error( "Load configuration", "Configuration file not found or corrupted" );	
				cmd( "ttk::messageBox -parent . -type ok -icon error -title Error -message \"Configuration file cannot be reloaded\" -detail \"Check if LSD still has WRITE access to the model directory.\nLSD will close now.\"" );
#else
				fprintf( stderr, "\nFile '%s' not found or corrupted.\n", struct_file );
#endif
				myexit( 10 );
			}
			
		// build initial object list for user pointer checking
		if ( ! no_ptr_chk )
			build_obj_list( true );

		series_saved = 0;
		t = 1;

		if ( ! alloc_save_mem( root ) )
		{
#ifndef NW 
			log_tcl_error( "Memory allocation", "Not enough memory, too many series saved for the memory available" );
			cmd( "ttk::messageBox -parent . -type ok -icon error -title Error -message \"Not enough memory\" -detail \"Too many series saved for the available memory. Memory insufficient for %d series over %d time steps. Reduce series to save and/or time steps.\nLSD will close now.\"", series_saved, max_step );
#else
			fprintf( stderr, "\nNot enough memory. Too many series saved for the memory available.\nMemory insufficient for %d series over %d time steps.\nReduce series to save and/or time steps.\n", series_saved, max_step );
#endif
			myexit( 11 );
		}
		 
		// reset trace stack
		empty_stack( );

		// new random routine' initialization
		init_random( seed );
		
		// reset math error counters
		init_math_error( );

		seed++;
		pause_run = false;
		debug_flag = false;
		error_hard_thread = false;
		worker_ready = true;
		worker_crashed = false;
		wait_delete = NULL;
		stack_info = 0;
		use_nan = false;
		no_search = false;
		done_in = 0;
		wr_warn_cnt = 0;
		start = last_update = clock( );

		for ( t = 1; quit == 0 && t <= max_step; ++t )
		{
#ifndef NW 
			// restart runtime variables color cycle
			cur_plt = 0;

			// adjust "clock" backwards if simulation is paused
			if ( pause_run )
				t--;

			if ( when_debug == t )
			{
				debug_flag = true;
				cmd( "focustop .deb" );
			}

			// only update if simulation not paused
			if ( ! pause_run )
#endif
			{
				actual_steps = t;
				root->update( true, false );
			}

#ifndef NW
			switch ( done_in )
			{
				case 1:			// Stop button in Log window / s/S key in Runtime window
					if ( pause_run )
					{
						cmd( "wm title .log \"$origLogTit\"" );
						cmd( ".b.r2.pause conf -text Pause" );
					}
					quit = 2;
				break;

				case 2:			// Fast button in Log window / f/F key in Runtime window
					set_fast( 1 );
					debug_flag = false;
					break;

				case 3:			// Debug button in Log window / d/D key in Runtime window
					if ( ! pause_run )
					{
						when_debug = t + 1;
						debug_flag = true;
						cmd( "focustop .deb" );
					}
					else		// if paused, just call the data browser
					{
						double useless = 0;
						deb( root, NULL, "Paused by User", &useless );
					}
					break;

				case 4:			// Observe button in Log window / o/O key in Runtime window
					set_fast( 0 );
					break;
				 
				// plot window DELETE_WINDOW button handler
				case 5:
					if ( pause_run )
						cmd( "wm title .log \"$origLogTit\"" );
					quit = 2;
					break;

				// runtime plot events
				case 7:  		// center button
					center_plot( );
					break;

				case 8: 		// scroll checkbox
					scrollB = ! scrollB;
					break;

				case 9: 		// pause simulation
					pause_run = ! pause_run;
					if ( pause_run )
					{
						cmd( "set origLogTit [ wm title .log ]; wm title .log \"$origLogTit (PAUSED)\"" );
						plog( "\nSimulation %d of %d paused at case %d", "", i, sim_num, t );
						cmd( ".b.r2.pause conf -text Resume" );
					}
					else
					{
						cmd( "wm title .log \"$origLogTit\"" );
						plog( "\nSimulation %d of %d resumed at case %d", "", i, sim_num, t );
						cmd( ".b.r2.pause conf -text Pause" );
					}
					break;
			}

			done_in = 0;

			// perform scrolling if enabled
			if ( ! pause_run )
				scroll_plot( );
			
			if ( ( ( float ) clock( ) - last_update ) / CLOCKS_PER_SEC > UPD_PER )
			{
				cmd( ".p.b2.b configure -value %d", t );
				cmd( ".p.b2.i configure -text \"Case: %d of %d ([ expr { int( 100 * %d / %d ) } ]%% done)\"", min( t + 1, max_step ), max_step, t, max_step );
				cmd( "update" );
				last_update = clock( );
			}
#endif
		}	// end of for t

		unsavedData = true;			// flag unsaved simulation results
		running = false;
		deb_log( false );			// close debug log file, if any
		end = clock( );
		
		if ( fast_mode < 2 )
			plog( "\nSimulation %d of %d %s at case %d (%.2f sec.)\n", "", i, sim_num, quit == 2 ? "stopped" : "finished", t - 1, ( float ) ( end - start ) / CLOCKS_PER_SEC );

		if ( quit == 1 ) 			// for multiple simulation runs you need to reset quit
			quit = 0;
		
#ifndef NW 
		cmd( ".p.b1.b configure -value %d", cur_sim );
		cmd( ".p.b1.i configure -text \"Simulation: %d of %d ([ expr { int( 100 * %d / %d ) } ]%% done)\"", min( cur_sim + 1, sim_num ), sim_num, cur_sim, sim_num  );
		
		cmd( "destroytop .deb" );
		cmd( "update" );
		reset_plot( );
#endif
		// run user closing function, reporting error appropriately
		user_exception = true;
		close_sim( );
		user_exception = false;
		
		reset_end( root );
		root->emptyturbo( );
		
		if ( quit != 2 && ( sim_num > 1 || no_window ) )
		{
			// save results for multiple simulation runs, if any
			if ( series_saved > 0 )
			{	// remove existing path, if any, from name in case of alternative output path
				char *alt_name = clean_file( simul_name );

				if ( ! no_res )
				{
					if ( ! batch_sequential )
						sprintf( msg, "%s%s%s_%d.%s", save_alt_path ? alt_path : path, strlen( save_alt_path ? alt_path : path ) > 0 ? "/" : "", save_alt_path ? alt_name : simul_name, seed - 1, docsv ? "csv" : "res" );
					else
						sprintf( msg, "%s%s%s_%d_%d.%s", save_alt_path ? alt_path : path, strlen( save_alt_path ? alt_path : path ) > 0 ? "/" : "", save_alt_path ? alt_name : simul_name, findex, seed - 1, docsv ? "csv" : "res" );

					if ( dozip )
						strcat( msg, ".gz" );
					
					res_list.push_back( msg );
					
					if ( fast_mode < 2 )
						plog( "Saving results to file %s... ", "", msg );

					rf = new result( msg, "wt", dozip, docsv );	// create results file object
					rf->title( root, 1 );						// write header
					rf->data( root, 0, actual_steps );			// write all data
					delete rf;									// close file and delete object

					if ( fast_mode < 2 )
						plog( "Done\n" );
				}

				if ( ! grandTotal || batch_sequential )		// generate partial total files?
				{
					if ( ! batch_sequential )
					  sprintf( msg, "%s%s%s_%d_%d.%s", save_alt_path ? alt_path : path, strlen( save_alt_path ? alt_path : path ) > 0 ? "/" : "", save_alt_path ? alt_name : simul_name, seed - i, seed - 1 + sim_num - i, docsv ? "csv" : "tot" );
					else
					  sprintf( msg, "%s%s%s_%d_%d_%d.%s", save_alt_path ? alt_path : path, strlen( save_alt_path ? alt_path : path ) > 0 ? "/" : "", save_alt_path ? alt_name : simul_name, findex, seed - i, seed - 1 + sim_num - i, docsv ? "csv" : "tot" );
				}
				else										// generate single grand total file
				{
					sprintf( msg, "%s%s%s.%s", save_alt_path ? alt_path : path, strlen( save_alt_path ? alt_path : path ) > 0 ? "/" : "", save_alt_path ? alt_name : simul_name, docsv ? "csv" : "tot" );
				}

				if ( dozip )
					strcat( msg, ".gz" );
					
				if ( fast_mode < 2 && i == sim_num )		// print only for last
					plog( "\nSaving totals to file %s... ", "", msg );

				if ( i == 1 && grandTotal && ! add_to_tot )
				{
					rf = new result( msg, "wt", dozip, docsv );	// create results file object
					rf->title( root, 0 );					// write header
				}
				else
					rf = new result( msg, "a", dozip, docsv );	// add results object to existing file

				rf->data( root, actual_steps );				// write current data data
				delete rf;									// close file and delete object

				if ( fast_mode < 2 && i == sim_num )		// print only for last
					plog( "Done\n" );
			}
			else
				if ( fast_mode < 2 )
					plog( "Nothing to save: no element selected\n" );

				
			if ( batch_sequential && i == sim_num )  		// last run of current batch file?
			{
				findex++;									// try next file
				sprintf( msg, "%s_%d.lsd", simul_name, findex );
				delete [ ] struct_file;
				struct_file = new char[ strlen( msg ) + 1 ];
				strcpy( struct_file, msg );
				f = fopen( struct_file, "r" );			
				if ( f == NULL || ( fend != 0 && findex > fend ) )// no more file to process
				{
					if ( f != NULL ) 
						fclose( f );
					if ( fast_mode < 2 )
						plog( "\nFinished processing %s\n", "", simul_name );
					break;
				}
				
				if ( fast_mode < 2 )
					plog( "\nProcessing configuration file %s ...\n", "", struct_file );
				fclose( f );  								// process next file

				i = 0;   									// force restarting run count
				batch_sequential_loop = true;				// force reloading configuration
			} 
		}
	}

	if ( fast_mode == 2 )
		plog( "\nSimulation %d of %d finished at case %d\n", "", i - 1, sim_num, t - 1 );

#ifndef NW 
	uncover_browser( );
	show_prof_aggr( );
	cmd( "focustop .log" );
#endif

#ifndef NP
	// stop multi-thread workers
	delete [ ] workers;
	workers = NULL;
#endif	

	quit = 0;
}


/*********************************
SET_VAR
*********************************/
// function to set a c variable when not in a Tcl idle loop (hardcoded vars only)
#ifndef NW   
int Tcl_set_c_var( ClientData cdata, Tcl_Interp *inter, int argc, const char *argv[ ] )
{
	char vname[ MAX_ELEM_LENGTH ];
	int value;
	
	if ( argc != 3 )					// require 2 parameters: variable name and value
		return TCL_ERROR;
		
	if ( argv[ 1 ] == NULL || argv[ 2 ] == NULL )
		return TCL_ERROR;
	
	if ( ! sscanf( argv[ 1 ], "%99s", vname ) )	// remove unwanted spaces
		return TCL_ERROR;
	
	// set the appropriate variable (hardcoded in an else-if chain)
	if ( ! strcmp( vname, "done_in" ) )
	{
		if ( ! sscanf( argv[ 2 ], "%d", &value ) )	// transform to integer
			return TCL_ERROR;
	
		done_in = value;
	}
	else 
		return TCL_ERROR;
	
	return TCL_OK;		
}
#endif


/*********************************
SET_FAST
*********************************/
void set_fast( int level )
{
	if ( level > 2 )
		level = 2;
	if ( level < 0 )
		level = 0;
		
#ifndef NW
	if ( fast && level == 0 )
		enable_plot( );
		
	if ( ! fast && level > 0 )
		disable_plot( );
#endif
	
	// remove the variables stack when switching to any fast mode
	if ( fast_mode == 0 && level > 0 )
	{
		if ( when_debug > 0 || stack_info > 0 || prof_aggr_time )
		{
			plog( "\nWarning: %s is active, fast mode command ignored", "", 
				  when_debug > 0 ? "debugging" : "profiling" );
			return;
		}
		empty_stack( );
		deb_log( false );
	}
	
	fast_mode = level;
	fast = ( level == 0 ) ? false : true;
}


/*********************************
EMPTY_STACK
*********************************/
void empty_stack( void )
{
	if ( stacklog != NULL )
	{
		// remove stack allocation
		while ( stacklog->prev != NULL )
		{
			lsdstack *cur_stack = stacklog;
			stacklog = stacklog->prev;
			delete cur_stack;
		}
		// prepare for next run
		stacklog->next = NULL;
		stacklog->ns = 0;
		stacklog->vs = NULL;
		stack = 0; 
	}
	else
	{
#ifndef NW 
		log_tcl_error( "Internal error", "LSD trace stack corrupted" );	
		cmd( "ttk::messageBox -parent . -type ok -icon error -title Error -message \"Internal LSD error\" -detail \"The LSD trace stack is corrupted.\nLSD will close now.\"" );
#else
		fprintf( stderr, "\nLSD trace stack corrupted.\n" );	
#endif
		myexit( 28 );
	}	
}


/*********************************
ALLOC_SAVE_MEM
*********************************/
bool alloc_save_mem( object *r )
{
	int toquit = quit;
	bridge *cb;
	object *cur;
	variable *cv;
	
	// for each variable set the data saving support
	for ( cv = r->v; cv != NULL; cv = cv->next )
	{ 
		if ( ( cv->num_lag > 0 || cv->param == 1 ) && cv->data_loaded == '-' )
		{
			sprintf( msg, "%s '%s' in object '%s' has not been initialized", cv->param == 1 ? "parameter" : "variable", cv->label, r->label );
			error_hard( msg, "required initialization values missing", "select the object and choose menu 'Data'/'Initial Values'" );
			
			toquit = 2;
		}
		
		cv->last_update = 0;

		// choose next update step for special updating variables
		if ( cv->delay > 0 || cv->delay_range > 0 )
		{
			cv->next_update = cv->delay;
			if ( cv->delay_range > 0 )
				cv->next_update += rnd_int( 0, cv->delay_range );
		}
		
		if ( cv->save || cv->savei )
			alloc_save_var( cv );
			
#ifndef NW 
		// variable to parent name map for AoR
		par_map.insert( make_pair < string, string > ( cv->label, r->label ) );		
#endif
	}

	for ( cb = r->b; cb != NULL; cb = cb->next )
		for ( cur = cb->head; cur != NULL && quit != 2; cur = go_brother( cur ) )
			alloc_save_mem( cur );

	if ( quit != 2 )
		quit = toquit;
	
	return ! no_more_memory;
}


/*********************************
ALLOC_SAVE_VAR
*********************************/
bool alloc_save_var( variable *v )
{
	bool prev_state = no_more_memory;
	
	if ( ! running )
		return true;
	
	if ( ! no_more_memory )
	{
		if ( v->num_lag > 0 || v->param == 1 )
			v->start = t - 1;
		else
			v->start = t;
		
		v->end = max_step;

		// use C stdlib to be able to deallocate memory for deleted objects
		free( v->data );
		v->data = ( double * ) malloc( ( v->end - v->start + 1 ) * sizeof( double ) );

		if( v->data == NULL )
		{
			no_more_memory = true;
			v->save = v->savei = false;
			v->start = v->end = 0;
			
			if ( no_more_memory != prev_state )
			{
				set_lab_tit( v );
				plog( "\nWarning: cannot allocate memory for saving '%s %s' (object '%s')\n Subsequent series will not be saved\n", "", v->label, v->lab_tit, v->up->label );
			}
		}
		else
		{
			if ( v->num_lag > 0  || v->param == 1 )
				v->data[ 0 ] = v->val[ 0 ];
			
			++series_saved;
		}
	}
	else
		v->save = v->savei = false;
	
	return ! no_more_memory;
}


/*********************************
RESET_END
*********************************/
void reset_end( object *r )
{
	bridge *cb;
	object *cur;
	variable *cv;

	for ( cv = r->v; cv != NULL; cv = cv->next )
	{ 
		if ( cv->save )
			cv->end = t - 1;
		if ( cv->savei == 1 )
			save_single( cv );
	} 

	for ( cb = r->b; cb != NULL; cb = cb->next )
	{
		cur = cb->head;
		if ( cur != NULL && cur->to_compute )
			for ( ; cur != NULL; cur = go_brother( cur ) )
				reset_end( cur );
	}
}


/*********************************
RESULTS_ALT_PATH
simple tool to allow changing where results are saved.
*********************************/
void results_alt_path( const char *altPath )
{
	if ( save_alt_path )
		delete [ ] alt_path;

	if ( strlen( altPath ) == 0 )
	{
		save_alt_path = false;
		return;
	}
	  
	alt_path = new char[ strlen( altPath ) + 1 ];
	if ( sprintf( alt_path, "%s", altPath ) > 0 )
	{
		int lstChr = strlen( alt_path ) - 1;
		if ( alt_path[ lstChr ] == '\\' || alt_path[ lstChr ] == '/' )
			alt_path[ lstChr ] = '\0';
		
		struct stat sb;
		if ( stat( alt_path, &sb ) == 0 && S_ISDIR( sb.st_mode ) )
		{
			save_alt_path = true;
			return;
		}
	}
	
	delete [ ] alt_path;
	save_alt_path = false;
	plog( "\nWarning: could not open directory '%s', ignoring '-o' option.\n", "", altPath );
}


/***************************************
SEARCH_PARALLEL
***************************************/
bool search_parallel( object *r )
{
	bridge *cb; 
	variable *cv;

	// search among the variables 
	for ( cv = r->v; cv != NULL; cv=cv->next )
		if ( cv->parallel )
			return true;

	// search among descendants
	for ( cb = r->b; cb != NULL; cb = cb->next )
		if ( cb->head != NULL )
			if ( search_parallel( cb->head ) )
				return true;

	return false;
}


#ifndef NW

/*********************************
CREATE_LOGWINDOW
*********************************/
void create_logwindow( void )
{
	if ( ! tk_ok )
		myexit( 7 );

	cmd( "newtop .log \"LSD Log\" { if [ string equal [ discard_change ] ok ] { exit } } \"\"" );

	cmd( "set w .log.text" );
	cmd( "ttk::frame $w" );
	cmd( "ttk::scrollbar $w.scroll -command \"$w.text yview\"" );
	cmd( "ttk::scrollbar $w.scrollx -command \"$w.text xview\" -orient hor" );
	cmd( "ttk::text $w.text -yscrollcommand \"$w.scroll set\" -xscrollcommand \"$w.scrollx set\" -wrap none -entry 0 -dark $darkTheme -style smallFixed.TText" );
	cmd( "mouse_wheel $w.text" );
	cmd( "$w.text configure -tabs {%s}", tabs  );
	
	// Log window tags
	cmd( "$w.text tag configure highlight -foreground $colorsTheme(hl)" );
	cmd( "$w.text tag configure tabel" );
	cmd( "$w.text tag configure series -tabs {2c 5c 8c}" );
	cmd( "$w.text tag configure prof1 -tabs {5c 7.5c 9c 11.2c 13.2c 17.5c}" );
	cmd( "$w.text tag configure prof2 -tabs {3c 6c 9c}" );

	// context menu (right mouse button)
	cmd( "ttk::menu $w.text.menu -tearoff 0" );
	cmd( "$w.text.menu add command -label Copy -underline 0 -accelerator Ctrl+C -command { tk_textCopy .log.text.text }" );		// entryconfig 0
	cmd( "$w.text.menu add command -label Clear -accelerator Ctrl+Del -command { .log.text.text.internal delete 0.0 end }" );		// entryconfig 1
	cmd( "$w.text.menu add separator" );	// entryconfig 2
	cmd( "$w.text.menu add command -label Help -accelerator F1 -command { LsdHelp log.html }" );	// entryconfig 3

	cmd( "pack $w.scroll -side right -fill y" );
	cmd( "pack $w.text -expand yes -fill both" );
	cmd( "pack $w.scrollx -side bottom -fill x" );
	cmd( "pack $w -expand yes -fill both" );
	
	cmd( "bind .log.text.text <Button-2> { \
			tk_popup .log.text.text.menu %%X %%Y \
		}" );	
	cmd( "bind .log.text.text <Button-3> { \
			tk_popup .log.text.text.menu %%X %%Y \
		}" );	

	cmd( "showtop .log none 1 1 0" );
	
	cmd( "bind .log <F1> { .log.text.text.menu invoke 3 }" );
	cmd( "bind .log <Escape> { focustop . }" );
	cmd( "bind .log <Control-c> { .log.text.text.menu invoke 0 }; bind .log <Control-C> { .log.text.text.menu invoke 0 }" );
	cmd( "bind .log <Control-Delete> { .log.text.text.menu invoke 1 }" );
	
	// replace text widget default insert, delete and replace bindings, preventing the user to change it
	cmd( "rename .log.text.text .log.text.text.internal" );
	cmd( "proc .log.text.text { args } { switch -exact -- [ lindex $args 0 ] { insert { } delete { } replace { } default { return [ eval .log.text.text.internal $args] } } }" );

	cmd( "plog \"LSD Version %s (%s)\nCopyright Marco Valente and Marcelo Pereira\nLSD is distributed under the GNU General Public License\nLSD is free software and comes with ABSOLUTELY NO WARRANTY\n[ LsdEnv {  } ]\n\"", _LSD_VERSION_, _LSD_DATE_ );

	log_ok = true;
}


/*********************************
SET_SHORTCUTS_RUN
*********************************/
void set_shortcuts_run( const char *window )
{
	cmd( "set res [ winfo exists %s ]", window );
	
	if ( get_bool( "res" ) )
	{
		cmd( "bind %s <KeyPress-s> { catch { .b.r2.stop invoke } }; bind %s <KeyPress-S> { catch { .b.r2.stop invoke } }", window, window );
		cmd( "bind %s <KeyPress-p> { catch { .b.r2.pause invoke } }; bind %s <KeyPress-P> { catch { .b.r2.pause invoke } }", window, window );
		cmd( "bind %s <KeyPress-r> { catch { .b.r2.pause invoke } }; bind %s <KeyPress-R> { catch { .b.r2.pause invoke } }", window, window );
		cmd( "bind %s <KeyPress-f> { catch { .b.r2.speed invoke } }; bind %s <KeyPress-F> { catch { .b.r2.speed invoke } }", window, window );
		cmd( "bind %s <KeyPress-o> { catch { .b.r2.obs invoke } }; bind %s <KeyPress-O> { catch { .b.r2.obs invoke } }", window, window );
		cmd( "bind %s <KeyPress-d> { catch { .b.r2.deb invoke } }; bind %s <KeyPress-D> { catch { .b.r2.deb invoke } }", window, window );
	}
}


/*********************************
UNSET_SHORTCUTS_RUN
*********************************/
void unset_shortcuts_run( const char *window )
{
	cmd( "set res [ winfo exists %s ]", window );
	
	if ( get_bool( "res" ) )
	{
		cmd( "bind %s <KeyPress-s> { }; bind %s <KeyPress-S> { }", window, window );
		cmd( "bind %s <KeyPress-p> { }; bind %s <KeyPress-P> { }", window, window );
		cmd( "bind %s <KeyPress-r> { }; bind %s <KeyPress-R> { }", window, window );
		cmd( "bind %s <KeyPress-f> { }; bind %s <KeyPress-F> { }", window, window );
		cmd( "bind %s <KeyPress-o> { }; bind %s <KeyPress-O> { }", window, window );
		cmd( "bind %s <KeyPress-d> { }; bind %s <KeyPress-D> { }", window, window );
	}
}


/*********************************
SET_BUTTONS_RUN
*********************************/
void set_buttons_run( bool enable )
{
	char state[ 9 ];
	
	cmd( "set res [ winfo exists .b.r2 ]" );
	if ( ! get_bool( "res" ) )
		return;
	
	if ( enable )
		strcpy( state, "normal" );
	else
		strcpy( state, "disabled" );
	
	cmd( "catch { .b.r2.stop configure -state %s }", state );
	cmd( "catch { .b.r2.pause configure -state %s }", state );
	cmd( "catch { .b.r2.speed configure -state %s }", state );
	cmd( "catch { .b.r2.obs configure -state %s }", state );
	cmd( "catch { .b.r2.deb configure -state %s }", state );
}


/*********************************
COVER_BROWSER
*********************************/
void cover_browser( const char *text1, const char *text2, bool run )
{
	if ( brCovered )		// ignore if already covered
		return;
		
	cmd( "destroy .bbar .m .l" );
	
	cmd( "ttk::frame .t1" );
	cmd( "ttk::label .t1.l1 -justify center -text \"%s\" -style bold.TLabel", text1  );
	cmd( "pack .t1.l1 -pady 10 -expand yes -fill y" );
	cmd( "pack .t1 -fill both -expand yes -padx 10 -pady 10" );
	
	if ( run )
	{
		cmd( "ttk::frame .p" );
		cmd( "ttk::label .p.l -text \"Simulation progress\"" );
		
		cmd( "ttk::frame .p.b1" );
		cmd( "ttk::progressbar .p.b1.b -maximum %d -value 0", sim_num );
		cmd( "ttk::label .p.b1.i -text \"Simulation: 0 of %d (0%% done)\"", sim_num );
		cmd( "pack .p.b1.b .p.b1.i -pady 5 -expand yes -fill x" );
		
		cmd( "ttk::frame .p.b2" );
		cmd( "ttk::progressbar .p.b2.b -maximum %d -value 0", max_step );
		cmd( "ttk::label .p.b2.i -text \"Case: 0 of %d (0%% done)\"", max_step );
		cmd( "pack .p.b2.b .p.b2.i -pady 5 -expand yes -fill x" );
		
		if ( sim_num > 1 )
			cmd( "pack .p.l .p.b1 .p.b2 -pady 10 -expand yes -fill x" );
		else
			cmd( "pack .p.l .p.b2 -pady 10 -expand yes -fill x" );

		cmd( "pack .p -fill x -expand yes -padx 20 -pady 5" );
	}
	
	cmd( "ttk::frame .t2" );
	cmd( "ttk::label .t2.l1 -justify left -text \"\n%s\"", text2 );
	cmd( "pack .t2.l1 -expand yes -fill y" );
	cmd( "pack .t2 -fill both -expand yes -padx 10 -pady 10" );
	
	if ( run )
	{
		cmd( "if [ string equal $CurPlatform windows ] { \
				set goWid $butWid \
			} elseif [ string equal $CurPlatform linux ] { \
				set goWid $butWid \
			} { \
				set goWid [ expr { $butWid - 1 } ] \
			}" );
			
		cmd( "ttk::frame .b" );
		cmd( "ttk::frame .b.r2" );
		cmd( "ttk::button .b.r2.stop -width $goWid -text Stop -command { set_c_var done_in 1 } -underline 0" );
		cmd( "ttk::button .b.r2.pause -width $goWid -text Pause -command { set_c_var done_in 9 } -underline 0" );
		cmd( "ttk::button .b.r2.speed -width $goWid -text Fast -command { set_c_var done_in 2 } -underline 0" );
		cmd( "ttk::button .b.r2.obs -width $goWid -text Observe -command { set_c_var done_in 4 } -underline 0" );
		cmd( "ttk::button .b.r2.deb -width $goWid -text Debug -command { set_c_var done_in 3 } -underline 0" );
		cmd( "pack .b.r2.stop .b.r2.pause .b.r2.speed .b.r2.obs .b.r2.deb -padx $butSpc -side left" );
		cmd( "pack .b.r2" );
		cmd( "pack .b -padx $butPad -pady $butPad -side right" );

		cmd( "bind . <F1> { LsdHelp runtime.html#buttons }" );
		set_shortcuts_run( "." );
		set_shortcuts_run( ".log" );
		set_shortcuts_run( ".str" );
	}
	else
	{
		cmd( "set origMainTit [ wm title . ]" );
		cmd( "wm title . \"$origMainTit (DISABLED)\"" );
	}
	
	cmd( "update" );
	
	brCovered = true;
	redrawRoot = false;
}


/*********************************
UNCOVER_BROWSER
*********************************/
void uncover_browser( void )
{
	if ( ! brCovered || running )	// ignore if not covered or running
		return;

	unset_shortcuts_run( "." );
	unset_shortcuts_run( ".log" );
	unset_shortcuts_run( ".str" );
		
	cmd( "destroytop .deb" );
	cmd( "destroy .t1 .p .t2 .b" );
	
	cmd( "if [ info exists origMainTit ] { \
			wm title . $origMainTit; \
			unset origMainTit \
		}" );
	
	cmd( "if { [ string equal [ wm state . ] normal ] } { \
			focustop . \
		}" );

	brCovered = false;
	redrawRoot = true;
}


/*********************************
SHOW_PROF_AGGR
*********************************/
struct item
{
	const char *var, *obj;
	unsigned int time;
	unsigned int count;
};

bool comp_item( item& item1, item& item2 )
{
	int comp_str = strcmp( item1.obj, item2.obj );
	if ( ! comp_str )
		return item1.time > item2.time;
	else
		return comp_str < 0;
}

void show_prof_aggr( void )
{
	if ( ! prof_aggr_time )
		return;

	item elem;
	list < item > vars;
	list < item >::iterator it1;
	variable *cv;
	map < string, profile >::iterator it2;
	
	plog( "\nProfiling aggregated results:\n" );
	plog( "\nObject\tElement\tTime (msec.)\tComputation count", "prof2" );
	
	for ( it2 = prof.begin(); it2 != prof.end(); ++it2 )
	{
		elem.var = it2->first.c_str( );
		cv = root->search_var( NULL, elem.var );
		elem.obj = ( cv == NULL ) ? NULL : cv->up->label;
		elem.time = 1000 * it2->second.ticks / CLOCKS_PER_SEC;
		elem.count = it2->second.comp;
		vars.push_back( elem );
	}
	
	vars.sort( comp_item );
	
	for ( it1 = vars.begin(); it1 != vars.end(); ++it1 )
		plog( "\n%-12.12s\t%-12.12s\t%d\t%d", "prof2", it1->obj, it1->var, it1->time, it1->count );
	
	plog( "\n" );
}

#endif


/*******************************************
DEB_LOG
Creates/saves the file "log.txt" and 
enable/disable logging the variables 
computation order and enable/disable the 
debugger 
********************************************/
void deb_log( bool on, int time )
{ 
#ifndef NW  
	// check if should turn off
	if ( ! on || parallel_mode || fast_mode != 0 )
	{
		// disable debugging
		if ( time > t && when_debug >= time )
			when_debug = 0;
		else
			if ( ( time == 0 && when_debug == t ) || time == t )
				debug_flag = false;
			
		// act now?
		if ( time == 0 || t > time )
		{
			// close file if open
			if ( log_file != NULL )
			{
				fclose( log_file );
				log_file = NULL;
			}
		}
		else
			log_stop = time;
	}

	// check if should turn on
	if ( on && ! parallel_mode && fast_mode == 0 )
	{
		// enable debugging
		if ( time > t )
			when_debug = time;
		else
			if ( time == 0 || time == t )
			{
				when_debug = t;
				debug_flag = true;
				cmd( "focustop .deb" );
			}
		
		// ignore if log already open
		if ( log_file == NULL )
		{
			log_file = fopen( "log.txt", "a" );
			log_start = time;
			log_stop = max_step;
		}
	}
	
	if ( on && ( parallel_mode || fast_mode > 0 ) )
		plog( "\nWarning: %s is active, debug command ignored", "", 
			  parallel_mode ? "parallel processing" : "fast mode" );
			
#endif
}
