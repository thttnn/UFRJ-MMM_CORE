	
Label Root
{
	Son: INIT
	Label INIT
	{
		Son: MACRO
		Label MACRO
		{
			Son: SECTORS
			Label SECTORS
			{
				Son: FIRMS
				Label FIRMS
				{
					Son: CAPITALS
					Label CAPITALS
					{
						Param: capital_good_date_birth
						Param: capital_good_depreciation_period
						Param: capital_good_productive_capacity
						Param: capital_good_productivity_initial
						Param: capital_good_to_depreciate
						Param: capital_good_to_replace
						Param: id_capital_good_number
						Var: Capital_Good_Acumulated_Production
						Var: Capital_Good_Production
						Var: Capital_Good_Productivity

					}

					Param: firm_date_birth
					Param: id_firm_number
					Var: Firm_Available_Debt
					Var: Firm_Available_Financial_Assets
					Var: Firm_Available_Funds_Replacement
					Var: Firm_Available_Inputs_Ratio
					Var: Firm_Avg_Potential_Markup
					Var: Firm_Capital
					Var: Firm_Competitiveness
					Var: Firm_Debt_Rate
					Var: Firm_Delivery_Delay
					Var: Firm_Demand_Capital_Goods
					Var: Firm_Demand_Productive_Capacity_Expansion
					Var: Firm_Productive_Capacity_Depreciation
					Var: Firm_Desired_Expansion_Investment_Expenses
					Var: Firm_Desired_Market_Share
					Var: Firm_Desired_Markup
					Var: Firm_Desired_Price
					Var: Firm_Effective_Market_Share
					Var: Firm_Effective_Markup
					Var: Firm_Effective_Orders
					Var: Firm_Effective_Orders_Capital_Goods
					Var: Firm_Effective_Production
					Var: Firm_Effective_Productive_Capacity_Variation
					Var: Firm_Expected_Sales
					Var: Firm_Expected_Sales_Long_Term
					Var: Firm_Avg_Debt_Rate
					Var: Firm_Avg_Market_Share
					Var: Firm_Avg_Productivity
					Var: Firm_Financial_Assets_Return
					Var: Firm_Debt_Flow
					Var: Firm_Financial_Assets_Flow
					Var: Firm_Frontier_Productivity
					Var: Firm_Total_Funds
					Var: Firm_Imitation_Productivity
					Var: Firm_Indirect_Tax
					Var: Firm_Innovation_Productivity
					Var: Firm_Input_Cost
					Var: Firm_Input_Demand_Next_Period
					Var: Firm_Interest_Rate
					Var: Firm_Stock_Inventories
					Var: Firm_Inventories_Variation
					Var: Firm_Effective_Expansion_Investment_Expenses
					Var: Firm_Market_Share
					Var: Firm_Max_Productivity
					Var: Firm_Net_Profits
					Var: Firm_Net_Revenue
					Var: Firm_Planned_Production
					Var: Firm_Potential_Markup
					Var: Firm_Price
					Var: Firm_Productive_Capacity
					Var: Firm_Distributed_Profits
					Var: Firm_RND_Expenses
					Var: Firm_Demand_Productive_Capacity_Replacement
					Var: Firm_Required_Inputs
					Var: Firm_Retained_Profits
					Var: Firm_Revenue
					Var: Firm_Sales
					Var: Firm_Stock_Debt
					Var: Firm_Stock_Financial_Assets
					Var: Firm_Stock_Inputs
					Var: Firm_Variable_Cost
					Var: Firm_Replacement_Expenses
					Var: Firm_Available_Funds_After_Replacement
					Var: Firm_Wage
					Var: Firm_Quality
					Var: Firm_Investment_Period
					Var: Firm_Modernization_Rate
					Var: Firm_Capacity_Utilization
					Var: Firm_Demand_Capital_Goods_Expansion
					Var: Firm_Demand_Capital_Goods_Replacement
					Var: Firm_Effective_Capital_Goods_Expansion
					Var: Firm_Effective_Capital_Goods_Replacement
					Var: Firm_Imitation_Quality
					Var: Firm_Innovation_Quality

				}

				Param: sector_capital_output_ratio
				Param: sector_depreciation_period
				Param: sector_desired_debt_rate
				Param: sector_desired_degree_capacity_utilization
				Param: sector_desired_financial_rate
				Param: sector_desired_inventories_proportion
				Param: sector_elascitity_delay
				Param: sector_elasticity_price
				Param: sector_elasticity_quality
				Param: sector_expectations
				Param: sector_exports_elasticity_income
				Param: sector_exports_elasticity_price
				Param: sector_external_price_competitiveness
				Param: sector_external_price_growth
				Param: id_capital_goods_sector
				Param: id_consumption_goods_sector
				Param: id_intermediate_goods_sector
				Param: sector_indirect_tax_rate
				Param: sector_initial_productivity
				Param: sector_initial_quality
				Param: sector_innovation_proportion
				Param: sector_input_tech_coefficient
				Param: sector_investment_period
				Param: sector_learning_adjustment
				Param: sector_market_share_expansion
				Param: sector_markup_apropriation
				Param: sector_markup_period
				Param: sector_profits_distribution_rate
				Param: sector_rnd_revenue_proportion
				Param: sector_exports_coefficient
				Param: sector_passthrough_inflation
				Param: sector_passthrough_productivity
				Param: sector_std_dev_innovation
				Param: sector_strategic_price_weight
				Param: sector_survival_period
				Param: sector_tech_opportunity
				Var: Sector_Avg_Competitiveness
				Var: Sector_Avg_Debt_Rate
				Var: Sector_Avg_Markup
				Var: Sector_Avg_Price
				Var: Sector_Avg_Productivity
				Var: Sector_Avg_Quality
				Var: Sector_Avg_Wage
				Var: Sector_Domestic_Capital_Demand
				Var: Sector_Domestic_Consumption_Demand
				Var: Sector_Demand_Met
				Var: Sector_Demand_Met_By_Imports
				Var: Sector_Effective_Orders
				Var: Sector_Effective_Production
				Var: Sector_Employment
				Var: Sector_Entry_Condition
				Var: Sector_Exports
				Var: Sector_External_Price
				Var: Sector_Extra_Imports
				Var: Sector_Domestic_Intermediate_Demand
				Var: Sector_Inventories
				Var: Sector_Inverse_HHI
				Var: Sector_Max_Productivity
				Var: Sector_Max_Quality
				Var: Sector_Normalized_HHI
				Var: Sector_Number_Firms
				Var: Sector_Participation
				Var: Sector_Potential_Employment
				Var: Sector_Productive_Capacity
				Var: Sector_Productive_Capacity_Available
				Var: Sector_Productive_Capacity_Entry
				Var: Sector_Productive_Capacity_Exit
				Var: Sector_Quality_Growth
				Var: Sector_Sales
				Var: Sector_Sum_Market_Share
				Var: Sector_Turbulence
				Var: Sector_Unemployment
				Var: Sector_Taxation

			}

			Son: CLASSES
			Label CLASSES
			{
				Param: class_autonomous_consumption_adjustment
				Param: class_direct_tax
				Param: class_interest_payment_share
				Param: class_max_debt_ratio
				Param: class_period
				Param: class_profit_share
				Param: class_propensity_to_consume
				Param: class_propensity_to_import
				Param: class_wage_share
				Var: Class_Autonomous_Consumption
				Var: Class_Debt
				Var: Class_Debt_Payment
				Var: Class_Debt_Ratio
				Var: Class_Effective_Domestic_Consumption
				Var: Class_Effective_Imports
				Var: Class_Expenses
				Var: Class_Financial_Asset_Return
				Var: Class_Financial_Assets
				Var: Class_Government_Interest_Payment
				Var: Class_Nominal_Income
				Var: Class_Real_Domestic_Consumption
				Var: Class_Real_Imports
				Var: Class_Real_Income
				Var: Class_Savings
				Var: Class_Taxation

			}

			Son: GOVERNMENT
			Label GOVERNMENT
			{
				Param: basic_percent_spread
				Param: government_expectations
				Param: government_period
				Param: government_surplus_rate_target
				Param: inflation_sensitivity
				Param: inflation_target
				Param: interest_rate
				Param: interest_rate_adjustment
				Param: unemployment_sensitivity
				Param: unemployment_target
				Var: Basic_Interest_Rate
				Var: Government_Debt
				Var: Government_Debt_GDP_Ratio
				Var: Government_Deficit
				Var: Government_Interest_Payment
				Var: Government_Max_Expenses
				Var: Government_Primary_Surplus
				Var: Government_Wages
				Var: Total_Income_Taxes
				Var: Total_Indirect_Taxes
				Var: Total_Taxes

			}

			Son: EXTERNAL_SECTOR
			Label EXTERNAL_SECTOR
			{
				Param: International_Reserves
				Param: exchange_rate_growth
				Param: external_income_fixed_growth
				Param: external_income_growth_adjustment
				Var: Exchange_Rate
				Var: External_Income
				Var: Trade_Balance

			}

			Son: ANALYSIS
			Label ANALYSIS
			{
				Var: C
				Var: CGDP
				Var: CON_G
				Var: C_r
				Var: Cri
				Var: DEBT_C
				Var: DEBT_I
				Var: DEBT_K
				Var: EMP
				Var: EMP_G
				Var: GDP_G
				Var: GGDP
				Var: GOV_G
				Var: G_n
				Var: G_r
				Var: HHI_C
				Var: HHI_I
				Var: HHI_K
				Var: I
				Var: IGDP
				Var: INVE_G
				Var: INVE_r
				Var: INVGDP
				Var: INV_G
				Var: I_r
				Var: KGDP
				Var: KL
				Var: K_G
				Var: K_r
				Var: MK
				Var: MK_C
				Var: MK_G
				Var: MK_I
				Var: MK_K
				Var: M_G
				Var: M_r
				Var: NXGDP
				Var: NX_G
				Var: NX_r
				Var: P
				Var: PCU
				Var: PDEBT
				Var: PDEBT_G
				Var: PR
				Var: PROD
				Var: PROD_C
				Var: PROD_G
				Var: PROD_I
				Var: PROD_K
				Var: PROFITS
				Var: PROFITS_G
				Var: P_C
				Var: P_G
				Var: P_I
				Var: P_K
				Var: U
				Var: U_C
				Var: U_I
				Var: U_K
				Var: WAGE
				Var: WAGE_G
				Var: W_C
				Var: W_I
				Var: W_K
				Var: X_G
				Var: X_r

			}

			Param: annual_period
			Param: crisis_threshold
			Param: initial_avg_price
			Var: Country_Annual_Growth
			Var: Country_Annual_CPI_Inflation
			Var: Country_Annual_Real_Growth
			Var: Country_Avg_Markup
			Var: Country_Avg_Productivity
			Var: Country_Avg_Profit_Rate
			Var: Country_Avg_Capacity_Utilization
			Var: Country_Consumer_Price_Index
			Var: Exit
			Var: Exit_Defaulted_Loans
			Var: Exit_Deposits_Distributed
			Var: Exit_Productive_Capacity
			Var: Country_GDP
			Var: Country_GDP_Demand
			Var: Country_Gross_Value_Production
			Var: Country_Likelihood_Crisis
			Var: Country_Observed_Capital_Labor_Ratio
			Var: Country_Observed_Capital_Output_Ratio
			Var: Country_Price_Capital_Goods
			Var: Country_Price_Index
			Var: Country_Profit_Share
			Var: Country_Real_GDP
			Var: SFC_Financial_Sector_Wealth
			Var: SFC_Financial_Sector_Wealth_2
			Var: SFC_Net_Rentability_Financial_Assets
			Var: SFC_Total_Financial_Assets_Return_Classes
			Var: SFC_Total_Financial_Assets_Return_Firms
			Var: SFC_Total_Funds
			Var: SFC_Total_Interest_Payments_Classes
			Var: SFC_Total_Interest_Payments_Firms
			Var: SFC_Total_Savings
			Var: SFC_Total_Variation_Debt_Classes
			Var: SFC_Total_Variation_Debt_Firms
			Var: SFC_Total_Variation_Financial_Assets_Classes
			Var: SFC_Total_Variation_Financial_Assets_Firms
			Var: Country_Autonomous_Consumption
			Var: Country_Autonomous_Investment
			Var: Country_Capital_Stock
			Var: Country_Classes_Expenses
			Var: Country_Consumption
			Var: Country_Distributed_Profits
			Var: Country_Exports
			Var: Country_Imports
			Var: Country_Induced_Investment
			Var: Country_Intermediate
			Var: Country_Inventories
			Var: Country_Inventories_Variation
			Var: Country_Investment
			Var: Country_Investment_Expenses
			Var: Country_Productive_Capacity_Depreciated
			Var: Country_Productive_Capacity_Expansion
			Var: Country_Productive_Capacity_Replacement
			Var: Country_Profits
			Var: Country_Wages
			Var: Country_Unemployment
			Var: Country_Wage_Share

		}

		Param: C_alpha
		Param: C_beta
		Param: C_d
		Param: C_delta
		Param: C_eta
		Param: C_exp_sh
		Param: C_i_per
		Param: C_lambda
		Param: C_mk
		Param: C_mk_per
		Param: C_phi
		Param: C_psi
		Param: C_q
		Param: C_sigma
		Param: C_tau
		Param: C_w
		Param: I_alpha
		Param: I_beta
		Param: I_d
		Param: I_delta
		Param: I_eta
		Param: I_exp_sh
		Param: I_i_per
		Param: I_lambda
		Param: I_mk
		Param: I_mk_per
		Param: I_phi
		Param: I_psi
		Param: I_q
		Param: I_sigma
		Param: I_tau
		Param: I_w
		Param: K_alpha
		Param: K_beta
		Param: K_d
		Param: K_delta
		Param: K_eta
		Param: K_exp_sh
		Param: K_i_per
		Param: K_lambda
		Param: K_mk
		Param: K_mk_per
		Param: K_phi
		Param: K_psi
		Param: K_q
		Param: K_sigma
		Param: K_tau
		Param: K_w
		Param: a_per
		Param: aut_con
		Param: c_per
		Param: depre_per
		Param: gov_per
		Param: i_per
		Param: ir
		Param: mk_per
		Var: Calibration
		Var: Time_Step

	}


}


DATA

Object: Root C	1

Object: INIT C	1
Param: C_alpha 0 n + n n	0.4
Param: C_beta 0 n + n n	2
Param: C_d 0 n + n n	0.9
Param: C_delta 0 n + n n	60
Param: C_eta 0 n + n n	20
Param: C_exp_sh 0 n + n n	0.333333
Param: C_i_per 0 n + n n	6
Param: C_lambda 0 n + n n	0.01
Param: C_mk 0 n + n n	1.5
Param: C_mk_per 0 n + n n	2
Param: C_phi 0 n + n n	1
Param: C_psi 0 n + n n	0.9
Param: C_q 0 n + n n	1
Param: C_sigma 0 n + n n	0.1
Param: C_tau 0 n + n n	0
Param: C_w 0 n + n n	1
Param: I_alpha 0 n + n n	0.4
Param: I_beta 0 n + n n	2
Param: I_d 0 n + n n	0.9
Param: I_delta 0 n + n n	60
Param: I_eta 0 n + n n	20
Param: I_exp_sh 0 n + n n	0.33333
Param: I_i_per 0 n + n n	6
Param: I_lambda 0 n + n n	0.01
Param: I_mk 0 n + n n	1.5
Param: I_mk_per 0 n + n n	2
Param: I_phi 0 n + n n	1
Param: I_psi 0 n + n n	0.9
Param: I_q 0 n + n n	1
Param: I_sigma 0 n + n n	0.1
Param: I_tau 0 n + n n	0
Param: I_w 0 n + n n	1
Param: K_alpha 0 n + n n	0.4
Param: K_beta 0 n + n n	2
Param: K_d 0 n + n n	0.9
Param: K_delta 0 n + n n	60
Param: K_eta 0 n + n n	20
Param: K_exp_sh 0 n + n n	0.33333
Param: K_i_per 0 n + n n	6
Param: K_lambda 0 n + n n	0.01
Param: K_mk 0 n + n n	1.5
Param: K_mk_per 0 n + n n	2
Param: K_phi 0 n + n n	1
Param: K_psi 0 n + n n	0.9
Param: K_q 0 n + n n	1
Param: K_sigma 0 n + n n	0.1
Param: K_tau 0 n + n n	0
Param: K_w 0 n + n n	1
Param: a_per 0 n + n n	4
Param: aut_con 0 n + n n	20
Param: c_per 0 n + n n	4
Param: depre_per 0 n + n n	60
Param: gov_per 0 n + n n	4
Param: i_per 0 n + n n	6
Param: ir 0 n + n n	0
Param: mk_per 0 n + n n	4
Var: Calibration 0 n + n n
Var: Time_Step 0 n + d n

Object: MACRO C	1
Param: annual_period 0 n + n n	4
Param: crisis_threshold 0 n + n n	0
Param: initial_avg_price 0 n + n n	1
Var: Country_Annual_Growth 1 n + n n	0
Var: Country_Annual_CPI_Inflation 1 s + n n	0
Var: Country_Annual_Real_Growth 1 s + n n	0
Var: Country_Avg_Markup 0 s + n n
Var: Country_Avg_Productivity 5 s + n n	1	1	1	1	1
Var: Country_Avg_Profit_Rate 0 s + n n
Var: Country_Avg_Capacity_Utilization 0 s + n n
Var: Country_Consumer_Price_Index 5 n + n n	1	1	1	1	1
Var: Exit 0 n + n n
Var: Exit_Defaulted_Loans 0 n + n n
Var: Exit_Deposits_Distributed 0 n + n n
Var: Exit_Productive_Capacity 0 n + n n
Var: Country_GDP 10 s + n p	294	294	294	294	294	294	294	294	294	294
Var: Country_GDP_Demand 0 n + n n
Var: Country_Gross_Value_Production 0 n + n n
Var: Country_Likelihood_Crisis 1 n + n n	0
Var: Country_Observed_Capital_Labor_Ratio 0 s + n n
Var: Country_Observed_Capital_Output_Ratio 0 s + n n
Var: Country_Price_Capital_Goods 6 n + n n	1	1	1	1	1	1
Var: Country_Price_Index 5 n + n n	1	1	1	1	1
Var: Country_Profit_Share 0 s + n n
Var: Country_Real_GDP 8 s + n p	294	294	294	294	294	294	294	294
Var: SFC_Financial_Sector_Wealth 0 n + n n
Var: SFC_Financial_Sector_Wealth_2 0 n + n n
Var: SFC_Net_Rentability_Financial_Assets 0 n + n n
Var: SFC_Total_Financial_Assets_Return_Classes 0 n + n n
Var: SFC_Total_Financial_Assets_Return_Firms 0 n + n n
Var: SFC_Total_Funds 0 n + n n
Var: SFC_Total_Interest_Payments_Classes 0 n + n n
Var: SFC_Total_Interest_Payments_Firms 0 n + n n
Var: SFC_Total_Savings 0 n + n n
Var: SFC_Total_Variation_Debt_Classes 0 n + n n
Var: SFC_Total_Variation_Debt_Firms 0 n + n n
Var: SFC_Total_Variation_Financial_Assets_Classes 0 n + n n
Var: SFC_Total_Variation_Financial_Assets_Firms 0 n + n n
Var: Country_Autonomous_Consumption 0 s + n n
Var: Country_Autonomous_Investment 0 s + n n
Var: Country_Capital_Stock 0 s + n n
Var: Country_Classes_Expenses 0 n + n n
Var: Country_Consumption 0 s + n n
Var: Country_Distributed_Profits 0 n + n n
Var: Country_Exports 0 s + n n
Var: Country_Imports 0 s + n n
Var: Country_Induced_Investment 0 s + n n
Var: Country_Intermediate 0 n + n n
Var: Country_Inventories 1 n + n n	0
Var: Country_Inventories_Variation 0 n + n n
Var: Country_Investment 0 s + n n
Var: Country_Investment_Expenses 0 n + n n
Var: Country_Productive_Capacity_Depreciated 0 n + n n
Var: Country_Productive_Capacity_Expansion 0 s + n n
Var: Country_Productive_Capacity_Replacement 0 s + n n
Var: Country_Profits 0 s + n n
Var: Country_Wages 0 s + n n
Var: Country_Unemployment 5 s + n n	0.18	0.18	0.18	0.18	0.18
Var: Country_Wage_Share 0 s + n n

Object: SECTORS C	3
Param: sector_capital_output_ratio 0 n + n n	2	2	2
Param: sector_depreciation_period 0 n + n n	60	60	60
Param: sector_desired_debt_rate 0 n + n n	0.5	0.5	0.5
Param: sector_desired_degree_capacity_utilization 0 n + n n	0.9	0.9	0.9
Param: sector_desired_financial_rate 0 n + n n	0.05	0.05	0.05
Param: sector_desired_inventories_proportion 0 n + n n	0.1	0.1	0.1
Param: sector_elascitity_delay 0 n + n n	0.25	0.25	0.25
Param: sector_elasticity_price 0 n + n n	1	1	1
Param: sector_elasticity_quality 0 n + n n	0.5	0.5	0.5
Param: sector_expectations 0 n + n n	0.2	0.2	0.2
Param: sector_exports_elasticity_income 0 n + n n	1	1	1
Param: sector_exports_elasticity_price 0 n + n n	0.5	0.5	0.5
Param: sector_external_price_competitiveness 0 n + n n	1	1	1
Param: sector_external_price_growth 0 n + n n	0	0	0
Param: id_capital_goods_sector 0 n + n n	0	1	0
Param: id_consumption_goods_sector 0 n + n n	1	0	0
Param: id_intermediate_goods_sector 0 n + n n	0	0	1
Param: sector_indirect_tax_rate 0 n + n n	0	0	0
Param: sector_initial_productivity 0 n + n n	1	1	1
Param: sector_initial_quality 0 n + n n	1	1	1
Param: sector_innovation_proportion 0 n + n n	0.5	0.5	0.5
Param: sector_input_tech_coefficient 0 n + n n	0.4	0.4	0.4
Param: sector_investment_period 0 n + n n	6	6	6
Param: sector_learning_adjustment 0 n + n n	0	0	0
Param: sector_market_share_expansion 0 n + n n	0.5	0.5	0.5
Param: sector_markup_apropriation 0 n + n n	0.5	0.5	0.5
Param: sector_markup_period 0 n + n n	2	2	2
Param: sector_profits_distribution_rate 0 n + n n	0.9	0.9	0.9
Param: sector_rnd_revenue_proportion 0 n + n n	0.01	0.01	0.01
Param: sector_exports_coefficient 0 n + n n	0	0	0
Param: sector_passthrough_inflation 0 s + n n	0.9	0.9	0.9
Param: sector_passthrough_productivity 0 s + n n	1	1	1
Param: sector_std_dev_innovation 0 n + n n	0.005	0.005	0.005
Param: sector_strategic_price_weight 0 n + n n	0.5	0.5	0.5
Param: sector_survival_period 0 n + n n	0	0	0
Param: sector_tech_opportunity 0 n + n n	0.001	0.001	0.001
Var: Sector_Avg_Competitiveness 1 n + n n	1	1	1
Var: Sector_Avg_Debt_Rate 0 s + n n
Var: Sector_Avg_Markup 0 s + n n
Var: Sector_Avg_Price 2 s + n n	1	1	1	1	1	1
Var: Sector_Avg_Productivity 1 s + n n	0	0	0
Var: Sector_Avg_Quality 5 s + n n	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1
Var: Sector_Avg_Wage 0 s + n n
Var: Sector_Domestic_Capital_Demand 0 n + n n
Var: Sector_Domestic_Consumption_Demand 0 n + n n
Var: Sector_Demand_Met 6 s + n n	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1
Var: Sector_Demand_Met_By_Imports 6 n + n n	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1
Var: Sector_Effective_Orders 8 s + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Sector_Effective_Production 0 s + n n
Var: Sector_Employment 5 s + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Sector_Entry_Condition 0 n + n n
Var: Sector_Exports 1 s + n n	0	0	0
Var: Sector_External_Price 1 n + n n	1	1	1
Var: Sector_Extra_Imports 0 n + n n
Var: Sector_Domestic_Intermediate_Demand 0 n + n n
Var: Sector_Inventories 1 n + n n	0	0	0
Var: Sector_Inverse_HHI 0 s + n n
Var: Sector_Max_Productivity 1 n + n n	1	1	1
Var: Sector_Max_Quality 1 n + n n	1	1	1
Var: Sector_Normalized_HHI 0 n + n n
Var: Sector_Number_Firms 0 s + n n
Var: Sector_Participation 0 s + n n
Var: Sector_Potential_Employment 0 s + n n
Var: Sector_Productive_Capacity 1 s + n n	0	0	0
Var: Sector_Productive_Capacity_Available 1 s + n n	0	0	0
Var: Sector_Productive_Capacity_Entry 0 s + n n
Var: Sector_Productive_Capacity_Exit 0 s + n n
Var: Sector_Quality_Growth 0 n + n n
Var: Sector_Sales 0 s + n n
Var: Sector_Sum_Market_Share 0 n + n n
Var: Sector_Turbulence 0 s + n n
Var: Sector_Unemployment 0 s + n n
Var: Sector_Taxation 0 n + n n

Object: FIRMS C	1	1	1
Param: firm_date_birth 0 n + n n	0	0	0
Param: id_firm_number 0 n + n n	0	0	0
Var: Firm_Available_Debt 0 n + n n
Var: Firm_Available_Financial_Assets 0 n + n n
Var: Firm_Available_Funds_Replacement 0 n + n n
Var: Firm_Available_Inputs_Ratio 0 n + n n
Var: Firm_Avg_Potential_Markup 1 n + n n	0	0	0
Var: Firm_Capital 1 n + n n	0	0	0
Var: Firm_Competitiveness 1 n + n n	1	1	1
Var: Firm_Debt_Rate 6 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Delivery_Delay 1 n + n n	1	1	1
Var: Firm_Demand_Capital_Goods 6 s + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Demand_Productive_Capacity_Expansion 7 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Productive_Capacity_Depreciation 7 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Desired_Expansion_Investment_Expenses 0 n + n n
Var: Firm_Desired_Market_Share 1 n + n n	0	0	0
Var: Firm_Desired_Markup 1 n + n n	0	0	0
Var: Firm_Desired_Price 0 n + n n
Var: Firm_Effective_Market_Share 1 n + n n	0	0	0
Var: Firm_Effective_Markup 0 n + n n
Var: Firm_Effective_Orders 12 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Effective_Orders_Capital_Goods 6 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Effective_Production 0 n + n n
Var: Firm_Effective_Productive_Capacity_Variation 0 n + n n
Var: Firm_Expected_Sales 0 n + n n
Var: Firm_Expected_Sales_Long_Term 0 n + n n
Var: Firm_Avg_Debt_Rate 1 n + n n	0	0	0
Var: Firm_Avg_Market_Share 1 n + n n	0	0	0
Var: Firm_Avg_Productivity 6 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Financial_Assets_Return 0 n + n n
Var: Firm_Debt_Flow 0 n + n n
Var: Firm_Financial_Assets_Flow 0 n + n n
Var: Firm_Frontier_Productivity 6 n + n n	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1
Var: Firm_Total_Funds 0 n + n n
Var: Firm_Imitation_Productivity 0 n + n n
Var: Firm_Indirect_Tax 0 n + n n
Var: Firm_Innovation_Productivity 0 n + n n
Var: Firm_Input_Cost 0 n + n n
Var: Firm_Input_Demand_Next_Period 0 n + n n
Var: Firm_Interest_Rate 0 n + n n
Var: Firm_Stock_Inventories 1 n + n n	1	1	1
Var: Firm_Inventories_Variation 0 n + n n
Var: Firm_Effective_Expansion_Investment_Expenses 0 n + n n
Var: Firm_Market_Share 7 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Max_Productivity 6 n + n n	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1
Var: Firm_Net_Profits 0 n + n n
Var: Firm_Net_Revenue 0 n + n n
Var: Firm_Planned_Production 0 n + n n
Var: Firm_Potential_Markup 7 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Price 1 n + n n	1	1	1
Var: Firm_Productive_Capacity 1 n + n n	0	0	0
Var: Firm_Distributed_Profits 0 n + n n
Var: Firm_RND_Expenses 0 n + n n
Var: Firm_Demand_Productive_Capacity_Replacement 6 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Required_Inputs 0 n + n n
Var: Firm_Retained_Profits 0 n + n n
Var: Firm_Revenue 1 n + n n	10	10	10
Var: Firm_Sales 1 n + n n	10	10	10
Var: Firm_Stock_Debt 1 n + n n	0	0	0
Var: Firm_Stock_Financial_Assets 1 n + n n	0	0	0
Var: Firm_Stock_Inputs 1 s + n n	0	0	0
Var: Firm_Variable_Cost 1 n + n n	0	0	0
Var: Firm_Replacement_Expenses 0 n + n n
Var: Firm_Available_Funds_After_Replacement 0 n + n n
Var: Firm_Wage 1 n + n n	0	0	0
Var: Firm_Quality 1 n + n n	1	1	1
Var: Firm_Investment_Period 0 n + n n
Var: Firm_Modernization_Rate 0 n + n n
Var: Firm_Capacity_Utilization 0 n + n n
Var: Firm_Demand_Capital_Goods_Expansion 6 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Demand_Capital_Goods_Replacement 6 n + n n	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
Var: Firm_Effective_Capital_Goods_Expansion 0 n + n n
Var: Firm_Effective_Capital_Goods_Replacement 0 n + n n
Var: Firm_Imitation_Quality 0 n + n n
Var: Firm_Innovation_Quality 0 n + n n

Object: CAPITALS C	1	1	1
Param: capital_good_date_birth 0 n + n n	0	0	0
Param: capital_good_depreciation_period 0 n + n n	1000	1000	1000
Param: capital_good_productive_capacity 0 n + n n	1	1	1
Param: capital_good_productivity_initial 0 n + n n	1	1	1
Param: capital_good_to_depreciate 0 n + n n	0	0	0
Param: capital_good_to_replace 0 n + n n	0	0	0
Param: id_capital_good_number 0 n + n n	1	1	1
Var: Capital_Good_Acumulated_Production 1 n + n n	0	0	0
Var: Capital_Good_Production 0 n + n n
Var: Capital_Good_Productivity 0 n + n n

Object: CLASSES C	2
Param: class_autonomous_consumption_adjustment 0 n + n n	1	1
Param: class_direct_tax 0 n + n n	0	0
Param: class_interest_payment_share 0 n + n n	1	0
Param: class_max_debt_ratio 0 n + n n	1	1
Param: class_period 0 n + n n	4	4
Param: class_profit_share 0 n + n n	0.9	0.1
Param: class_propensity_to_consume 0 n + n n	0.8	0.9
Param: class_propensity_to_import 0 n + n n	0	0
Param: class_wage_share 0 n + n n	0.1	0.9
Var: Class_Autonomous_Consumption 1 s + n n	5	4
Var: Class_Debt 1 s + n n	0	0
Var: Class_Debt_Payment 1 n + n n	0	0
Var: Class_Debt_Ratio 0 s + n n
Var: Class_Effective_Domestic_Consumption 0 n + n n
Var: Class_Effective_Imports 0 n + n n
Var: Class_Expenses 0 s + n n
Var: Class_Financial_Asset_Return 0 n + n n
Var: Class_Financial_Assets 4 s + n n	0	0	0	0	0	0	0	0
Var: Class_Government_Interest_Payment 0 n + n n
Var: Class_Nominal_Income 4 s + n n	0	0	0	0	0	0	0	0
Var: Class_Real_Domestic_Consumption 0 n + n n
Var: Class_Real_Imports 0 n + n n
Var: Class_Real_Income 4 n + n n	0	0	0	0	0	0	0	0
Var: Class_Savings 0 s + n n
Var: Class_Taxation 0 n + n n

Object: GOVERNMENT C	1
Param: basic_percent_spread 0 n + n n	0.5
Param: government_expectations 0 n + n n	0.3
Param: government_period 0 n + n n	4
Param: government_surplus_rate_target 0 n + n n	0
Param: inflation_sensitivity 0 n + n n	0
Param: inflation_target 0 n + n n	0
Param: interest_rate 0 n + n n	0
Param: interest_rate_adjustment 0 n + n n	0
Param: unemployment_sensitivity 0 n + n n	0
Param: unemployment_target 0 n + n n	0
Var: Basic_Interest_Rate 1 n + n n	0
Var: Government_Debt 4 n + n n	0	0	0	0
Var: Government_Debt_GDP_Ratio 0 n + n n
Var: Government_Deficit 0 n + n n
Var: Government_Interest_Payment 0 n + n n
Var: Government_Max_Expenses 1 n + n n	0
Var: Government_Primary_Surplus 0 n + n n
Var: Government_Wages 1 n + n n	0
Var: Total_Income_Taxes 0 n + n n
Var: Total_Indirect_Taxes 0 n + n n
Var: Total_Taxes 1 n + n n	0

Object: EXTERNAL_SECTOR C	1
Param: International_Reserves 1 n + n n	100000
Param: exchange_rate_growth 0 n + n n	0
Param: external_income_fixed_growth 0 n + n n	0
Param: external_income_growth_adjustment 0 n + n n	1
Var: Exchange_Rate 1 n + n n	1
Var: External_Income 1 s + n n	100
Var: Trade_Balance 0 s + n n

Object: ANALYSIS C	1
Var: C 0 s + n n
Var: CGDP 0 s + n n
Var: CON_G 0 s + n n
Var: C_r 1 s + n n	0
Var: Cri 0 s + n n
Var: DEBT_C 0 s + n n
Var: DEBT_I 0 s + n n
Var: DEBT_K 0 s + n n
Var: EMP 1 s + n n	0
Var: EMP_G 0 s + n n
Var: GDP_G 0 s + n n
Var: GGDP 0 s + n n
Var: GOV_G 0 s + n n
Var: G_n 0 s + n n
Var: G_r 1 s + n n	0
Var: HHI_C 0 s + n n
Var: HHI_I 0 s + n n
Var: HHI_K 0 s + n n
Var: I 0 s + n n
Var: IGDP 0 s + n n
Var: INVE_G 0 s + n n
Var: INVE_r 1 s + n n	0
Var: INVGDP 0 s + n n
Var: INV_G 0 s + n n
Var: I_r 1 s + n n	0
Var: KGDP 0 s + n n
Var: KL 0 s + n n
Var: K_G 0 s + n n
Var: K_r 1 s + n n	0
Var: MK 1 s + n n	0
Var: MK_C 0 s + n n
Var: MK_G 0 s + n n
Var: MK_I 0 s + n n
Var: MK_K 0 s + n n
Var: M_G 0 s + n n
Var: M_r 1 s + n n	0
Var: NXGDP 0 s + n n
Var: NX_G 0 s + n n
Var: NX_r 1 s + n n	0
Var: P 0 s + n n
Var: PCU 0 s + n n
Var: PDEBT 1 s + n n	0
Var: PDEBT_G 0 s + n n
Var: PR 0 s + n n
Var: PROD 1 s + n n	0
Var: PROD_C 0 s + n n
Var: PROD_G 0 s + n n
Var: PROD_I 0 s + n n
Var: PROD_K 0 s + n n
Var: PROFITS 1 s + n n	0
Var: PROFITS_G 0 s + n n
Var: P_C 0 s + n n
Var: P_G 0 s + n n
Var: P_I 0 s + n n
Var: P_K 0 s + n n
Var: U 0 s + n n
Var: U_C 0 s + n n
Var: U_I 0 s + n n
Var: U_K 0 s + n n
Var: WAGE 1 s + n n	0
Var: WAGE_G 0 s + n n
Var: W_C 0 s + n n
Var: W_I 0 s + n n
Var: W_K 0 s + n n
Var: X_G 0 s + n n
Var: X_r 1 s + n n	0

SIM_NUM 1
SEED 1
MAX_STEP 600
EQUATION fun_MMM_CORE.cpp
MODELREPORT report_Sim1.html

DESCRIPTION

Object_Root

END_DESCRIPTION

Object_INIT

END_DESCRIPTION

Parameter_C_alpha

_INIT_
All 1 instances equal to 0.4.
END_DESCRIPTION

Parameter_C_beta

_INIT_
All 1 instances equal to 2.
END_DESCRIPTION

Parameter_C_d

_INIT_
All 1 instances equal to 0.9.
END_DESCRIPTION

Parameter_C_delta

_INIT_
All 1 instances equal to 60.
END_DESCRIPTION

Parameter_C_eta

_INIT_
All 1 instances equal to 20.
END_DESCRIPTION

Parameter_C_exp_sh

_INIT_
All 1 instances equal to 0.333333.
END_DESCRIPTION

Parameter_C_i_per

_INIT_
All 1 instances equal to 6.
END_DESCRIPTION

Parameter_C_lambda

_INIT_
All 1 instances equal to 0.01.
END_DESCRIPTION

Parameter_C_mk

_INIT_
All 1 instances equal to 1.5.
END_DESCRIPTION

Parameter_C_mk_per

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_C_phi

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_C_psi

_INIT_
All 1 instances equal to 0.9.
END_DESCRIPTION

Parameter_C_q

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_C_sigma

_INIT_
All 1 instances equal to 0.1.
END_DESCRIPTION

Parameter_C_tau

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_C_w

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_I_alpha

_INIT_
All 1 instances equal to 0.4.
END_DESCRIPTION

Parameter_I_beta

_INIT_
All 1 instances equal to 2.
END_DESCRIPTION

Parameter_I_d

_INIT_
All 1 instances equal to 0.9.
END_DESCRIPTION

Parameter_I_delta

_INIT_
All 1 instances equal to 60.
END_DESCRIPTION

Parameter_I_eta

_INIT_
All 1 instances equal to 20.
END_DESCRIPTION

Parameter_I_exp_sh

_INIT_
All 1 instances equal to 0.33333.
END_DESCRIPTION

Parameter_I_i_per

_INIT_
All 1 instances equal to 6.
END_DESCRIPTION

Parameter_I_lambda

_INIT_
All 1 instances equal to 0.01.
END_DESCRIPTION

Parameter_I_mk

_INIT_
All 1 instances equal to 1.5.
END_DESCRIPTION

Parameter_I_mk_per

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_I_phi

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_I_psi

_INIT_
All 1 instances equal to 0.9.
END_DESCRIPTION

Parameter_I_q

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_I_sigma

_INIT_
All 1 instances equal to 0.1.
END_DESCRIPTION

Parameter_I_tau

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_I_w

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_K_alpha

_INIT_
All 1 instances equal to 0.4.
END_DESCRIPTION

Parameter_K_beta

_INIT_
All 1 instances equal to 2.
END_DESCRIPTION

Parameter_K_d

_INIT_
All 1 instances equal to 0.9.
END_DESCRIPTION

Parameter_K_delta

_INIT_
All 1 instances equal to 60.
END_DESCRIPTION

Parameter_K_eta

_INIT_
All 1 instances equal to 20.
END_DESCRIPTION

Parameter_K_exp_sh

_INIT_
All 1 instances equal to 0.33333.
END_DESCRIPTION

Parameter_K_i_per

_INIT_
All 1 instances equal to 6.
END_DESCRIPTION

Parameter_K_lambda

_INIT_
All 1 instances equal to 0.01.
END_DESCRIPTION

Parameter_K_mk

_INIT_
All 1 instances equal to 1.5.
END_DESCRIPTION

Parameter_K_mk_per

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_K_phi

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_K_psi

_INIT_
All 1 instances equal to 0.9.
END_DESCRIPTION

Parameter_K_q

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_K_sigma

_INIT_
All 1 instances equal to 0.1.
END_DESCRIPTION

Parameter_K_tau

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_K_w

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Parameter_a_per

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_aut_con

_INIT_
All 1 instances equal to 20.
END_DESCRIPTION

Parameter_c_per

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_depre_per

_INIT_
All 1 instances equal to 60.
END_DESCRIPTION

Parameter_gov_per

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_i_per

_INIT_
All 1 instances equal to 6.
END_DESCRIPTION

Parameter_ir

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_mk_per

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Variable_Calibration
Macro Parameters
END_DESCRIPTION

Variable_Time_Step

END_DESCRIPTION

Object_MACRO

END_DESCRIPTION

Parameter_annual_period

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_crisis_threshold

END_DESCRIPTION

Parameter_initial_avg_price

END_DESCRIPTION

Variable_Country_Annual_Growth

END_DESCRIPTION

Variable_Country_Annual_CPI_Inflation

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Variable_Country_Annual_Real_Growth

END_DESCRIPTION

Variable_Country_Avg_Markup

END_DESCRIPTION

Variable_Country_Avg_Productivity

END_DESCRIPTION

Variable_Country_Avg_Profit_Rate
Observed Ratio, Total Profits over Stock of Capital
END_DESCRIPTION

Variable_Country_Avg_Capacity_Utilization

END_DESCRIPTION

Variable_Country_Consumer_Price_Index

END_DESCRIPTION

Variable_Exit
This variable counts productive capacity that exited the sector in each time step. Firm objects are deleted inside that variable due to two possibilities: small market share or high debt rate. In the second case, if entry conitions are met, the firm can be bought by a new one.
This variable counts productive capacity that exited the sector in each time step. Firm objects are deleted inside that variable due to two possibilities: small market share or high debt rate. In the second case, if entry conitions are met, the firm can be bought by a new one.
END_DESCRIPTION

Variable_Exit_Defaulted_Loans

END_DESCRIPTION

Variable_Exit_Deposits_Distributed

END_DESCRIPTION

Variable_Exit_Productive_Capacity

END_DESCRIPTION

Variable_Country_GDP

END_DESCRIPTION

Variable_Country_GDP_Demand

END_DESCRIPTION

Variable_Country_Gross_Value_Production

END_DESCRIPTION

Variable_Country_Likelihood_Crisis

END_DESCRIPTION

Variable_Country_Observed_Capital_Labor_Ratio
Observed Ratio, Stock of Capital over Total Employment
END_DESCRIPTION

Variable_Country_Observed_Capital_Output_Ratio
Observed Ratio, Stock of Capital over GDP
END_DESCRIPTION

Variable_Country_Price_Capital_Goods

_INIT_
All 1 instances equal to 1.
END_DESCRIPTION

Variable_Country_Price_Index

END_DESCRIPTION

Variable_Country_Profit_Share

END_DESCRIPTION

Variable_Country_Real_GDP

END_DESCRIPTION

Variable_SFC_Financial_Sector_Wealth

END_DESCRIPTION

Variable_SFC_Financial_Sector_Wealth_2

END_DESCRIPTION

Variable_SFC_Net_Rentability_Financial_Assets

END_DESCRIPTION

Variable_SFC_Total_Financial_Assets_Return_Classes

END_DESCRIPTION

Variable_SFC_Total_Financial_Assets_Return_Firms

END_DESCRIPTION

Variable_SFC_Total_Funds

END_DESCRIPTION

Variable_SFC_Total_Interest_Payments_Classes

END_DESCRIPTION

Variable_SFC_Total_Interest_Payments_Firms

END_DESCRIPTION

Variable_SFC_Total_Savings

END_DESCRIPTION

Variable_SFC_Total_Variation_Debt_Classes

END_DESCRIPTION

Variable_SFC_Total_Variation_Debt_Firms

END_DESCRIPTION

Variable_SFC_Total_Variation_Financial_Assets_Classes

END_DESCRIPTION

Variable_SFC_Total_Variation_Financial_Assets_Firms

END_DESCRIPTION

Variable_Country_Autonomous_Consumption
Sum up nominal value of autonomous consumption
END_DESCRIPTION

Variable_Country_Autonomous_Investment
Sum up the nominal value of effective replacement investment of all firms
END_DESCRIPTION

Variable_Country_Capital_Stock
Sum up the nominal value of firms stock of capital
END_DESCRIPTION

Variable_Country_Classes_Expenses

END_DESCRIPTION

Variable_Country_Consumption

END_DESCRIPTION

Variable_Country_Distributed_Profits

END_DESCRIPTION

Variable_Country_Exports

END_DESCRIPTION

Variable_Country_Imports

END_DESCRIPTION

Variable_Country_Induced_Investment
Sum up the nominal value of effective expansion investment of all firms
END_DESCRIPTION

Variable_Country_Intermediate

END_DESCRIPTION

Variable_Country_Inventories

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Variable_Country_Inventories_Variation

END_DESCRIPTION

Variable_Country_Investment

END_DESCRIPTION

Variable_Country_Investment_Expenses

END_DESCRIPTION

Variable_Country_Productive_Capacity_Depreciated

END_DESCRIPTION

Variable_Country_Productive_Capacity_Expansion

END_DESCRIPTION

Variable_Country_Productive_Capacity_Replacement

END_DESCRIPTION

Variable_Country_Profits

END_DESCRIPTION

Variable_Country_Wages

END_DESCRIPTION

Variable_Country_Unemployment

END_DESCRIPTION

Variable_Country_Wage_Share

END_DESCRIPTION

Object_SECTORS
(no description available )
END_DESCRIPTION

Parameter_sector_capital_output_ratio
Capital/good relation for every sector related to a specific capital good sector
_INIT_
All 1 instances equal to 2.
END_DESCRIPTION

Parameter_sector_depreciation_period

_INIT_
All 3 instances equal to 1000.
END_DESCRIPTION

Parameter_sector_desired_debt_rate

_INIT_
All 1 instances equal to 0.5.
END_DESCRIPTION

Parameter_sector_desired_degree_capacity_utilization

END_DESCRIPTION

Parameter_sector_desired_financial_rate

END_DESCRIPTION

Parameter_sector_desired_inventories_proportion

END_DESCRIPTION

Parameter_sector_elascitity_delay

END_DESCRIPTION

Parameter_sector_elasticity_price

_INIT_
All 4 instances equal to 1.
END_DESCRIPTION

Parameter_sector_elasticity_quality

_INIT_
All 3 instances equal to 0.25.
END_DESCRIPTION

Parameter_sector_expectations

_INIT_
All 1 instances equal to 0.2.
END_DESCRIPTION

Parameter_sector_exports_elasticity_income

END_DESCRIPTION

Parameter_sector_exports_elasticity_price

END_DESCRIPTION

Parameter_sector_external_price_competitiveness

END_DESCRIPTION

Parameter_sector_external_price_growth

END_DESCRIPTION

Parameter_id_capital_goods_sector

END_DESCRIPTION

Parameter_id_consumption_goods_sector

END_DESCRIPTION

Parameter_id_intermediate_goods_sector

END_DESCRIPTION

Parameter_sector_indirect_tax_rate

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_sector_initial_productivity

END_DESCRIPTION

Parameter_sector_initial_quality

_INIT_
All 3 instances equal to 1.
END_DESCRIPTION

Parameter_sector_innovation_proportion

_INIT_
All 3 instances equal to 0.5.
END_DESCRIPTION

Parameter_sector_input_tech_coefficient

_INIT_
All 3 instances equal to 0.45.
END_DESCRIPTION

Parameter_sector_investment_period

END_DESCRIPTION

Parameter_sector_learning_adjustment

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Parameter_sector_market_share_expansion

_INIT_
All 1 instances equal to 0.5.
END_DESCRIPTION

Parameter_sector_markup_apropriation

_INIT_
All 3 instances equal to 0.5.
END_DESCRIPTION

Parameter_sector_markup_period

_INIT_
All 3 instances equal to 2.
END_DESCRIPTION

Parameter_sector_profits_distribution_rate

END_DESCRIPTION

Parameter_sector_rnd_revenue_proportion

END_DESCRIPTION

Parameter_sector_exports_coefficient

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Parameter_sector_passthrough_inflation

_INIT_
All 3 instances equal to 0.9.
END_DESCRIPTION

Parameter_sector_passthrough_productivity

_INIT_
All 3 instances equal to 1.
END_DESCRIPTION

Parameter_sector_std_dev_innovation

_INIT_
All 1 instances equal to 0.005.
END_DESCRIPTION

Parameter_sector_strategic_price_weight

_INIT_
All 50 instances equal to 0.5.
END_DESCRIPTION

Parameter_sector_survival_period

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_sector_tech_opportunity

_INIT_
All 1 instances equal to 0.001.
END_DESCRIPTION

Variable_Sector_Avg_Competitiveness

END_DESCRIPTION

Variable_Sector_Avg_Debt_Rate

END_DESCRIPTION

Variable_Sector_Avg_Markup

END_DESCRIPTION

Variable_Sector_Avg_Price

END_DESCRIPTION

Variable_Sector_Avg_Productivity

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Sector_Avg_Quality

END_DESCRIPTION

Variable_Sector_Avg_Wage

END_DESCRIPTION

Variable_Sector_Domestic_Capital_Demand
Calls the Capital_Goods_Demand Function and calculates the demand of other sectors.
END_DESCRIPTION

Variable_Sector_Domestic_Consumption_Demand
Stores the value of the Demand Function if it is a consumption goods sector
END_DESCRIPTION

Variable_Sector_Demand_Met

END_DESCRIPTION

Variable_Sector_Demand_Met_By_Imports

END_DESCRIPTION

Variable_Sector_Effective_Orders

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Sector_Effective_Production

END_DESCRIPTION

Variable_Sector_Employment

END_DESCRIPTION

Variable_Sector_Entry_Condition

END_DESCRIPTION

Variable_Sector_Exports

END_DESCRIPTION

Variable_Sector_External_Price

END_DESCRIPTION

Variable_Sector_Extra_Imports

END_DESCRIPTION

Variable_Sector_Domestic_Intermediate_Demand
This stores the value of the "Dom_Intermediate_Demand_Function" for each sector.
END_DESCRIPTION

Variable_Sector_Inventories

END_DESCRIPTION

Variable_Sector_Inverse_HHI

END_DESCRIPTION

Variable_Sector_Max_Productivity

END_DESCRIPTION

Variable_Sector_Max_Quality

_INIT_
All 3 instances equal to 1.
END_DESCRIPTION

Variable_Sector_Normalized_HHI
Sector Variable for Analysis
Sector Variable for Analysis
END_DESCRIPTION

Variable_Sector_Number_Firms

END_DESCRIPTION

Variable_Sector_Participation

END_DESCRIPTION

Variable_Sector_Potential_Employment

END_DESCRIPTION

Variable_Sector_Productive_Capacity

END_DESCRIPTION

Variable_Sector_Productive_Capacity_Available

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Sector_Productive_Capacity_Entry
Sector Variable
In this variable a new firm enters if there is market space available and the entry condiion is met
END_DESCRIPTION

Variable_Sector_Productive_Capacity_Exit

END_DESCRIPTION

Variable_Sector_Quality_Growth
Sector Avg Quality Annual Growth
Sector Avg Quality Annual Growth
END_DESCRIPTION

Variable_Sector_Sales

END_DESCRIPTION

Variable_Sector_Sum_Market_Share

END_DESCRIPTION

Variable_Sector_Turbulence

END_DESCRIPTION

Variable_Sector_Unemployment

END_DESCRIPTION

Variable_Sector_Taxation

END_DESCRIPTION

Object_FIRMS

END_DESCRIPTION

Parameter_firm_date_birth

END_DESCRIPTION

Parameter_id_firm_number

_INIT_
All 40 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Available_Debt

END_DESCRIPTION

Variable_Firm_Available_Financial_Assets

END_DESCRIPTION

Variable_Firm_Available_Funds_Replacement

END_DESCRIPTION

Variable_Firm_Available_Inputs_Ratio
Measures the possibilities of using the stock of intermidiate goods.
END_DESCRIPTION

Variable_Firm_Avg_Potential_Markup

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Capital

END_DESCRIPTION

Variable_Firm_Competitiveness

END_DESCRIPTION

Variable_Firm_Debt_Rate

END_DESCRIPTION

Variable_Firm_Delivery_Delay

END_DESCRIPTION

Variable_Firm_Demand_Capital_Goods

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Demand_Productive_Capacity_Expansion

END_DESCRIPTION

Variable_Firm_Productive_Capacity_Depreciation

END_DESCRIPTION

Variable_Firm_Desired_Expansion_Investment_Expenses

END_DESCRIPTION

Variable_Firm_Desired_Market_Share

END_DESCRIPTION

Variable_Firm_Desired_Markup

END_DESCRIPTION

Variable_Firm_Desired_Price

END_DESCRIPTION

Variable_Firm_Effective_Market_Share

END_DESCRIPTION

Variable_Firm_Effective_Markup

END_DESCRIPTION

Variable_Firm_Effective_Orders

END_DESCRIPTION

Variable_Firm_Effective_Orders_Capital_Goods

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Effective_Production

END_DESCRIPTION

Variable_Firm_Effective_Productive_Capacity_Variation

END_DESCRIPTION

Variable_Firm_Expected_Sales

END_DESCRIPTION

Variable_Firm_Expected_Sales_Long_Term

END_DESCRIPTION

Variable_Firm_Avg_Debt_Rate

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Avg_Market_Share

END_DESCRIPTION

Variable_Firm_Avg_Productivity

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Financial_Assets_Return

END_DESCRIPTION

Variable_Firm_Debt_Flow

END_DESCRIPTION

Variable_Firm_Financial_Assets_Flow

END_DESCRIPTION

Variable_Firm_Frontier_Productivity

END_DESCRIPTION

Variable_Firm_Total_Funds

END_DESCRIPTION

Variable_Firm_Imitation_Productivity

END_DESCRIPTION

Variable_Firm_Indirect_Tax

END_DESCRIPTION

Variable_Firm_Innovation_Productivity

END_DESCRIPTION

Variable_Firm_Input_Cost

END_DESCRIPTION

Variable_Firm_Input_Demand_Next_Period

END_DESCRIPTION

Variable_Firm_Interest_Rate

END_DESCRIPTION

Variable_Firm_Stock_Inventories
The current stock of final goods
END_DESCRIPTION

Variable_Firm_Inventories_Variation

END_DESCRIPTION

Variable_Firm_Effective_Expansion_Investment_Expenses

END_DESCRIPTION

Variable_Firm_Market_Share

END_DESCRIPTION

Variable_Firm_Max_Productivity

END_DESCRIPTION

Variable_Firm_Net_Profits

END_DESCRIPTION

Variable_Firm_Net_Revenue

END_DESCRIPTION

Variable_Firm_Planned_Production
Planed Production, calculated based on expected sales subject to the productive capacity restriction, expect for capital goods, wich define their planed production based on current orders.
END_DESCRIPTION

Variable_Firm_Potential_Markup

END_DESCRIPTION

Variable_Firm_Price

END_DESCRIPTION

Variable_Firm_Productive_Capacity
Capacity of production
END_DESCRIPTION

Variable_Firm_Distributed_Profits

END_DESCRIPTION

Variable_Firm_RND_Expenses

END_DESCRIPTION

Variable_Firm_Demand_Productive_Capacity_Replacement

END_DESCRIPTION

Variable_Firm_Required_Inputs

END_DESCRIPTION

Variable_Firm_Retained_Profits

END_DESCRIPTION

Variable_Firm_Revenue

END_DESCRIPTION

Variable_Firm_Sales

END_DESCRIPTION

Variable_Firm_Stock_Debt

_INIT_
All 50 instances equal to 3.2.
END_DESCRIPTION

Variable_Firm_Stock_Financial_Assets

END_DESCRIPTION

Variable_Firm_Stock_Inputs
The stock of intermidiate goods available for next period.
END_DESCRIPTION

Variable_Firm_Variable_Cost

END_DESCRIPTION

Variable_Firm_Replacement_Expenses

END_DESCRIPTION

Variable_Firm_Available_Funds_After_Replacement

END_DESCRIPTION

Variable_Firm_Wage

END_DESCRIPTION

Variable_Firm_Quality

_INIT_
All 3 instances equal to 1.
END_DESCRIPTION

Variable_Firm_Investment_Period

END_DESCRIPTION

Variable_Firm_Modernization_Rate

END_DESCRIPTION

Variable_Firm_Capacity_Utilization

END_DESCRIPTION

Variable_Firm_Demand_Capital_Goods_Expansion
Number of capital goods demanded to expand productive capacity 
Number of capital goods demanded to expand productive capacity
_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Demand_Capital_Goods_Replacement
Number of capital goods demanded to modernie productive capacity 
Number of capital goods demanded to modernie productive capacity
_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Firm_Effective_Capital_Goods_Expansion

END_DESCRIPTION

Variable_Firm_Effective_Capital_Goods_Replacement

END_DESCRIPTION

Variable_Firm_Imitation_Quality
Imitation process. The sucess depends on the amount of recources alocated to imitation. Firms search for best quality of the sector, trying to copy if succeded.
Imitation process. The sucess depends on the amount of recources alocated to imitation. Firms search for best quality of the sector, trying to copy if succeded.
END_DESCRIPTION

Variable_Firm_Innovation_Quality
Innovation process. The sucess depends on the amount ou recources alocated to innovation. Firms search for new quality and the result depends on a random distribution with exonegous parameters.
Innovation process. The sucess depends on the amount ou recources alocated to innovation. Firms search for new quality and the result depends on a random distribution with exonegous parameters.
END_DESCRIPTION

Object_CAPITALS

END_DESCRIPTION

Parameter_capital_good_date_birth

END_DESCRIPTION

Parameter_capital_good_depreciation_period

_INIT_
All 3 instances equal to 1000.
END_DESCRIPTION

Parameter_capital_good_productive_capacity

END_DESCRIPTION

Parameter_capital_good_productivity_initial

END_DESCRIPTION

Parameter_capital_good_to_depreciate

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Parameter_capital_good_to_replace

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Parameter_id_capital_good_number

_INIT_
All 3 instances equal to 1.
END_DESCRIPTION

Variable_Capital_Good_Acumulated_Production

END_DESCRIPTION

Variable_Capital_Good_Production

END_DESCRIPTION

Variable_Capital_Good_Productivity

END_DESCRIPTION

Object_CLASSES

END_DESCRIPTION

Parameter_class_autonomous_consumption_adjustment

_INIT_
All 1 instances equal to 2.
END_DESCRIPTION

Parameter_class_direct_tax

_INIT_
All 2 instances equal to 0.
END_DESCRIPTION

Parameter_class_interest_payment_share

END_DESCRIPTION

Parameter_class_max_debt_ratio

_INIT_
All 2 instances equal to 1.
END_DESCRIPTION

Parameter_class_period

END_DESCRIPTION

Parameter_class_profit_share

END_DESCRIPTION

Parameter_class_propensity_to_consume

END_DESCRIPTION

Parameter_class_propensity_to_import

_INIT_
All 2 instances equal to 0.
END_DESCRIPTION

Parameter_class_wage_share

END_DESCRIPTION

Variable_Class_Autonomous_Consumption

END_DESCRIPTION

Variable_Class_Debt

END_DESCRIPTION

Variable_Class_Debt_Payment

END_DESCRIPTION

Variable_Class_Debt_Ratio

END_DESCRIPTION

Variable_Class_Effective_Domestic_Consumption

END_DESCRIPTION

Variable_Class_Effective_Imports

END_DESCRIPTION

Variable_Class_Expenses

END_DESCRIPTION

Variable_Class_Financial_Asset_Return

END_DESCRIPTION

Variable_Class_Financial_Assets

END_DESCRIPTION

Variable_Class_Government_Interest_Payment

END_DESCRIPTION

Variable_Class_Nominal_Income

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Class_Real_Domestic_Consumption

END_DESCRIPTION

Variable_Class_Real_Imports

END_DESCRIPTION

Variable_Class_Real_Income

_INIT_
All 3 instances equal to 0.
END_DESCRIPTION

Variable_Class_Savings

END_DESCRIPTION

Variable_Class_Taxation

END_DESCRIPTION

Object_GOVERNMENT

END_DESCRIPTION

Parameter_basic_percent_spread

_INIT_
All 1 instances equal to 0.5.
END_DESCRIPTION

Parameter_government_expectations

END_DESCRIPTION

Parameter_government_period

_INIT_
All 1 instances equal to 4.
END_DESCRIPTION

Parameter_government_surplus_rate_target

END_DESCRIPTION

Parameter_inflation_sensitivity

_INIT_
All 1 instances equal to 0.01.
END_DESCRIPTION

Parameter_inflation_target

_INIT_
All 1 instances equal to 0.005.
END_DESCRIPTION

Parameter_interest_rate

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_interest_rate_adjustment

END_DESCRIPTION

Parameter_unemployment_sensitivity

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Parameter_unemployment_target

_INIT_
All 4 instances equal to 0.16.
END_DESCRIPTION

Variable_Basic_Interest_Rate

END_DESCRIPTION

Variable_Government_Debt
Public Debt
END_DESCRIPTION

Variable_Government_Debt_GDP_Ratio

END_DESCRIPTION

Variable_Government_Deficit

END_DESCRIPTION

Variable_Government_Interest_Payment

END_DESCRIPTION

Variable_Government_Max_Expenses

END_DESCRIPTION

Variable_Government_Primary_Surplus

END_DESCRIPTION

Variable_Government_Wages

END_DESCRIPTION

Variable_Total_Income_Taxes

END_DESCRIPTION

Variable_Total_Indirect_Taxes

END_DESCRIPTION

Variable_Total_Taxes

END_DESCRIPTION

Object_EXTERNAL_SECTOR

END_DESCRIPTION

Parameter_International_Reserves

_INIT_
All 1 instances equal to 100000.
END_DESCRIPTION

Parameter_exchange_rate_growth

END_DESCRIPTION

Parameter_external_income_fixed_growth

_INIT_
All 1 instances equal to 0.01.
END_DESCRIPTION

Parameter_external_income_growth_adjustment

_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Variable_Exchange_Rate

END_DESCRIPTION

Variable_External_Income

END_DESCRIPTION

Variable_Trade_Balance

END_DESCRIPTION

Object_ANALYSIS

END_DESCRIPTION

Variable_C

END_DESCRIPTION

Variable_CGDP
Real Consumption share of GDP
Real Consumption share of GDP
END_DESCRIPTION

Variable_CON_G

END_DESCRIPTION

Variable_C_r

END_DESCRIPTION

Variable_Cri

END_DESCRIPTION

Variable_DEBT_C
Average Debt Rate of Consumption good sector
END_DESCRIPTION

Variable_DEBT_I

END_DESCRIPTION

Variable_DEBT_K
Average Debt Rate of Capital good sector
END_DESCRIPTION

Variable_EMP
Employment
_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Variable_EMP_G
Quarterly Employment Growth rate
Quarterly Employment Growth rate
END_DESCRIPTION

Variable_GDP_G

END_DESCRIPTION

Variable_GGDP
Real Government Expenses share of GDP
Real Government Expenses share of GDP
END_DESCRIPTION

Variable_GOV_G

END_DESCRIPTION

Variable_G_n

END_DESCRIPTION

Variable_G_r

END_DESCRIPTION

Variable_HHI_C
Inverse HHI of Consumption good sector
END_DESCRIPTION

Variable_HHI_I
Inverse HHI of Intermediate good sector
END_DESCRIPTION

Variable_HHI_K
Inverse HHI of Capital good sector
END_DESCRIPTION

Variable_I

END_DESCRIPTION

Variable_IGDP
Real Investment share of GDP
Real Investment share of GDP
END_DESCRIPTION

Variable_INVE_G
Real Aggregate Inventories Growth
END_DESCRIPTION

Variable_INVE_r
Real Aggregate Inventories
END_DESCRIPTION

Variable_INVGDP
Real inventories share of GDP
Real inventories share of GDP
END_DESCRIPTION

Variable_INV_G

END_DESCRIPTION

Variable_I_r

END_DESCRIPTION

Variable_KGDP
Real stock of capital share of GDP, or capital-output ratio
Real stock of capital share of GDP, or capital-output ratio
END_DESCRIPTION

Variable_KL
Capital labour ratio
Capital labour ratio
END_DESCRIPTION

Variable_K_G
Real Stock of Capital Growth
END_DESCRIPTION

Variable_K_r
Real Stock of Capital
END_DESCRIPTION

Variable_MK
Average Markup
_INIT_
All 1 instances equal to 0.
END_DESCRIPTION

Variable_MK_C
Average Markup of Consumption good sector
END_DESCRIPTION

Variable_MK_G

END_DESCRIPTION

Variable_MK_I
Average Markup of Intermediate good sector
END_DESCRIPTION

Variable_MK_K
Average Markup of Capital good sector
END_DESCRIPTION

Variable_M_G
Quarterly Real Imports Growth rate
END_DESCRIPTION

Variable_M_r

END_DESCRIPTION

Variable_NXGDP
Real net exports share of GDP
Real net exports share of GDP
END_DESCRIPTION

Variable_NX_G
Quarterly Real Net Exports Growth rate
END_DESCRIPTION

Variable_NX_r
Quarterly Real Net Exports
END_DESCRIPTION

Variable_P

END_DESCRIPTION

Variable_PCU
Productive Capacity Utilization Rate
Productive Capacity Utilization Rate
END_DESCRIPTION

Variable_PDEBT

END_DESCRIPTION

Variable_PDEBT_G

END_DESCRIPTION

Variable_PR
Profit Rate
Profit Rate
END_DESCRIPTION

Variable_PROD

END_DESCRIPTION

Variable_PROD_C
Average Productivity of Consumption good sector
END_DESCRIPTION

Variable_PROD_G

END_DESCRIPTION

Variable_PROD_I
Average Productivity of Intermediate good sector
END_DESCRIPTION

Variable_PROD_K
Average Productivity of Capital good sector
END_DESCRIPTION

Variable_PROFITS

END_DESCRIPTION

Variable_PROFITS_G

END_DESCRIPTION

Variable_P_C
Average Price of Consumption good sector
END_DESCRIPTION

Variable_P_G

END_DESCRIPTION

Variable_P_I
Average Price of Intermediate good sector
END_DESCRIPTION

Variable_P_K
Average Price of Capital good sector
END_DESCRIPTION

Variable_U

END_DESCRIPTION

Variable_U_C
Unemployment Rate of Consumption good sector
END_DESCRIPTION

Variable_U_I
Unemployment Rate of Intermediate good sector
END_DESCRIPTION

Variable_U_K
Unemployment Rate of Capital good sector
END_DESCRIPTION

Variable_WAGE

END_DESCRIPTION

Variable_WAGE_G

END_DESCRIPTION

Variable_W_C
Average Wage of Consumption good sector
END_DESCRIPTION

Variable_W_I
Average Price of Intermediate good sector
END_DESCRIPTION

Variable_W_K
Average Price of Capital good sector
END_DESCRIPTION

Variable_X_G
Quarterly Real Exports Growth rate
END_DESCRIPTION

Variable_X_r
Quarterly Real Exports
END_DESCRIPTION


DOCUOBSERVE
Root
CGDP

END_DOCUOBSERVE


DOCUINITIAL
Root

END_DOCUINITIAL


EQ_FILE
#include "fun_head.h"

MODELBEGIN



/************************************  PRODUÇÃO PROGRAMADA  ***************************************/

if(!strcmp(label, "EXP_SALES") )
{
/*	
Firm variable
As vendas previstas são calculadas a partir da média das encomendas efetivas dos dois últimos períodos, sobre a qual é aplicada uma taxa de crescimento esperada. Esta taxa de crescimento é obtida com base na média das encomendas efetivas dos dois últimos períodos e dos dois períodos anteriores a estes, aplicando-se um fator de extrapolação.
*/
  
   v[0]=p->cal("EFOR", 1);
   v[1]=p->cal("EFOR", 2);
   v[2]=p->cal("EFOR", 3);
   v[3]=p->cal("EFOR", 4);
  	v[5]=p->cal("GAMA",0); //GAMA(<=1)PROJEÇÃO: REFLETE O ESTADO DAS EXPECTATIVAS E CONDIÇÕES DE CONCORRÊNCIA
   v[8]=(v[2]+v[3])/2;
   v[9]=(v[0]+v[1])/2;
    	if(v[8]!=0)
   		{
   		v[6]=v[9]*(1+v[5]*((v[9]-v[8])/v[8]));// extrapolação da taxa de crescimento
   		v[7]=max(0,v[6]);
   		}
   		else
   		{
   		v[7]=v[9];
   		} 
		res=v[7];
		goto end;
}

if(!strcmp(label,"PP"))
{
/*
Firm variable
A produção programada é calculada a partir das vendas previstas para o período, considerando a proporção das vendas que se deseja manter como estoque e descontando o estoque acumulado do período anterior.  Este valor estará sujeito à  restrição imposta pela capacidade produtiva existente, tendo em vista a possibilidade de expandir a produção, através, por exemplo, do uso de hora-extra de trabalho.

A produção programada do setor de bens de capital é definida em função da demanda observada no período â€“ este setor produz sob encomenda.  Também neste caso, a produção estará sujeita à  restrição imposta pela capacidade produtiva existente, considerando-se a possibilidade do uso hora-extra.  
*/
v[0]=p->cal("Ibk",0);
v[1]=p->cal("EXP_SALES", 0); 
v[2]=p->cal("CP",1);
v[3]=p->cal("BETA",0); //BETA >=1,margem de sobre-utilização da capacidade produtiva
v[4]=v[3]*v[2];
	if(v[0]==0)// se o setor não é produtor de BK
		{
			v[5]=p->cal("SIGMA",0);//proporção de estoque desejada
			v[8]=p->cal("STOCK",1);//
			v[6]=v[1]*(1+v[5])-v[8];
			v[7]=max(0, min( v[4], v[6] ));
			
		}
	if(v[0]==1)// se o setor é produtor de BK
		{
		v[6]=p->cal("EFOR_BK_firm",0);
		v[7]=max(0,min(v[4],v[6]));
		}
v[9]=max(v[7],0);
res=v[9];
goto end;
}


/**************************************  DEMANDA POR BENS INTERMEDIÁRIOS  ************************************/


if(!strcmp(label,"UA"))
{
/*
A utilização de insumos necessária para atender à  produção programada é calculada através do produto da produção programada pelo coeficiente técnico.
*/
	v[0]=p->cal("PP",0);
	v[1]=p->cal("A",0) ;
	v[2]=p->cal("A_M",0) ;
	res=v[0]*(v[1]+v[2]);

goto end;
}



if(!strcmp(label,"A_at"))
{
/*
Esta variável define a razão entre os insumos disponíveis e o total de insumos necessários de cada setor de bens intermediários para se realizar a produção programada.  
*/
	v[2]=p->cal("UA",0);
	v[3]=p->cal("DA_stock_expost",1);

		if(v[2]>0)
		v[0]=v[3]/v[2];
		
		if(v[2]==0)
		v[0]=1;
		
res=min(1,v[0]);
goto end;
}


if(!strcmp(label,"minA_at"))
{
/*
firm variable
A variável minA_at define para cada setor a menor razão entre os insumos disponíveis e os insumos necessários para realizar a produção programada.
*/
for(v[1]=1,cur=p->search("Inputs"); cur!=NULL; cur=go_brother(cur) )
{
  v[2]=cur->cal("A_at",0);
  v[3]=min(v[2],1);
  v[1]=min(v[1],v[3]);
}

res=v[1];

goto end;
}


if(!strcmp(label,"DA_stock_exante"))
{
/*
O estoque de insumos de cada setor, antes da demanda por insumos para serem utilizados no período seguinte, é determinado subtraindo-se do total de insumos disponíveis a quantidade de insumos que será efetivamente usada na produção.  Este último fator é calculado através do produto dos insumos necessários a produção programada pelo valor da menor razão entre os insumos disponíveis e os insumos necessários.
*/
v[0]=p->cal("DA_stock_expost",1);
v[2]=p->cal("minA_at",0);
v[3]=p->cal("UA",0);
v[4]=v[0]-(v[3]*v[2]);
res=max(v[4],0);
goto end;
}



if(!strcmp(label, "DA") )
{
/*
A demanda por insumos de cada setor de bens intermediários, que deverão ser produzidos durante o período corrente para serem usados no período seguinte, é calculada com base na quantidade de insumos necessária para realizar a produção programada, sobre a qual é aplicada uma taxa de crescimento esperada e descontado o estoque restante.  A taxa de crescimento é definida pela média das encomendas efetivas dos dois últimos períodos e dos dois períodos anteriores a estes, utilizando-se um fator de extrapolação. 

Os setores de bens intermediários demandam exatamente a quantidade que irão precisar para produzir no período seguinte, sem descontar o estoque inicial, que é desconhecido, uma vez que não sua produção no período será função da encomenda de insumos feita por todos os setores e não de sua produção programada.   
*/

  
v[0]=p->cal("PP",0);	
v[1]=p->cal("A",0) ;
v[2]=p->cal("Ibi",0);
v[22]=p->cal("Ibk",0);
v[3]=p->cal("DA_stock_exante",0);

v[10]=p->cal("EFOR", 1);
v[11]=p->cal("EFOR", 2);
v[12]=p->cal("EFOR", 3);
v[13]=p->cal("EFOR", 4);
v[15]=p->cal("GAMA",0); //GAMA(<=1)PROJEÇÃO REFLETE O ESTADO DAS EXPECTATIVAS E CONDIÇÕES DE CONCORRêNCIA
v[8]=(v[12]+v[13]);
v[9]=(v[10]+v[11]);

   if(v[8]!=0)
   v[16]=1+(v[15]*((v[9]-v[8])/v[8]));// extrapolação da taxa de crescimento
   else
   v[16]=1;
   	
          if(v[2]==0)//Se não for bem intermediário
          {
               if(v[22]==1)
               {
               v[23]=p->cal("SIGMA",0);
           				v[4]=(v[0]*(1+v[23])*v[1])*(v[16])-v[3];
               }
               else
               v[4]=(v[0]*v[1])*(v[16])-v[3];
  				}
          if(v[2]==1)//Se for bem intermediário
          v[4]=(v[0]*v[1])*(v[16]);
  
  res=max(v[4],0);
  goto end;
}


if(!strcmp(label,"Dem_intermediate"))
{
/*
A encomenda efetiva de insumos recebida por cada setor de bens intermediários é definida pela soma da demanda por seus insumos de todos os setores da economia mais as exportações.  
*/
last_update--;//repeat the computation any time is requested
if(c==NULL)//Avoids to be computed when the system activates the equation
{
res=-1;
goto end;
}
else
{
v[0]=c->cal("Id1",0);
v[8]=c->cal("Ibi",0);
if(v[8]==1)
{
	for(v[2]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
  {
     		for(v[3]=0,cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
     {
      cur2=cur1->search_var_cond("Id3",v[0], 0);
      v[4]=cur2->cal("DA",0);
      v[3]=v[3]+v[4];
     }
  v[2]=v[2]+v[3];
  }
  //c->write("DA_TOTP",v[2], 0); /* O parâmetro DA_TOTP soma a demanda de todos os setores pelos insumos de cada setor intermediário */
res=v[2];
}
else
res=0;
goto end;
}
}


if(!strcmp(label,"DA_TOT"))
{
/*
Not Included yet
*/
		
	v[1]=p->cal("DA_TOTP",0);
   res=v[1];
goto end;
}

if(!strcmp(label,"DomIntDem"))
{
/*
Sector Variable - Total Domestic Intermidiate goods demand. 
*/
v[0]=p->cal("Dem_intermediate",0);
res=v[0];
goto end;
}

if(!strcmp(label,"EFOR_intermediate"))
{
/*
Sector Variable - Total Intermidiate goods demand includes exports. 
*/
v[0]=p->cal("Ibi",0);
v[1]=p->cal("DomIntDem",0);
v[2]=p->cal("EXPORTS",0);
if(v[0]==1)
res=v[2]+v[1];
else
res=0;
goto end;
}


/********************************************  CONSUMO  ************************************************/


if(!strcmp(label, "DomConsDem") )
{
/*
Sector Variable
A demanda total de cada setor de bens de consumo é determinada pela soma do consumo das diferentes classes de renda com o gasto em consumo do governo e com o consumo autônomo. O consumo das diferentes classes de renda da economia é calculado multiplicando-se pela respectiva propensão a consumir a renda média da classe, determinada em função da defasagem considerada.  Quanto à s defasagens, para a classe A a defasagem é de 4 períodos, para classe B é de 3, para classe C é de 2 e para classe D é de 1.  O gasto em consumo do governo é obtido multiplicando-se o total de seus gastos por sua propensão a consumir.  
Cosumoi(t)= Consumo_de_cada_classe(t)+ Consumo_gov (t)

*/
		v[20]=p->cal("Ibc",0);
		if(v[20]==1)//Se for setor de consumo 
		{
    v[0]=p->cal("CLASS_A", 1);
    v[1]=p->cal("CLASS_A", 2);
    v[2]=p->cal("CLASS_A", 3);
    v[3]=p->cal("CLASS_A", 4);
    
    v[4]=p->cal("CLASS_B", 1);
    v[5]=p->cal("CLASS_B", 2);
    v[6]=p->cal("CLASS_B", 3);
    
    v[7]=p->cal("CLASS_C", 1);
    v[8]=p->cal("CLASS_C", 2);
    
    v[9]=p->cal("CLASS_D", 1);
    
    v[10]=(v[0]+v[1]+v[2]+v[3])/4;
    v[11]=(v[4]+v[5]+v[6])/3;
    v[12]=(v[7]+v[8])/2;
      
    v[14]=p->cal("P_A", 0);
    v[15]=p->cal("P_B", 0);
    v[16]=p->cal("P_C", 0);
    v[17]=p->cal("P_D", 0);
    v[19]=p->cal("Consumo_gov", 0);
    v[21]=p->cal("Avg_PRICE",1);
    v[22]=p->cal("Consumo_autonomo", 0);
    v[23]=v[19]/v[21];
  
     res=(v[10]*v[14]+v[11]*v[15]+v[12]*v[16]+v[9]*v[17]+v[23]+v[22]);
		}
		else 
		res=0; 
		
  goto end;

}



if(!strcmp(label,"EFOR_consumo"))
{
/*
Sector Variable
A encomenda efetiva para os setores produtores de bens de consumo é determinada pela demanda interna mais as exportações. 
*/

	v[0]=p->cal("Ibc",0);
	if(v[0]==1)
	{
		v[1]=p->cal("DomConsDem",0);
		v[2]=p->cal("EXPORTS",0);
		res=v[1]+v[2];
	}
	if(v[0]==0)
	res=0;
	goto end;
}

if(!strcmp(label,"Consumo_autonomo"))
{
/*
This means that it is actually a parameter
*/

v[0]=p->cal("C_aut_A",0);
v[1]=p->cal("C_aut_B",0);
v[2]=p->cal("C_aut_C",0);
v[3]=p->cal("C_aut_D",0);

res=v[0]+v[1]+v[2]+v[3];
goto end;
}

EQUATION("Tax_var_C_aut")
/*
Comment
*/
v[0]=p->cal("Switch_C_aut",0);
v[1]=p->cal("Tax_var_C_aut",1);
     if(v[0]==0)
     v[8]=0;
     else
     {
     v[2]=fmod((double) t,10);
        if(v[2]==0)
        {
        v[3]=p->cal("AVG_QUALITY_SET",10);
        v[4]=p->cal("AVG_QUALITY_SET",1);
        v[5]=(v[4]-v[3])/v[3];
        v[6]=p->cal("Tax_var_C_aut_min",0);
        v[7]=p->cal("Tax_var_C_aut_max",0);
        
            if(v[5]<=0)
            {
            v[8]=0;
            }
            else
            {
            v[9]=v[5]/0.0001;
            modf(v[9],&v[10]);
            v[11]=v[10]*0.0001;
            v[8]=min(v[7],v[11]);
            }
               
        }
        else
        v[8]=v[1];
     }

RESULT(v[8])


EQUATION("C_aut_A")
/*
Comment
*/
v[0]=VL("C_aut_A",1);
v[1]=VL("prop_cons_aut_A",1);

v[2]=fmod((double) t,10);
        if(v[2]==0)
        {
         v[3]=V("Tax_var_C_aut");
         v[5]=VL("aplic_fin_A",1);
         v[6]=VL("aplic_fin_A",10);
         v[7]=V("Prop_var_C_aut_A");
           if(v[6]>0)
           v[8]=v[7]*(v[5]-v[6])/v[6];
           else
           v[8]=0;
         v[9]=max(0,v[3]+v[8]);
         v[4]=(1+v[9])*v[0];
        }
        else
        v[4]=v[0];
        
RESULT(v[4]*v[1])

EQUATION("C_aut_B")
/*
Comment
*/
v[0]=VL("C_aut_B",1);
v[1]=VL("prop_cons_aut_B",1);
v[2]=fmod((double) t,10);
        if(v[2]==1)
        {
        v[3]=V("Tax_var_C_aut");
        v[5]=VL("aplic_fin_B",1);
        v[6]=VL("aplic_fin_B",10);
        v[7]=V("Prop_var_C_aut_B");
           if(v[6]>0)
           v[8]=v[7]*(v[5]-v[6])/v[6];
           else
           v[8]=0;
        v[9]=max(0,v[3]+v[8]);
        v[4]=(1+v[9])*v[0];
        }
        else
        v[4]=v[0];
        
RESULT(v[4]*v[1])

EQUATION("C_aut_C")
/*
Comment
*/
v[0]=VL("C_aut_C",1);
v[1]=VL("prop_cons_aut_C",1);
v[2]=fmod((double) t,10);
        if(v[2]==2)
        {
        v[3]=V("Tax_var_C_aut");
        v[5]=VL("aplic_fin_C",1);
        v[6]=VL("aplic_fin_C",10);
        v[7]=V("Prop_var_C_aut_C");
           if(v[6]>0)
           v[8]=v[7]*(v[5]-v[6])/v[6];
           else
           v[8]=0;
        v[9]=max(0,v[3]+v[8]);
        v[4]=(1+v[9])*v[0];
        }
        else
        v[4]=v[0];
        
RESULT(v[4]*v[1])

EQUATION("C_aut_D")
/*
Comment
*/
v[0]=VL("C_aut_D",1);
v[2]=fmod((double) t,10);
        if(v[2]==3)
        {
        	v[3]=V("Tax_var_C_aut");
         v[5]=VL("aplic_fin_D",1);
         v[6]=VL("aplic_fin_D",10);
         v[7]=V("Prop_var_C_aut_D");
           if(v[6]>0)
           v[8]=v[7]*(v[5]-v[6])/v[6];
           else
           v[8]=0;
         v[9]=max(0,v[3]+v[8]);
         v[4]=(1+v[9])*v[0];
        }
        else
        v[4]=v[0];
        
RESULT(v[4]*v[1])


/*****************************************  INVESTIMENTO  **************************************/


if(!strcmp(label, "ES2") )
{
/*
Firm variable
Os setores atualizam sua capacidade produtiva de ano em ano, tempo que demora para nova capacidade ser produzida e estar disponível para uso.  A variação na capacidade produtiva desejada é então definida em função das encomendas esperadas para o ano seguinte.  As encomendas esperadas são calculadas a partir da média das encomendas efetivas dos últimos quatro períodos e da projeção de crescimento para daqui a quatro períodos.  Esta projeção é determinada com base na diferença entre as médias de encomendas dos quatro últimos períodos e dos quatro períodos anteriores a estes, sobre a qual se aplica um fator de extrapolação anual duplicado.
*/

		v[0]=p->cal("EFOR",0);
  		v[1]=p->cal("EFOR",1);
  		v[2]=p->cal("EFOR",2);
  		v[3]=p->cal("EFOR",3);
  		v[4]=p->cal("EFOR",4);
  		v[5]=p->cal("EFOR",5);
  		v[6]=p->cal("EFOR",6);
  		v[7]=p->cal("EFOR",7);
		v[8]=p->cal("EFOR",8);
  		v[9]=p->cal("EFOR",9);
  		v[10]=p->cal("EFOR",10);
  		v[11]=p->cal("EFOR",11);
   
   		v[12]=(v[0]+v[1]+v[2]+v[3]+v[4]+v[5])/6;
   		v[13]=(v[6]+v[7]+v[8]+v[9]+v[10]+v[11])/6;
   		
v[14]=p->cal("GAMA",0);
v[15]=v[12]*(1+2*v[14]*((v[12]-v[13])/v[13]));
v[16]=max(0,v[15]);
res=v[16];

goto end;
}


if(!strcmp(label, "DELTACP_DES") )
{
/*
Firm Variable
A variação de capacidade produtiva desejada é calculada a partir das vendas esperadas menos a capacidade produtiva existente, considerando-se a margem sobre as vendas que se deseja manter em estoque e o grau de utilização da capacidade produtiva desejado (ou o quanto se deseja deixar de capacidade ociosa = 1/ALFA).  Para garantir que a variação de capacidade desejada gerara uma demanda por um número inteiro de bens de capital, divide-se a variação desejada pelo coeficiente de indivisibilidade e toma-se o inteiro, que é então multiplicado pelo coeficiente.

As defasagens consideradas distribuem uniformemente a demanda por bens de investimento dos diferentes setores ao longo do tempo.
*/
v[6]=p->cal("Id2",0);
v[10]=p->cal("Per_Inv",0);
v[7]= fmod((double) t,v[10]); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
   if(v[6]==v[7]||v[6]==(v[7]+v[10])||v[6]==(v[7]+2*v[10])||v[6]==(v[7]+3*v[10]))
   {
   v[0]=p->cal("ES2",0);
   v[1]=p->cal("CP",0); //CP CAPACIDADE PRODUTIVA, leva em consideraçào o quanto a capacidade foi acrescida no período.
   v[2]=p->cal("SIGMA",0);
   v[3]=p->cal("ALFA",0);
   v[9]=p->cal("CP_DEPRECIACAO",0);
   v[4]=(1/v[3])*v[0]-(v[1]-v[9]);
   v[8]=max(0,v[4]);
   cur=p->search_var_cond("Id3",2,0);//Repensar se houver mais de um setor de BK
   v[5]=cur->cal("B",0);
   v[11]=v[8]*v[5];
   modf(v[11],&v[12]);
   v[13]=v[12]/v[5];
   }
   else
   v[13]=0;

res=v[13];
goto end;
}




if(!strcmp(label, "CP_DEPRECIACAO") )
{
v[6]=p->cal("Id2",0);
v[10]=p->cal("Per_Inv",0);
v[7]= fmod((double) t,v[10]); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
   if(v[6]==v[7]||v[6]==(v[7]+v[10])||v[6]==(v[7]+2*v[10])||v[6]==(v[7]+3*v[10]))
   {
   v[0]=p->cal("DEPRE",0);
   /*rotina(loop) para determinar os B_K's que estarão depreciados daqui a 6 períodos:*/
      for(v[1]=0,cur=p->search("B_K");cur!=NULL;cur=go_brother(cur))
      {
      v[2]=cur->cal("DataNasc",0);
      v[3]=cur->cal("CP_BK",0);
         if((double)t==v[2]+v[0]-6)
         v[1]=v[1]+v[3];
         else
         v[1]=v[1];
      }
   res=v[1];
   }
   else
   res=0;

goto end;
}

if(!strcmp(label,"DES_INV_EXPENSES"))
{
/*
firm variable
Demanda por bem de capital do setor, soma variação de capacidade com investimento autonomo.
*/
v[6]=p->cal("Id2",0);
v[10]=p->cal("Per_Inv",0);
v[7]= fmod((double) t,v[10]); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
  if(v[6]==v[7]||v[6]==(v[7]+v[10])||v[6]==(v[7]+2*v[10])||v[6]==(v[7]+3*v[10]))
  {
  v[2]=p->cal("DELTACP_DES",0);
  v[3]=p->cal("Investimento_aut_des",0);
  v[4]=p->cal("PRICE_BK",0);
  cur=p->search_var_cond("Id3",2,0);//Repensar se houver mais de um setor de BK
  v[5]=cur->cal("B",0);
  res=(v[2]+v[3])*v[5]*v[4];
  }
  else
  res=0;
goto end;
}

if(!strcmp(label,"Investimento_aut_des"))
{
/*
firm variable
Demanda por bem de capital do setor, soma variação de capacidade com investimento autonomo.
*/
v[3]=V("Switch_Invest_aut");
if(v[3]==1)
{
   if((double) t<15)
   v[0]=p->cal("Investimento_aut_desP",0);
   if((double) t>=15 &&(double) t<35)
   {
   v[1]=p->cal("Investimento_aut_desP",0);
   v[2]=(double) t;
   v[0]=(1-((v[2]-15)/40))*v[1];
   }
   if((double) t>=35)
   {
   v[1]=p->cal("Investimento_aut_desP",0);
   v[0]=v[1]*0.5;
   }
}

if(v[3]==2)
{
   if((double) t<15)
   v[0]=p->cal("Investimento_aut_desP",0);
   if((double) t>=15 &&(double) t<35)
   {
   v[1]=p->cal("Investimento_aut_desP",0);
   v[2]=(double) t;
   v[0]=(1-((v[2]-15)/20))*v[1];
   }
   if((double) t>=35)
   {
   v[1]=p->cal("Investimento_aut_desP",0);
   v[0]=v[1]*0.0;
   }
}
   
if(v[3]==2)
v[0]=p->cal("Investimento_aut_desP",0);


res=v[0];
goto end;
}

if(!strcmp(label, "DELTACP") )
{
v[1]=p->cal("DELTACP_DES",0);
v[2]=p->cal("INV_EXPENSES",0);
v[3]=p->cal("PRICE_BK",0);
cur=p->search_var_cond("Id3",2,0);
v[5]=cur->cal("B",0);
v[6]=(v[2])/(v[3]);/*valor transformDELTACPado em unidades de capacidade*/
v[8]=v[6]*v[5];/*efeito indivisibilidade. */
modf(v[8],&v[7]);/*v[7] determina quanto inteiros(unidade de capaciade mímima) tenho*/

     if(v[7]>0)
     {
     v[9]=p->cal("PROD",0);
     v[10]=p->cal("A_BK_MAX",0);
        if(v[9]>=v[10])
        p->write("IdA3",1,0);    
        else
        p->write("IdA3",2,0);
        }
     else
     p->write("IdA3",0,0);

res=min(v[7],v[1]);
goto end;
}


if(!strcmp(label, "CP_DEM") )
{
v[2]=p->cal("INV_EXPENSES",0);
v[3]=p->cal("PRICE_BK",0);
cur=p->search_var_cond("Id3",2,0);
v[5]=cur->cal("B",0);
v[6]=(v[2])/(v[3]); /*valor transformado em unidades de capacidade de capital*/
v[8]=v[6]/v[5]; /*efeito indivisibilidade, transforma em unidades de CAPACIDADE PRODUTIVA */
modf(v[8],&v[7]); /*v[7] determina quanto inteiros(unidade de capaciade mímima) tenho*/
p->write("rest",v[2]-v[7]*v[5]*v[3],0);
res=v[8];
goto end;
}

if(!strcmp(label, "DI") )
{
/*
A demanda por bens de capital a cada período será determinada pela soma do investimento autônomo com 1/4 da variação de capacidade produtiva desejada por cada setor multiplicada pelo coeficiente de capital (para transformá-la em unidades de bens de capital demandadas).  
*/

	v[5]=p->cal("Id2", 0);
	v[8]=p->cal("Per_Inv",0);

	v[3]=p->cal("B",0);
	v[0]= fmod((double) t,6); // armazena em v[0] o resto da divisao de t(período corrente) por 6.

	if(v[5]==(v[0]-1)||v[5]==(v[0]+5)||v[5]==(v[0]+11)||v[5]==(v[0]+17))
	{
	v[6]=p->cal("REPO",1);
	v[7]=p->cal("CP_Dem_quality",1); 
	v[1]=p->cal("CP_DEM", 1);
	v[2]=(v[1]+v[6]+v[7])/6;
	}
   if(v[5]==(v[0]-2)||v[5]==(v[0]+4)||v[5]==(v[0]+10)||v[5]==(v[0]+16))
	{
	v[6]=p->cal("REPO",2);
	v[7]=p->cal("CP_Dem_quality",2); 
	v[1]=p->cal("CP_DEM", 2);
	v[2]=(v[1]+v[6]+v[7])/6;
	}
  if(v[5]==(v[0]-3)||v[5]==(v[0]+3)||v[5]==(v[0]+9)||v[5]==(v[0]+15))
	{
	v[6]=p->cal("REPO",3);
	v[7]=p->cal("CP_Dem_quality",3); 
	v[1]=p->cal("CP_DEM", 3);
	v[2]=(v[1]+v[6]+v[7])/6;
	}
  if(v[5]==(v[0]-4)||v[5]==(v[0]+2)||v[5]==(v[0]+8)||v[5]==(v[0]+14))	
	{
	v[6]=p->cal("REPO",4);
	v[7]=p->cal("CP_Dem_quality",4); 
	v[1]=p->cal("CP_DEM", 4);
	v[2]=(v[1]+v[6]+v[7])/6;
	}
	if(v[5]==(v[0]-5)||v[5]==(v[0]+1)||v[5]==(v[0]+7)||v[5]==(v[0]+13))
	{
	v[6]=p->cal("REPO",5);
	v[7]=p->cal("CP_Dem_quality",5); 
	v[1]=p->cal("CP_DEM", 5);
	v[2]=(v[1]+v[6]+v[7])/6;
	}
  if(v[5]==(v[0])||v[5]==(v[0]+6)||v[5]==(v[0]+12)||v[5]==(v[0]+18))
	{
	v[6]=p->cal("REPO",6);
	v[7]=p->cal("CP_Dem_quality",6); 
	v[1]=p->cal("CP_DEM", 6);
	v[2]=(v[1]+v[6]+v[7])/6;
	}
	res=v[2]*v[3];
   goto end;

}

if(!strcmp(label,"Dem_BK"))
{
/*
A demanda por bens de capital é calculada somando-se a demanda por bens de capital de todos os setores com os gastos do governo em investimento.  
*/
last_update--;//Repeat the computation any time is requested
if(c==NULL)//Avoids to be computed when the system activates the equation
{
res=-1;
goto end;
}
else
{
v[0]=c->cal("Id1",0);

for(v[2]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
  {
   for(v[3]=0,cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
    {
     cur2=cur1->search_var_cond("Id3",v[0], 0);
     v[4]=cur2->cal("DI",0);
     v[3]=v[3]+v[4];
    }
    v[2]=v[2]+v[3];
  }
res=v[2];
goto end;
}
}

if(!strcmp(label,"Inv_gov"))
{
/*
O investimento do governo em termos de valor é determinado pelos gastos do governo multiplicados por seu coeficiente de investimento.
*/
v[0]=p->cal("Gov_expenses",0);
v[1]=p->cal("Wage_Gov",0);
v[2]=p->cal("coef_inv_gov",0);

v[6]=p->cal("Switch_Superavit_target", 0);
   
   if(v[6]==0)
   v[4]=((v[0]-v[1])*v[2]);
   
   else
   {
   v[7]=p->cal("Switch_Priority_gov",0);
        
        if(v[7]==0)//não há prioridade nos gastos restantes do governo
        v[4]=((v[0]-v[1])*v[2]);
        
        if(v[7]==1)//prioridade do investimento
        {
        v[8]=p->cal("Gov_wage_rate",0);
        v[9]=v[2]*(1-v[8]);
        v[10]=min((v[0]*v[9]),(v[0]-v[1]));
        v[4]=v[10];
        }
        
        if(v[7]==2)//prioridade do consumo
        {
        v[8]=p->cal("Consumo_gov",0);
        v[4]=(v[0]-v[8]);
        }
        
   }


modf(v[4],&v[5]);//em v[4] fica armazenada a parte inteira da divisão
res=v[5]; 

goto end;
}

EQUATION("Consumo_gov")
/*
Valor do Consumo do Governo
*/
 
v[0]=p->cal("Wage_Gov",0);
v[1]=p->cal("P_gov", 0);
v[3]=p->cal("Gov_expenses", 0);
v[5]=p->cal("Switch_Superavit_target", 0);
   
   if(v[5]==0)
   v[4]=((v[3]-v[0])*v[1]);
   
   else
   {
   v[6]=p->cal("Switch_Priority_gov",0);
        
        if(v[6]==0)//não há prioridade nos gastos restantes do governo
        v[4]=((v[3]-v[0])*v[1]);
        
        if(v[6]==1)//prioridade do investimento
        {
        v[7]=p->cal("Inv_gov",0);
        v[4]=(v[3]-v[7]);
        }
        
        if(v[6]==2)//prioridade do consumo
        {
        v[7]=p->cal("Gov_wage_rate",0);
        v[8]=v[1]*(1-v[7]);
        v[4]=min((v[0]*v[8]),(v[3]-v[0]));
        }
        
   }

 
RESULT(v[4])


if(!strcmp(label,"DomBKDem"))
{
/*
Sector Variable
Variável localizada nos setores, chama a função Dem_BK e calcula a demanda dos demais setores por bens de capital produzidos pelo setor que está chamando. Esse valor só será positivo se o setor for produtor de bens de capital.
*/
v[0]=p->cal("Ibk",0);

if(v[0]==1)
{
v[1]=p->cal("Dem_BK",0);
v[2]=p->cal("M_BK",0);
v[3]=p->cal("Inv_gov",0);
v[5]=p->cal("Avg_PRICE",1);
v[4]=v[1]*(1-v[2])+v[3]/v[5];
}
else
v[4]=0;

res=v[4];
goto end;
}


if(!strcmp(label,"EFOR_BK"))
{
/*
Sector Variable
As encomendas efetivas para o setor de bens de capital são determinadas a partir da demanda interna mais exportações e menos importações.  
*/
v[0]=p->cal("Ibk",0);
	if(v[0]==1)
	{
	v[1]=p->cal("DomBKDem",0);
	v[2]=p->cal("EXPORTS",0);
	res=v[1]+v[2];
	}
	if(v[0]==0)
	res=0;
	goto end;
}

if(!strcmp(label,"EFOR_BK_firm"))
{
/*
It is settled in a way that there will be no excess demand while there is still productive capacity in the sector. This distribution is done in the variable: BK_EFOR_firm.
*/

p->cal("BK_EFOR_firm",0);
v[0]=p->cal("BK_EFOR_fP",0);
res=v[0];
p->write("BK_Production_fP",0, 0);
p->write("BK_EFOR_fP",0, 0);
/*
v[0]=p->cal("EFOR_BK",0);
v[1]=p->cal("MS",0);
*/
res=v[0];
goto end;
}


if(!strcmp(label, "CP") )
{
/*
In this variable, new capital goods are created and old ones are deleted.
*/ 
v[0]=p->cal("DELTACP_EF",0);
v[1]=p->cal("PROD",6);//Available technology when the capital good was ordered. 
v[2]=p->cal("A_BK_MAX",6);//Best technology in use when the capital good was ordered, incluiding skill   
v[3]=p->cal("Sum_IdA3",6);
v[4]=p->cal("Sum_IdA3",7);
v[5]=p->cal("DEPRE",0);
cur2=p->search_var_cond("Id3",2,0);
v[6]=cur2->cal("B",0);
v[7]=round(v[0]*v[6]);//The amount of Capital Goods bought
v[8]= fmod((double) t,6);
v[9]=p->cal("Id2",0);
v[20]=p->cal("A_BK_MAX",0);

if(v[9]==v[8]||v[9]==(v[8]+6)||v[9]==(v[8]+12)||v[9]==(v[8]+18))
{
/*
 REPOSICAO POR OBSOLESCENCIA
*/   
  
  for(v[10]=0,cur=p->search("B_K");cur!=NULL;cur=go_brother(cur))
  {    
  v[11]=cur->cal("IdA2",0);
  v[12]=cur->cal("CP_BK",0);  
     if(v[11]>0)//IdA2>0 implies that the capital good is being scrapped by obsolescence and therefore it will be replaced by a more modern one. 
     {
     cur->write("a_bk",v[1],0);
     //cur->write("A_BK",v[1],1);
     cur->write("IdA2",0,0);
     //cur->write("CQ",0,1);
     // cur->write("Q",0,0);
     cur->write("DataNasc",(double)t,0);
     cur->write("to_die_BK",0,0);
     v[10]=v[10]+v[12];
     }
     else
     v[10]=v[10];
  }
      
/*
 EXPANSÃO DA CAPACIDADE PRODUTIVA.
*/    
  if(v[0]>0)
  {
  /*se o b_k possui tecnologia de fronteira*/
     if(v[3]==v[4]+1)
     {
        for(v[13]=0; v[13]<v[7]; v[13]=v[13]+1)
        {
        //cur=p->add_an_object("B_K");
        cur=ADDOBJ("B_K");
        cur->write("a_bk",v[1],0);
        cur->write("CP_BK",v[6],0);
        cur->write("DataNasc",(double)t,0);
        cur->write("to_die_BK",0,0);
        }
     }
  /*se o b_k possui a tecnologia de um equipamento já em uso.*/
  
     if(v[3]==v[4]+2)
     {
     //p->lsdqsort("B_K","A_BK", "DOWN");//This is a away to avoid the problem of deleting the best B_K  
     //cur=p->search("B_K");
     cur=p->search_var_cond("A_BK",v[20],0);
        for(v[13]=0; v[13]<v[7]; v[13]=v[13]+1)
        {
        cur=ADDOBJ_EX("B_K",cur);
        //cur=p->add_an_object("B_K",cur);
        cur->write("DataNasc",(double)t,0);
        cur->write("to_die_BK",0,0);
        //cur->write("a_bk",v[20],0);
        }
     }      
  }
p->write("CP_REP_P",v[10],0);/*quantidade de capacidade produtiva sucateada*/
}
/*eliminação de um b_k por depreciação*/

res=p->sum("CP_BK",0);
goto end;
}

if(!strcmp(label,"CP_apendix"))
{
/*
Sector Variable
Its is just to make it possible to delet the firm before it calculates CP if there is no more Capital Goods
*/
for(cur3=p->search("Sector"); cur3!=NULL; cur3=go_brother(cur3) )
 {
  v[3]=cur3->cal("DEPRE",0);
  v[13]=cur3->cal("AVG_PROD_SET",0);
    for(v[8]=0,v[9]=0,v[10]=0,cur=cur3->search("Firm"); cur!=NULL; )//12/05/2006
  {
 
       for(v[0]=0,v[6]=0,v[7]=0,cur1=cur->search("B_K");cur1!=NULL;cur1=cur2)//delete old capital good
       {
       v[1]=cur1->cal("DataNasc",0);
       v[2]=cur1->cal("CP_BK",0);
       cur2=cur1->next;
          if((double)t>=v[1]+v[3])
          {
          v[0]=v[0]+v[2];
          v[15]=0;
          v[16]=0;
          //cur1->delete_obj();
          }
          else
          {
          v[0]=v[0];
          v[15]=cur1->cal("to_die_BK",0);
          v[16]=1;
          }
       v[6]=v[6]+v[15];
       v[7]=v[7]+v[16];   
       }
       
     cur->write("cp_depre_P",v[0],0); 
     v[4]=cur->cal("CP",1);
     v[18]=cur->cal("DELTACP_EF",0);
         
         if(v[4]-v[0]<=0&&v[18]>=0)
         {
              for(v[20]=0,v[19]=v[4],cur1=cur->search("B_K");v[19]>=2&&cur1!=NULL;cur1=cur2)//delete old capital good
                {
                v[21]=cur1->cal("DataNasc",0);
                v[22]=cur1->cal("CP_BK",0);
                cur2=cur1->next;
                   if((double)t>=v[21]+v[3])
                   {
                   v[20]=v[20]+v[22];
                   v[19]=v[19]-v[22];
                   cur1->delete_obj();
                   }
                   else
                   {
                   v[20]=v[20];
                   v[19]=v[19];
                   }
                }
         }  
         
         else
         {
            for(v[20]=0,cur1=cur->search("B_K");cur1!=NULL;cur1=cur2)//delete old capital good
              {
              v[21]=cur1->cal("DataNasc",0);
              v[22]=cur1->cal("CP_BK",0);
              cur2=cur1->next;
                 if((double)t>=v[21]+v[3])
                 {
                 v[20]=v[20]+v[22];
                 cur1->delete_obj();
                 }
                 else
                 {
                 v[20]=v[20];
                 }
              }
         }
         
    v[5]=v[4]+v[18]-v[0];
     
     
             if(v[5]<1)// firm must be deleted
             {
             v[9]=v[9];//12/05/2006
             v[8]=v[8];//Soma quantas firmas são eliminadas
             v[11]=cur->cal("EF_MS",1);
             v[10]=v[10]+v[11];
             plog("\nFirm Deleted - all capital depreciated physically");
             cur4=go_brother(cur);
             cur->delete_obj();
             cur=cur4;
             }
             else
             {
         				v[8]=v[8];//Soma Quantas firmas são eliminadas
             v[9]=v[9];
             v[10]=v[10];
             cur=go_brother(cur);
             }//end else if firm is not deleted because all her equipment was sold to pay debt
        }//end cycle for all firms
   cur3->write("Num_ExitP_2",v[8], 0);
   cur3->write("CP_ExitP_2",v[9], 0);
   cur3->write("EF_MS_ExitP_2",v[10], 0);
   }// end cycle for all sectors
res=0;
goto end;
}

/***********************************  PRODUÇÃO EFETIVA e VENDAS OBSERVADAS   ***************************************/

if(!strcmp(label,"BK_EFOR_firm"))
{
/*
Sector Variable
*/
v[17]=p->cal("Ibk",0);
v[30]=p->cal("SumMS",0);

if(v[17]==1)
{
		v[0]=p->cal("EFOR_BK",0);
		for(v[1]=0,v[2]=v[0],v[4]=0; (v[0]-v[1])>0&&v[4]<v[30]; v[2]=(v[0]-v[1]),v[4]=v[14])
 		{	
  			for(v[6]=v[4],v[3]=0,v[7]=0,v[20]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 			{
  			v[8]=cur->cal("MS",0);
  			v[18]=cur->cal("CP",1);
  			v[13]=cur->cal("BETA",0);
  			v[11]=v[13]*v[18];
  			v[16]=cur->cal("BK_Production_fP",0); 
  				if(v[16]<v[11])
  				{
  				v[28]=cur->cal("BK_EFOR_fP",0);
  				v[19]=v[28]+v[2]*v[8]/(1-v[6]);
  				v[5]=max((min(v[19],v[11])),0);
  				}
  				else
  				{
  				v[19]=cur->cal("BK_EFOR_fP",0);
  				v[5]=v[11];
   				}
  			cur->write("BK_EFOR_fP",v[19], 0);
  			cur->write("BK_Production_fP",v[5], 0);
  			v[20]=v[20]+v[5];
  			v[15]=min(v[19],v[11]);
    			v[7]=v[7]+v[15];
  
  				if(v[5]==v[11])
  				v[12]=v[8];
  				else
  				v[12]=0;
    			v[3]=v[3]+v[12];
 			}
	v[1]=v[7];
	v[14]=v[3];
		}
	}
	else
	v[20]=0;

res=v[20];
goto end;
}



if(!strcmp(label,"Intermidiate_Production"))
{
/*
Sector Variable
Setor de bens intermediários produz sob encomenda. Essa variável calcula o quanto foi demanda aos setores podutores de bens
intermediários nesse período de forma a determinar a produção efetiva dos setores produtores de insumo.
*/
v[17]=p->cal("Ibi",0);// não precisa, pois só quem chama é firma do setor de bens intermediários, correto? correto.
v[30]=p->cal("SumMS",0);
if(v[17]==1)// Se o setor é de bens intermediários
	{
		v[0]=p->cal("EFOR_intermediate",0);
		for(v[1]=0,v[2]=v[0],v[4]=0; (v[0]-v[1])>0&&v[4]<v[30]; v[2]=(v[0]-v[1]),v[4]=v[14])
 		{	
  			for(v[6]=v[4],v[3]=0,v[7]=0,v[20]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 			{
  			v[8]=cur->cal("MS",0);
  			v[9]=cur->cal("SIGMA",0);
  			v[10]=cur->cal("STOCK",1);
  			v[18]=cur->cal("CP",1);
  			v[13]=cur->cal("BETA",0);
  			v[11]=v[13]*v[18];
  			v[16]=cur->cal("Intermidiate_Production_fP",0); 
  				if(v[16]<v[11])
  				{
  				v[28]=cur->cal("Intermidiate_EFOR_fP",0);
  				v[19]=v[28]+v[2]*v[8]/(1-v[6]);
  				v[5]=max((min(v[19]*(1+v[9])-v[10],v[11])),0);
  				}
  				else
  				{
  				v[19]=cur->cal("Intermidiate_EFOR_fP",0);
  				v[5]=v[11];
   				}
  			cur->write("Intermidiate_EFOR_fP",v[19], 0);
  			cur->write("Intermidiate_Production_fP",v[5], 0);
  			v[20]=v[20]+v[5];
  			v[15]=min(v[19],v[11]+v[10]);
    			v[7]=v[7]+v[15];
  
  				if(v[5]==v[11])
  				v[12]=v[8];
  				else
  				v[12]=0;
    			v[3]=v[3]+v[12];
 			}
	v[1]=v[7];
	v[14]=v[3];
		}
	}
	else
	v[20]=0;

res=v[20];
goto end;
}


if(!strcmp(label,"Intermidiate_Production_firm"))
{
p->cal("Intermidiate_Production",0);
v[0]=p->cal("Intermidiate_Production_fP",0);
res=v[0];
p->write("Intermidiate_Production_fP",0, 0);

goto end;
}


if(!strcmp(label,"UAbi"))
{
/*
A quantidade de insumos a ser utilizada pelos setores de bens intermediários em sua produção é calculada multiplicando-se a produção de insumos desejada pelo coeficiente técnico.  
*/
v[0]=p->cal("Intermidiate_Production_firm",0);
v[1]=p->cal("A",0) ;
v[2]=p->cal("A_M",0) ;
res=v[0]*(v[1]+v[2]);
goto end;
}


if(!strcmp(label,"A_at_insumos"))
{
/*
Relação entre insumos disponíveis e insumos necessários para os setores de bens intermediários realizarem sua produção desejada.
*/
	v[2]=p->cal("UAbi",0);
	v[3]=p->cal("DA_stock_expost",1);
		if(v[2]>0)
		{
		v[0]=v[3]/v[2];
		}
		if(v[2]==0)
		{
		v[0]=1;
		}

res=min(1,v[0]);
goto end;
}


if(!strcmp(label,"minA_at_insumos"))
{
/*
Esta variável determina a menor razão entre o total de insumos disponíveis e os insumos necessários para produção desejada dos setores de bens intermediários.  
*/

p->stat("A_at_insumos",v);
res=v[4];

goto end;
}


if(!strcmp(label,"EFPR"))
{
/*
Firm variable
A produção efetiva de cada setor será determinada pela restrição imposta pela disponibilidade de insumos a realização da produção programada (ou produção de insumos desejada, no caso do setores intermediários).  Tal restrição é definida pela menor razão entre insumos disponíveis e os insumos necessários para produção.  
*/
v[0]=p->cal("PP",0);
v[1]=p->cal("Ibi",0);
v[2]=p->cal("Intermidiate_Production_firm",0);
	if(v[1]==0)//Se não for bem intermediário
	{
	v[3]=p->cal("minA_at",0);
	v[4]=v[3]*v[0];
	}

	if(v[1]==1)// se for bem intermediário
		{
	v[3]=p->cal("minA_at_insumos",0);
	v[4]=v[3]*v[2];
	  }
/*RULE FOR THE USE OF CAPITAL GOODS: THE MOST MODERN ARE THE FIRST TO BE USED*/   
    p->lsdqsort("B_K","A_BK","DOWN");
    for(v[5]=0,cur=p->search("B_K"); cur!=NULL; cur=go_brother(cur) )
    {
    v[6]=cur->cal("CP_BK",0);
    v[7]=p->cal("BETA",0);
    v[8]= max(0, min (v[6]*v[7], v[4]));
    cur->write("Q_P", v[8], 0);/*CAPTIAL GOOD PARAMETER, DETERMINES HOW MUCH WAS PRODUCED BY THAT CAPITAL GOOD IN THE CURRENT PERIOD*/
    v[4]=v[4]-v[8];
    v[5]=v[5]+v[8];
    }
res=v[5];


goto end;
}

if(!strcmp(label, "EFOR_Sector") )
{
/*

As encomendas efetivas são determinadas a partir da demanda total pelos produtos do setor.  Na soma da demnada por consumo com a demanda por bens de capital e com a demanda por bens intermediários, só assumirá valores positivos o fator referente ao setor que estiver chamando esta variável. No caso do setor agrícola, as encomendas efetivas incluem também suas exportações.
*/  
   v[0]=p->cal("DomConsDem",0);
   v[1]=p->cal("DomBKDem",0);
   v[2]=p->cal("DomIntDem",0);
   v[3]=v[0]+v[1]+v[2];//Encomendas Efetivas
   v[4]=p->cal("EXPORTS",0);
  	res=v[3]+v[4];
  	 
  goto end;
}

if(!strcmp(label,"Consumption_EFOR_firm"))
{
/*
Sector Variable
*/
v[17]=p->cal("Ibc",0);
v[30]=p->cal("SumMS",0);
if(v[17]==1) 
	{
		v[0]=p->cal("EFOR_Sector",0);
		for(v[1]=0,v[2]=v[0],v[4]=0; (v[0]-v[1])>0&&v[4]<v[30]; v[2]=(v[0]-v[1]),v[4]=v[14])
 		{	
  			for(v[6]=v[4],v[3]=0,v[7]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 			{
  			v[8]=cur->cal("MS",0);
  			v[18]=cur->cal("EFPR",0);
  			v[10]=cur->cal("STOCK",1);
  			v[11]=v[18]+v[10];
  			v[16]=cur->cal("Cons_EFOR_fP",0); 
  				if(v[16]<v[11])
  				{
  				v[19]=v[16]+v[2]*v[8]/(1-v[6]);
  				}
  				else
  				{
  				v[19]=v[16];
  				}
  			cur->write("Cons_EFOR_fP",v[19], 0);
  			v[15]=min(v[19],v[11]);
    			v[7]=v[7]+v[15];
  
  				if(v[15]==v[11])
  				v[12]=v[8];
  				else
  				v[12]=0;
    			v[3]=v[3]+v[12];
 			}
	v[1]=v[7];
	v[14]=v[3];
		}
	}
	else
	v[1]=0;

res=v[1];
goto end;
}




if(!strcmp(label,"SALES"))
{
/*
Firm
As vendas observadas são definidas pelo mínimo entre as encomendas efetivas e a produção efetiva mais estoques de cada setor. 

No caso dos setores intermediários, a venda de insumos a partir de seus estoques para atender à  demanda extraordinária no início do período deve ser somada ao total vendido.

No caso do setor agrícola, as vendas observadas são iguais à  produção corrente.
*/
    v[0]=p->cal("STOCK",1);
    v[1]=p->cal("EFPR",0);
    v[2]=p->cal("EFOR",0);
    v[3]=v[0]+v[1];//Produção efetiva + Estoques
    v[4]=max(0, min( v[3], v[2] ));
    res=v[4];
goto end;
}

if(!strcmp(label,"SALES_Sector"))
{
/*
Comment
*/

res=p->sum("SALES",0);
goto end;
}


if(!strcmp(label,"Dem_atend"))
{
/*
Dem_atend=(1+((VEF-EFOR)/EFOR) - Porcentagem da demanda atendida por cada setor
*/
	
v[0]=p->cal("EFOR_Sector",0);
v[1]=p->cal("SALES_Sector",0);
    if(v[0]>0)
    v[2]=v[1]/v[0];// calcula a 'porcentagem' da demanda que foi atendida
    else
    v[2]=1;
res=v[2];
goto end;
}

EQUATION("Dem_at_M")
/*
input variable
*/

v[0]=V("Id3");
cur=SEARCH_CND("Id1",v[0]);
v[1]=VS(cur,"Dem_atend_M");

RESULT(v[1])


EQUATION("Dem_at")
/*
input variable
*/

v[0]=V("Id3");
cur=SEARCH_CND("Id1",v[0]);
v[1]=VS(cur,"Dem_atend");

RESULT(v[1])

if(!strcmp(label, "STOCK") )
{
/*
Firm Variable
O estoque de produtos acabados no final do período será calculado somando o estoque restante de produtos no início do período ao que foi produzido e descontando a quantidade vendida.  

No caso do setor agrícola, não há estoque de produtos acabados no final do período.
*/
		
   v[0]=p->cal("EFPR", 0);// actual production
   v[1]=p->cal("SALES", 0);//actual sales
   v[2]=p->cal("STOCK",1);
   res=(v[0]-v[1]+v[2]);
   goto end;

}

if(!strcmp(label, "STOCK_Sector"))    
{
/*
Sector Variable
Sum of the STOCK 
*/

for(v[0]=0, cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=cur->cal("STOCK",0);
  v[0]=v[0]+v[1];
 }
res=v[0];
goto end;
}

if(!strcmp(label, "EFPR_Sector"))    
{
/*
Sector Variable
Sum of the actual production 
*/
for(v[0]=0, cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=cur->cal("EFPR",0);
  v[0]=v[0]+v[1];
 }
res=v[0];
goto end;
}

if(!strcmp(label, "CP_Sector"))    
{
/*
Sector Variable
Sum of the actual production 
*/
for(v[0]=0, cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=cur->cal("CP",0);
  v[0]=v[0]+v[1];
 }
res=v[0];
goto end;
}

if(!strcmp(label,"DA_stock_expost"))
{
/*

O estoque de insumos de cada setor no final do período é calculado pela soma dos estoques de insumo que não foram utilizados na produção corrente com a demanda por insumos do período.  
*/

v[0]=p->cal("Ibi",0);
v[1]=p->cal("DA",0);
v[2]=p->cal("Dem_at",0);//A porcentagem da demanda que setor que foi demandado conseguiu atender. 22/03/04
v[3]=p->cal("Dem_at_M",0);
v[4]=v[2]+(1-v[2])*v[3];
v[5]=p->cal("DA_stock_exante",0);
v[6]=p->cal("IMPORT",0);
	if(v[0]==0)//se não for setor de bens intermediários
	v[7]=v[1]*v[4]+v[5]+v[6];
	
	if(v[0]==1)
	{
		v[8]=p->cal("UAbi",0);
		v[9]=p->cal("DA_stock_expost",1);
		v[10]=p->cal("minA_at_insumos",0);
		v[7]=v[1]*v[4]+(v[9]-(v[10]*v[8]))+v[6];
	}
res=max(v[7],0);
goto end;
}

if(!strcmp(label,"DELTACP_efetiva"))
{
/*
Firm Variable
Variação de capacidade demanda efetivamente produzida pelo setor de Bens de capital
Alteração Tita - a parte importada não sofre restrição
*/
last_update--;//repeat the computation any time is requested
if(c==NULL)//Avoids to be computed when the system activates the equation
{
res=-1;
goto end;
}
v[17]=c->cal("Id2",0);
v[12]= fmod((double) t,6); // armazena em v[12] o resto da divisao de t(período corrente) por 4.
if(v[17]==v[12]||v[17]==(v[12]+6)||v[17]==(v[12]+12)||v[17]==(v[12]+18))
{
v[0]=c->cal("DELTACP",6);
	
    for(v[1]=1,v[2]=1,v[3]=1,v[4]=1,v[13]=1,v[14]=1,v[36]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
    {
     v[5]=cur->cal("Ibk",0);
    	if(v[5]==1)
    	{
    	v[20]=cur->cal("Dem_atend",5);
    	v[21]=cur->cal("Dem_atend",4);
    	v[16]=cur->cal("Dem_atend",3);
    	v[15]=cur->cal("Dem_atend",2);
    	v[18]=cur->cal("Dem_atend",1);
    	v[19]=cur->cal("Dem_atend",0);
    	v[30]=cur->cal("Dem_atend_M",5);
    	v[31]=cur->cal("Dem_atend_M",4);
    	v[26]=cur->cal("Dem_atend_M",3);
    	v[25]=cur->cal("Dem_atend_M",2);
    	v[28]=cur->cal("Dem_atend_M",1);
    	v[29]=cur->cal("Dem_atend_M",0);
    	v[6]=v[16]+(1-v[16])*v[26];
    	v[7]=v[15]+(1-v[15])*v[25];
    	v[8]=v[18]+(1-v[18])*v[28];
    	v[9]=v[19]+(1-v[19])*v[29];
    	v[10]=v[20]+(1-v[20])*v[30];
    	v[11]=v[21]+(1-v[21])*v[31];	
    	v[35]=cur->cal("M_BK",0);
     }
    	if(v[5]==0)
    	{
    	v[6]=1;
    	v[7]=1;
    	v[8]=1;
    	v[9]=1;
    	v[10]=1;
    	v[11]=1;
     v[35]=0;
      	}
    v[1]=min(v[1],v[6]);
    v[2]=min(v[2],v[7]);
    v[3]=min(v[3],v[8]);
    v[4]=min(v[4],v[9]);
    v[13]=min(v[13],v[10]);
    v[14]=min(v[14],v[11]);
    v[36]=max(v[35],v[36]);//tem que ser alterado se tiver mais de um setor de BK
    }

res=v[0]*(1-v[36])*((v[1]+v[2]+v[3]+v[4]+v[13]+v[14])/6)+v[0]*v[36];
}
else
res=0;
goto end;
}

if(!strcmp(label,"DELTACP_EF"))
{
/*
Firm Variable
*/
v[0]=p->cal("DELTACP_efetiva",0);
res=v[0];
goto end;
}

if(!strcmp(label,"CONSUMO_efetivo"))
{
/*
Consumo realizado
Alteração Tita - inclui IMPORTACAO_OBS
*/

v[0]=p->cal("DomConsDem",0);
v[1]=p->cal("Dem_atend",0);
v[2]=p->cal("Dem_atend_M",0);
v[3]=p->cal("OBS_IMPORTS",0);
v[4]=p->cal("Ibc",0);
if(v[4]==1)
res=v[0]*(v[1]+(1-v[1])*v[2])+v[3];
else
res=0;

goto end;
}


/*
if(!strcmp(label,"Invest_aut_ef"))
{
/*
Investimento aut realizado - mudança 22/10/02 outra 22/03/04
Essa variável, assim como Investimento_aut deve ser alterada caso seja inserido mais um setor de BK

last_update--;//repeat the computation any time is requested
if(c==NULL)//Avoids to be computed when the system activates the equation
{
res=-1;
goto end;
}
v[0]=c->cal("Invest_aut",0);
for(v[1]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
{
  v[2]=cur->cal("Ibk",0);
  if(v[2]==1)
  {
  v[3]=cur->cal("Dem_atend",0);
  v[4]=cur->cal("Dem_atend_M",0);
  v[5]=v[3]+(1-v[3])*v[4];
  }
  else
  v[5]=0;
  v[1]=max(v[1],v[5]);
}
res=v[0]*v[1];
goto end;
}

if(!strcmp(label,"I_aut_ef"))
{
v[0]=p->cal("Invest_aut_ef",0);
res=v[0];
goto end;
}
*/



/**************************************** NEW FIRM'S VARIABLES **************************************/


if(!strcmp(label,"EF_EFOR"))
{
/*
Comment
*/
v[0]=p->cal("EFOR_Sector",0);
v[1]=p->cal("MS",0);
res=v[0]*v[1] ;
goto end;
}

if(!strcmp(label,"EFOR"))
{
/*
Comment
*/
v[0]=p->cal("Ibi",0);
v[1]=p->cal("Ibc",0);
v[2]=p->cal("Ibk",0);
if(v[0]==1)
{
p->cal("Intermidiate_Production",0);
v[3]=p->cal("Intermidiate_EFOR_fP",0);
}
if(v[1]==1)
{
p->cal("Consumption_EFOR_firm",0);
v[3]=p->cal("Cons_EFOR_fP",0);
}

if(v[2]==1)
{
v[3]=p->cal("EFOR_BK_firm",0);
}

p->write("Intermidiate_EFOR_fP",0, 0);
p->write("Cons_EFOR_fP",0, 0);

res=v[3];
goto end;
}


if(!strcmp(label, "SumMS"))    
{
/*
Market Variable
Sum of the Market shares: finalidade análise para verificar funcionamento de equação de Fisher
*/
res=p->sum("MS",0);
goto end;
}

if(!strcmp(label, "MS"))
{

v[0]=p->cal("MS",1);
v[1]=p->cal("EM",0);
v[2]=p->cal("VELO",0);
v[3]=p->cal("E",0);
  if(v[1]!=0)
  res=v[0]+v[0]*v[2]*((v[3]/v[1])-1);
  else
  res=0;
goto end;
}
/*
if(!strcmp(label, "E") )
{
//competitiveness

v[0]=p->cal("PRICE",0);
v[1]=p->cal("Ep",0);
v[4]=p->cal("E",1); //14/10/2003
v[2]=p->cal("D_D",1);
v[3]=p->cal("Ed",0);

	if(v[0]!=0&&v[2]!=0)
	res=(1/pow(v[0],v[1]))*(1/pow(v[2],v[3]));
	else
	{
	res=v[4];
 	plog("\nERROR: preco igual a zero");
 	}
/* ATENCAO
	if(v[0]!=0)
	res=(1/pow(v[0],v[1]));
	else
	{
	res=v[4];
 	plog("\nERROR: price equal to zero");
 	}

  goto end;
}
*/


if(!strcmp(label, "D_D") )
{
/*atraso de entrega*/
   v[0]=p->cal("EF_EFOR", 0);
   v[1]=p->cal("SALES", 0);
if(v[1]!=0)
   res=v[0]/v[1];
else
res=1;
  goto end;
}
if(!strcmp(label, "EM"))
{
/*
Average Efficiency  (look at the lag in MS.Different from onesector5).
*/
for(v[0]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
{
v[1]=cur->cal("E",0);
v[2]=cur->cal("MS",1);
v[0]=v[0]+v[1]*v[2];
}
res=v[0];
goto end;

}

/************************************** innovation/imitation ********************************************/

if(!strcmp(label, "PROD"))
{

/***************************
PROD(t) = max(PROD(t-1), PROD_IM(t), PROD_IN(t)

the new productivity is the maximum among the previous one and the ones
possibly obtained imitation and innovation. The latters are assigned the
value 0 if the research fails to provide a new productivity (see their equation)

***************************/
  v[0]=p->cal("PROD", 1);
  v[1]=p->cal("PROD_IM", 0);
  v[2]=p->cal("PROD_IN", 0);
v[3]= max(max(v[1], v[2]),v[0]);

if(v[3]==v[0])
{
 p->write("IM",0,0);
 p->write("IN",0,0);
 }
if(v[3]==v[1])
{
 p->write("IM",1,0);
 p->write("IN",0,0);
 }

if(v[3]==v[2])
{
 p->write("IM",0,0);
 p->write("IN",1,0);
 }

res=v[3];

 goto end;
}
/*
 if(!strcmp(label, "Num_IM"))
 {
 v[0]=p->cal("IM",0);
 res=val[0]+v[0];
 goto end;
 }

if(!strcmp(label, "IM"))
 {
 p->cal("PROD",0);
 res=val[0];
 goto end;
 }
 
 if(!strcmp(label, "Num_IN"))
 {
 v[0]=p->cal("IN",0);
 res=val[0]+v[0];
 goto end;
 }


if(!strcmp(label, "IN"))
 {
 p->cal("PROD",0);
 res=val[0];
 goto end;
 }
*/

if(!strcmp(label, "PROD_IM"))
 {
   v[0]=p->cal("REVENUE", 1);
   v[1]=p->cal("RIM", 0);
   v[2]=p->cal("PROD_MAX", 1);// Greatest Productivity among all firms in the sector 
   v[3]=p->cal("am",0);
   v[4]=p->cal("PRICE",1);
   v[6]=(v[0]*v[1]);//P&D em imitação
   v[7]=(1-exp(-v[6]*v[3]));//1029
   p->write("Prob_IM_P",v[7],0);
     if(RND<v[7])
     {
     res=v[2];    
     //p->write("sucessoim",1,0);
     }
     else
     {
     //p->write("sucessoim",0,0);
     res=0;
     } 
goto end;
}

FUNCTION("PROD_IM_FUNCTION")
/*
Function in the sector
*/
v[0]=VS(c,"a_bk_MAX");
for(v[2]=100,v[4]=v[0],cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=cur->cal("a_bk_MAX",1);
  v[3]=v[1]-v[0];
  v[2]=max(0,min(v[2],v[3]));
  if(v[2]==v[3])
  v[4]=v[1];
  else
  v[4]=v[4];
 }

RESULT(v[4])


/*
if(!strcmp(label, "Num_sucessoim"))
 {
 v[0]=p->cal("sucessoim",0);
 res=val[0]+v[0];
 goto end;
 }

if(!strcmp(label, "sucessoim"))
 {
 p->cal("A_IM",0);
 res=val[0];
 goto end;
 }
*/

if(!strcmp(label, "PROD_IN"))
 {

   v[0]=p->cal("REVENUE", 1);
   v[1]=p->cal("RIN", 0);
   v[2]=p->cal("Inn", 0);
   v[3]=p->cal("an",0);
   v[5]=p->cal("PRICE",1);
   v[4]=v[0]*v[1]*v[2];//P&D em inovaçao.
   v[7]=p->cal("Prod_ini",0);
   p->write("P&D_IN_P",v[4],0);
   v[12]=v[2]*(1-exp(-v[4]*v[3]));//1081
   p->write("Prob_IN_P",v[12],0);
   v[9]=p->cal("REGIM_TECN",0);//DETERMINA SE TEMOS SCIENCE BASED OU CUMULATIVO.
   v[10]=p->cal("PROD",1);
   v[13]=p->cal("SD_PROD",0);
   
   if(v[9]==1)//Science Based CORRECTED used to be v[9]=1
   {
   v[8]=p->cal("OPORT_TECN",0);
   v[11]=log(v[7])+(double)t*(v[8]);
	}
   else//Cumulativo
   {
   v[11]=log(v[10]);
   }
   
   if(RND<(1-exp(-v[4]*v[3])) && v[2]==1)
   {
   res=exp(norm(v[11],v[13]));
   p->write("sucessoin",1,0);
   }
   else
	{
	res=0;
	p->write("sucessoin",0,0);
	} 
goto end;
}
/*
if(!strcmp(label, "P&D_IN"))
 {
 p->cal("A_IN",0);
 v[0]=p->cal("P&D_IN_P", 0);
 res=v[0]/100;
 goto end;
 }

if(!strcmp(label, "Sum_P&D"))
 {
 v[0]=p->sum("P&D_IN", 0);
 res=val[0]+v[0];
 goto end;
 }
 
if(!strcmp(label, "Num_sucessoin"))
 {
 v[0]=p->cal("sucessoin",0);
 res=val[0]+v[0];
 goto end;
 }

if(!strcmp(label, "sucessoin"))
 {
 p->cal("A_IN",0);
 res=val[0];
 goto end;
 }
*/

if(!strcmp(label, "Prob_IN"))
{

p->cal("PROD_IN", 0);
v[0]=p->cal("Prob_IN_P", 0);
res=v[0];
goto end;
}

if(!strcmp(label, "Prob_IM"))
{

p->cal("PROD_IM", 0);
v[0]=p->cal("Prob_IM_P", 0);
 res=v[0];

goto end;
}


if(!strcmp(label, "PROD_MAX"))
{
     p->stat("PROD", v);    
     res=v[3];
goto end;
}
/*
if(!strcmp(label, "A_MIN") )
{
 p->stat("PROD", v);  
 res=v[4];
 goto end;
}
if(!strcmp(label, "A_VAR") )
{
 p->stat("PROD", v);  
 res=v[2];
 goto end;
}

if(!strcmp(label, "Num_IM_MAX"))
{
    p->stat("Num_IM", v);
    res=v[3];
  goto end;
}
if(!strcmp(label, "Num_IM_MED") )
{
p->stat("Num_IM", v);
res=v[1];
 goto end;
}

if(!strcmp(label, "Num_IN_MAX"))
{
    p->stat("Num_IN", v);

   res=v[3];
  goto end;
}
if(!strcmp(label, "Num_IN_MED") )
{
 p->stat("Num_IN", v);
  res=v[1];
 goto end;
}


if(!strcmp(label, "A_MEDIOMAX"))//Produtividade máxima na fronteira tecnológica
{
    p->stat("A_MEDIO", v);
    res=v[3];
  goto end;
}

if(!strcmp(label, "A_MEDIOMIN") )
{
 p->stat("A_MEDIO", v);
    res=v[4];
 goto end;
}
if(!strcmp(label, "A_MEDIOVAR") )
{
p->stat("A_MEDIO", v);
    res=v[2];
 goto end;
}


if(!strcmp(label, "A_MAX_TOT"))//Produtividade máxima entre os bens de K instalados
{
    p->stat("A_MAX", v);
    res=v[3];
  goto end;
}
if(!strcmp(label, "a_MAX_TOT"))//Produtividade máxima entre os bens de K instalados
{
    p->stat("a_bk_MAX", v);
    res=v[3];
  goto end;
}
if(!strcmp(label, "A_MAX_TOTMED") )
{
     p->stat("A_MAX", v);
    res=v[2];
 goto end;
}
if(!strcmp(label, "A_MAX_TOTMIN") )
{
    p->stat("A_MAX", v);
    res=v[4];
     goto end;
}
if(!strcmp(label, "A_MAX_TOTVAR") )
{
     p->stat("A_MAX", v);
    res=v[2];
    goto end;
}

if(!strcmp(label, "A_BK_N") )
{
 p->stat("A_BK", v);
    res=v[0];
 goto end;
}
if(!strcmp(label, "A_BK_MED") )
{
 p->stat("A_BK", v);
    res=v[1];
 goto end;
}
if(!strcmp(label, "A_BK_MIN") )
{
 p->stat("A_BK", v);
    res=v[4];
 goto end;
}

if(!strcmp(label, "a_bk_MIN") )
{
  p->stat("a_bk", v);
 res=v[4];
 goto end;
}

if(!strcmp(label, "A_BK_VAR") )
{
 p->stat("A_BK", v);
    res=v[2];
 goto end;
}

*/

/****************************************  PREÇO e RENDA  ***********************************************/

FUNCTION("PRICE_Function")
/*
Function, it must be called by the firms
*/
v[0]=VS(c,"DES_MARKUP");
v[1]=VS(c,"WAGE");
v[2]=VLS(c,"AVG_PROD",1);
v[3]=VS(c,"ind_taxesP");
v[4]=VS(c,"IntG_Cost");
v[5]=v[0]*((v[1]/v[2])+v[4]);//Price
v[6]=v[5]*(1-v[3])-(v[1]/v[2]+v[4]);//Excedente
c->write("SURPLUS_P",v[6],0);
RESULT(v[5] )


EQUATION("Cost")
/*
Costs of the inputs - input variable
*/

v[0]=V("Id3");
cur=SEARCH_CND("Id1",v[0]);
v[1]=VLS(cur,"Avg_PRICE",1);
v[2]=VS(cur,"P_F");
v[3]=V("A");
v[4]=V("A_M");
v[5]=V("EXCHANGE_RATE");
v[6]=VL("Dem_at",1);
v[7]=VL("Dem_at_M",1);
RESULT(v[1]*v[3]*v[6]+v[2]*v[5]*v[4]+1.1*(1-v[6])*v[7]*v[3]*v[2]*v[5])


EQUATION("IntG_Cost")
/*
Firm variable - Intermediate goods Costs
*/
v[0]=SUM("Cost");

RESULT(v[0] )


EQUATION("PRICE_DES")
/*
Firm variable
*/
v[0]=V("PRICE_Function");

RESULT(v[0] )

if(!strcmp(label,"Avg_PRICE"))
{
/*
Sector Variable
*/
for(v[0]=0, cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=cur->cal("PRICE",0);
  v[2]=cur->cal("MS",0);
  v[0]=v[0]+(v[2]/v[1]);
 }
if(v[0]!=0)
v[3]=1/v[0];
else
v[3]=0;
res=v[3];
goto end;
}



if(!strcmp(label,"PROFITS"))
{
/*
Lucro de cada firma, diferença entre receita e custos, sendo receita função do preço e das vendas e custo do total de insumos e trabalho usados na produção.
*/

v[0]=p->cal("REVENUE",0);
v[1]=p->cal("EFPR",0);
v[3]=p->cal("ind_taxesP",0);
v[4]=p->cal("CVAR",0);
v[6]=p->cal("CP",1);
v[7]=p->cal("fi",0);
v[5]=(1-v[3])*v[0]-(v[4]*v[1])-(v[6]*v[7]);
res=v[5];
goto end;
}

EQUATION("REVENUE")
/*
Comment
*/
v[0]=p->cal("SALES",0);
v[1]=p->cal("EXPORTS",0);
v[2]=p->cal("PRICE",0);
v[4]=V("EXCHANGE_RATE");
v[5]=V("EF_MS");
v[6]=v[2]*(v[0]-v[5]*v[1])+v[5]*v[1]*v[2]/v[4];
RESULT(v[6])


EQUATION("EF_MS")
/*
Comment
*/
v[0]=V("SALES");
v[1]=V("SALES_Sector");

RESULT(v[0]/v[1] )


if(!strcmp(label,"PRICE_BK"))
{
/*
Preço do setor de bem de capital
*/
cur=p->search_var_cond("Ibk",1,0);
v[0]=cur->cal("Avg_PRICE",1);
res=v[0];
goto end;
}

if(!strcmp(label, "SURPLUS_UNIT") )
{

p->cal("PRICE",0);
v[1]=p->cal("SURPLUS_P",0);
res=v[1];
goto end;
}


if(!strcmp(label, "SURPLUS") )
{
/*
O excedente total de cada firma é calculado multiplicando-se o excedente por unidade de produção pelas vendas observadas.  
*/
p->cal("STOCK",0);
p->cal("PRICE",0);
v[0]=p->cal("SALES",0);
v[1]=p->cal("SURPLUS_UNIT",0);//Excedente_unit
res=v[0]*v[1];
goto end;
}


if(!strcmp(label,"retained_profit"))
{
/*
Lucro retido pelo setor depois de distribuído para classe e pagos os juros sobre a dívida e separado o gasto para depreciação.
*/
v[0]=p->cal("PROFITS",0);
v[1]=p->cal("dist_rate",0);
v[2]=p->cal("DEBT",1);
v[3]=p->cal("INTERESTS_RATE_firm",0);
v[4]=p->cal("Depre_Expenses",0);
v[7]=p->cal("APLIC_FIN",1);
v[8]=p->cal("RETURN_RATE",0);
v[9]=p->cal("RIM", 0);
v[10]=p->cal("RIN", 0);
v[11]=p->cal("Inn",0);
v[12]=p->cal("REVENUE",0);
v[14]=p->cal("RQN", 0);
v[15]=p->cal("RQM", 0);
v[16]=p->cal("fi", 0);
v[17]=p->cal("CP", 1);
v[5]=v[0]+v[7]*v[8]-(v[4]+v[2]*v[3])-(v[9]+v[10]*v[11]+v[14]+v[15])*(v[12]);//Net Profits
   if(v[5]>0)
     {
     v[6]=(1-v[1])*v[5];
     v[13]=(v[1])*v[5]+(v[9]+v[10]*v[11]+v[14]+v[15])*(v[12])+v[16]*v[17];
     p->write("DISTRIBUTION_P",v[13],0);
     p->write("Ret_aplic_finP",v[7]*v[8]-v[2]*v[3],0);
     }
   else
     {
     v[6]=v[5];
     p->write("DISTRIBUTION_P",0,0);
     p->write("Ret_aplic_finP",v[7]*v[8]-v[2]*v[3],0);
     }
res=v[6];//pode ser negativo
goto end;
}

EQUATION("DISTRIBUTION")
/*
Firm Variable
*/
V("retained_profit");
v[0]=V("DISTRIBUTION_P");

RESULT(v[0])


if(!strcmp(label,"Depre_Expenses"))
{
/*
Gastos com depreciação, gastos são determinados por perído de produção
*/
v[0]=p->cal("CP",1);
v[1]=p->cal("depre_rate",0);
v[2]=p->cal("PRICE_BK",0);
cur=p->search_var_cond("Id3",2,0);
v[3]=cur->cal("B",0);
res=v[0]*(v[1]/6)*v[3]*v[2];
goto end;
}


if(!strcmp(label,"DEBT_RATE"))
{
/*
Grau de endividamento, calculado pela razão entre a dívida e o capital do setor.
*/
v[0]=p->cal("DEBT",0);
v[1]=p->cal("CAPITAL",0);
v[2]=p->cal("APLIC_FIN",1);
if(v[1]+v[2]>0.001)
res=v[0]/(v[1]+v[2]);
else
res=1.1;
goto end;
}



if(!strcmp(label,"CAPITAL"))
{
/*
Capital de cada setor, igual ao valor dos bens de capital disponíveis
*/
v[0]=p->cal("CP",0);
v[1]=p->cal("PRICE_BK",0);
  cur=p->search_var_cond("Id3",2,0);
  v[2]=cur->cal("B",0);
res=v[0]*v[1]*v[2];
goto end;
}


if(!strcmp(label,"DISTRIB_PROFITS"))
{
/*
Lucro distribuído pelos setores
*/
for(v[0]=0,v[4]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 {
    for(v[1]=0,v[5]=0,cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
    {
     cur1->cal("retained_profit",0);
     v[2]=cur1->cal("DISTRIBUTION",0);
     v[3]=cur1->cal("Ret_aplic_finP",0);     
     v[1]=v[1]+v[2];
     v[5]=v[5]+v[3];     
    }
 v[0]=v[0]+v[1];
 v[4]=v[4]+v[5];
 } 
WRITE("RET_APLIC_FIN_P",v[4]); 
res=v[0];
goto end;
}

EQUATION("RET_APLIC_FIN_liq")
/*
Comment
*/
V("DISTRIB_PROFITS");
v[0]=V("RET_APLIC_FIN_P");

RESULT(v[0])


if(!strcmp(label,"SURPLUS_TOT"))
{
/*
O excedente total da economia é calculado somando-se o excedente de cada setor.  
*/
for(v[0]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
{
	for(v[1]=0,cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
 {
  v[2]=cur1->cal("SURPLUS",0);
  v[1]=v[2]+v[1];
 }
v[0]=v[0]+v[1];
}
res=v[0];
goto end;
}


if(!strcmp(label, "WAGE_TOT") )
{
/*
O salário total é calculado pela soma dos salários pagos no setor agrícola com os salários pagos nos demais setores e os salários pagos pelo governo.  O salário por unidade de produção é um parâmetro pré-determinado, e o salário total é calculado multiplicando-se este salário unitário pela produção efetiva de cada setor (a contratação de trabalhadores é realizada apenas depois que se constata o quanto se tem de insumos disponíveis para poder produzir).  No caso do setor agrícola, o salário total é calculado multiplicando-se o salário unitário pela produção programada restringida pelos insumos disponíveis.  E, no caso do governo, 60% de seus gastos são direcionados para o pagamento de pessoal.  
*/
for(v[0]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
{
v[3]=cur->cal("WAGE",0);
	for(v[1]=0,cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
 {
  v[2]=cur1->cal("EFPR",0);
  v[6]=cur1->cal("AVG_PROD",1);
  v[1]=v[1]+v[2]*(v[3]/v[6]);
 }
v[0]=v[0]+v[1];
}
v[4]=p->cal("Wage_Gov",0);


res=v[0]+v[4];//Inclui salários do funcionalismo 
goto end;
}

if(!strcmp(label,"WAGE"))
{
/*
Comment
*/
v[0]=p->cal("WAGE",1);
v[1]= fmod((double) t,4);
   if(v[1]==0)
   {
   v[2]=p->cal("AVG_PROD_SET",1);
   v[3]=p->cal("AVG_PROD_SET",5);
   v[4]=(v[2]-v[3])/v[3];
   v[5]=p->cal("GAMA_WAGE",0);
   v[7]=p->cal("IGP",1);
   v[8]=p->cal("IGP",5);
   v[9]=(v[7]-v[8])/v[8];
   v[10]=p->cal("IGP_WAGE",0);
   v[6]=v[0]*(1+v[5]*v[4]+v[10]*v[9]);
   }
   else
   v[6]=v[0];


res=v[6];
goto end;
}


if(!strcmp(label, "CLASS_A_nom") )
{
/*
A renda nominal da classe A será calculada pela soma da proporção do excedente total com a proporção do salário líquido que é destinada à  classe mais o pagamento de juros do governo sobre a dívida pública interna.
*/

v[0]=p->cal("DISTRIB_PROFITS", 0);
v[1]=p->cal("WAGE_TOT", 0);
v[2]=p->cal("Prop_S_A",0);
v[3]=p->cal("Prop_W_A",0);
v[4]=p->cal("imp_dirP_A",0);

res=(v[0]*v[2]+v[1]*v[3])*(1-v[4]);
  goto end;
}


if(!strcmp(label, "CLASS_B_nom") )
{
/*
A renda nominal da classe B será calculada pela soma da proporção do excedente total com a proporção do salário líquido que é destinada à  classe.
*/

v[0]=p->cal("DISTRIB_PROFITS", 0);
v[1]=p->cal("WAGE_TOT", 0);
v[2]=p->cal("Prop_S_B",0);
v[3]=p->cal("Prop_W_B",0);
v[4]=p->cal("imp_dirP_B",0);
res=(v[0]*v[2]+v[1]*v[3])*(1-v[4]);
goto end;
}


if(!strcmp(label, "CLASS_C_nom") )
{
/*
A renda nominal da classe C será calculada pela soma da proporção do excedente total com a proporção do salário líquido que é destinada à  classe.
*/

v[0]=p->cal("DISTRIB_PROFITS", 0);
v[1]=p->cal("WAGE_TOT", 0);
v[2]=p->cal("Prop_S_C",0);
v[3]=p->cal("Prop_W_C",0);
v[4]=p->cal("imp_dirP_C",0);
res=(v[0]*v[2]+v[1]*v[3])*(1-v[4]);
goto end;
}


if(!strcmp(label, "CLASS_D_nom") )
{
/*
A renda nominal da classe D será calculada pela soma da proporção do excedente total com a proporção do salário líquido que é destinada à  classe.
*/

v[0]=p->cal("DISTRIB_PROFITS", 0);
v[1]=p->cal("WAGE_TOT", 0);
v[2]=p->cal("Prop_S_D",0);
v[3]=p->cal("Prop_W_D",0);
v[4]=p->cal("imp_dirP_D",0);
res=(v[0]*v[2]+v[1]*v[3])*(1-v[4]);
goto end;
}


if(!strcmp(label,"IPC_P_A"))
{
/*
O índice de preço para cada classe de renda é calculado com base no índice de Paasche, tendo como referência os preços observados no primeiro ano (que são iguais à  unidade e foram transformados em parâmetro â€œPREÇO_t0â€).  O cálculo será dado pela razão da soma para todos os setores da propensão a consumir da classe de renda multiplicada pelo preço do setor sobre a soma da propensão a consumir da classe vezes o preço básico.  No caso dos produtos do setor agrícola, o â€œPreço_agrâ€ substituirá o â€œPREÇO_OBSâ€.
*/

	for(v[2]=0,v[3]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
  {
  	cur->cal("IMPORTACAO_extra",0);
   v[0]=cur->cal("P_A",0);
   v[4]=cur->cal("Avg_PRICE_t0",0);
   v[6]=cur->cal("M_A",0);
   v[7]=cur->cal("P_F",0);
   v[8]=cur->cal("EXCHANGE_RATE",0);
   v[9]=cur->cal("P_F_t0",0);
   v[10]=cur->cal("Dem_atend",0);
   v[1]=cur->cal("Avg_PRICE",0);
   v[15]=cur->cal("Dem_atend_M",0);
   v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8]+1.1*v[15]*(1-v[10])*(v[0]*v[7]*v[8]);
   //v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8];
   v[3]=v[3]+v[0]*v[4]+v[6]*v[9];
  }

res=v[2]/v[3];
goto end;
}


if(!strcmp(label,"IPC_P_B"))
{
/*
O índice de preço para cada classe de renda é calculado com base no índice de Paasche, tendo como referência os preços observados no primeiro ano (que são iguais à  unidade e foram transformados em parâmetro â€œPREÇO_t0â€).  O cálculo será dado pela razão da soma para todos os setores da propensão a consumir da classe de renda multiplicada pelo preço do setor sobre a soma da propensão a consumir da classe vezes o preço básico.  No caso dos produtos do setor agrícola, o â€œPreço_agrâ€ substituirá o â€œPREÇO_OBSâ€.
*/

	for(v[2]=0,v[3]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
  {
   v[0]=cur->cal("P_B",0);
   v[4]=cur->cal("Avg_PRICE_t0",0);
   v[6]=cur->cal("M_B",0);
   v[7]=cur->cal("P_F",0);
   v[8]=cur->cal("EXCHANGE_RATE",0);
   v[9]=cur->cal("P_F_t0",0);
   v[10]=cur->cal("Dem_atend",0);
   v[1]=cur->cal("Avg_PRICE",0);
   v[15]=cur->cal("Dem_atend_M",0);
   v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8]+1.1*v[15]*(1-v[10])*(v[0]*v[7]*v[8]);
   //v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8];
   v[3]=v[3]+v[0]*v[4]+v[6]*v[9];
  }

res=v[2]/v[3];
goto end;
}


if(!strcmp(label,"IPC_P_C"))
{
/*
O índice de preço para cada classe de renda é calculado com base no índice de Paasche, tendo como referência os preços observados no primeiro ano (que são iguais à  unidade e foram transformados em parâmetro â€œPREÇO_t0â€).  O cálculo será dado pela razão da soma para todos os setores da propensão a consumir da classe de renda multiplicada pelo preço do setor sobre a soma da propensão a consumir da classe vezes o preço básico.  No caso dos produtos do setor agrícola, o â€œPreço_agrâ€ substituirá o â€œPREÇO_OBSâ€.
*/

	for(v[2]=0,v[3]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
  {
   v[0]=cur->cal("P_C",0);
   v[4]=cur->cal("Avg_PRICE_t0",0);
   v[6]=cur->cal("M_C",0);
   v[7]=cur->cal("P_F",0);
   v[8]=cur->cal("EXCHANGE_RATE",0);
   v[9]=cur->cal("P_F_t0",0);
   v[10]=cur->cal("Dem_atend",0);
   v[1]=cur->cal("Avg_PRICE",0);
   v[15]=cur->cal("Dem_atend_M",0);
   v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8]+1.1*v[15]*(1-v[10])*(v[0]*v[7]*v[8]);
   //v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8];
   v[3]=v[3]+v[0]*v[4]+v[6]*v[9];
  }

res=v[2]/v[3];
goto end;
}


if(!strcmp(label,"IPC_P_D"))
{
/*
O índice de preço para cada classe de renda é calculado com base no índice de Paasche, tendo como referência os preços observados no primeiro ano (que são iguais à  unidade e foram transformados em parâmetro â€œPREÇO_t0â€).  O cálculo será dado pela razão da soma para todos os setores da propensão a consumir da classe de renda multiplicada pelo preço do setor sobre a soma da propensão a consumir da classe vezes o preço básico.  No caso dos produtos do setor agrícola, o â€œPreço_agrâ€ substituirá o â€œPREÇO_OBSâ€.
*/

	for(v[2]=0,v[3]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
  {
   v[0]=cur->cal("P_D",0);
   v[4]=cur->cal("Avg_PRICE_t0",0);
   v[6]=cur->cal("M_D",0);
   v[7]=cur->cal("P_F",0);
   v[8]=cur->cal("EXCHANGE_RATE",0);
   v[9]=cur->cal("P_F_t0",0);
   v[10]=cur->cal("Dem_atend",0);
   v[1]=cur->cal("Avg_PRICE",0);
   v[15]=cur->cal("Dem_atend_M",0);
   v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8]+1.1*v[15]*(1-v[10])*(v[0]*v[7]*v[8]);
   //v[2]=v[2]+(v[0]*v[1])*v[10]+v[6]*v[7]*v[8];
   v[3]=v[3]+v[0]*v[4]+v[6]*v[9];
  }

res=v[2]/v[3];
goto end;
}


if(!strcmp(label, "CLASS_A") )
{
/*
A renda real da classe A é determinada pela razão entre a renda nominal e o índice de preço ao consumidor da classe.
*/

    v[0]=p->cal("CLASS_A_nom", 0);
    v[1]=p->cal("IPC_P_A", 0);
	 
	 res=v[0]/v[1];
	 goto end;
}


if(!strcmp(label, "CLASS_B") )
{
/*
A renda real da classe B é determinada pela razão entre a renda nominal e o índice de preço ao consumidor da classe.
*/

    v[0]=p->cal("CLASS_B_nom", 0);
    v[1]=p->cal("IPC_P_B", 0);

    res=v[0]/v[1];
   goto end;
}


if(!strcmp(label, "CLASS_C") )
{
/*
A renda real da classe C é determinada pela razão entre a renda nominal e o índice de preço ao consumidor da classe.
*/

    v[0]=p->cal("CLASS_C_nom", 0);
    v[1]=p->cal("IPC_P_C", 0);

    res=v[0]/v[1];
   goto end;
}


if(!strcmp(label, "CLASS_D") )
{
/*
A renda real da classe D é determinada pela razão entre a renda nominal e o índice de preço ao consumidor da classe.
*/

    v[0]=p->cal("CLASS_D_nom", 0);
    v[1]=p->cal("IPC_P_D", 0);

    res=v[0]/v[1];
   goto end;
}


/*************************************** SETOR PÚBLICO *********************************************/


if(!strcmp(label,"Superavit_rate_target"))
{
/*
A  meta de superávit do governo é recalculada a cada quatro períodos, tendo em vista a razão entre a divida pública e o valor agregado, e a relação entre a razão déficit/dívida e a taxa de crescimento do valor agregado.  Se a razão dívida/valor agregado for menor que 30%, a meta de superávit passada será reduzida no percentual determinado pelo parâmetro â€œvar_metasuperPâ€.  Se a razão dívida/valor agregado estiver entre 30% e 50% e a relação déficit/dívida média dos quatro últimos períodos for menor que o crescimento do valor agregado no último ano, a meta de superávit também será reduzida; se a relação for maior, a meta permanece inalterada.  No entanto, se a relação dívida/valor agregado estiver superior a 50%, então a meta de superávit será acrescida.
*/

v[16]=p->cal("Superavit_rate_target",1);
v[17]=p->cal("var_supertargetP",0);
v[18]= fmod((double) t,4);

  if(v[18]==0)
  {
  
  v[0]=p->cal("Q_GDP",7);
  v[1]=p->cal("Q_GDP",6);
  v[2]=p->cal("Q_GDP",5);
  v[3]=p->cal("Q_GDP",4);
  v[4]=(v[0]+v[1]+v[2]+v[3]);
  v[5]=p->cal("Q_GDP",3);
  v[6]=p->cal("Q_GDP",2);
  v[7]=p->cal("Q_GDP",1);
  v[8]=p->cal("Q_GDP",0);
  v[9]=(v[5]+v[6]+v[7]+v[8]);
  v[10]=(v[9]-v[4])/v[4];//variação do valor agregado anual
  
  			if(v[4]!=0)
			v[10]=(v[9]-v[4])/v[4];//variação do valor agregado anual
			else
			{
			v[10]=1;
			plog("\nERROR: VALOR_AGREGADO_anual igual a zero - ver Meta_Superavit");
			}
  v[13]=p->cal("Pub_Debt",0);
  v[14]=p->cal("Pub_Debt",4);
  			if(v[14]!=0)
			v[20]=(v[13]-v[14])/v[14];// crescimento divida_Pub
			else
			{
			v[20]=0;
			}
  v[21]=v[13]/v[9];//Pub_Debt/Anual_GDP
  
  if(v[21]<0.3)
				v[12]=v[16]-v[17];
			else
			{
				if(v[21]>=0.3&&v[21]<=0.4)
				{
					if(v[20]<v[10])
						v[12]=v[16]-v[17];
					else
						v[12]=v[16];
				}
				else
					v[12]=v[16]+v[17];
			}
	}	
	else
		v[12]=v[16];

res=min(max(-0.005,v[12]),0.03);
goto end;
}


if(!strcmp(label,"Superavit_target"))
{
/*
O superávit alvo do governo é determinado pelo produto da meta de superávit pelo valor agregado da economia, ambos defasados em um período.  
*/

v[0]=p->cal("Superavit_rate_target",1);
v[1]=p->cal("Q_GDP",1);
v[2]=p->cal("Q_GDP",2);
v[3]=p->cal("Q_GDP",3);
v[4]=p->cal("Q_GDP",4);
v[5]=p->cal("GAMA_ma",0);
  v[6]=(v[1]+v[2]);
  v[7]=(v[3]+v[4]);

	if(v[7]!=0)
	v[8]=v[0]*v[1]*(1+v[5]*((v[6]-v[7])/v[7]));
	else
	{
	v[8]=v[0]*v[1];
	plog("\nERROR: Q_DGP delayed equal to zero - see Superavit_target");
	}

res=v[8];
goto end;
}

if(!strcmp(label,"Gov_expenses"))
{
/*
Os gastos do governo são atualizados a cada período pela diferença entre os impostos esperados e o superávit alvo.  Os impostos esperados são calculados a partir dos impostos do período passado sobre os quais se aplica uma projeção de crescimento baseada na variação do valor agregado.  Estes gastos são voltados para pagamento de pessoal, consumo e investimento público. 
*/

v[11]= fmod((double) t,4);
   if(v[11]==0)
   {
   
       v[0]=p->cal("Q_GDP", 1);
       v[1]=p->cal("Q_GDP", 2);
       v[2]=p->cal("Q_GDP", 3);
       v[3]=p->cal("Q_GDP", 4);
       v[4]=p->cal("GAMA_ma",0); //GAMA(<=1)PROJEÇÃO - REFLETE O ESTADO DAS EXPECTATIVAS
       v[5]=(v[0]+v[1]);
       v[6]=(v[2]+v[3]);
          if(v[6]!=0)
          v[7]=1+v[4]*(v[5]-v[6])/v[6];// extrapolação da taxa de crescimento
          else
          v[7]=1;
       v[8]=p->cal("TOT_taxes",1);
       v[9]=p->cal("Superavit_target",0);
       v[10]=v[8]*v[7]-v[9];
         if(v[10]<=0)
         plog("\nERROR: Gov_expenses less or equal to zero!");
       
       v[12]=p->cal("Switch_Superavit_target", 0);
          if(v[12]==0)
          v[11]=v[10];
          else
          {
          v[13]=p->cal("Wage_Gov", 0);
          v[11]=max(v[13],v[10]);
          } 
   }
      
   else
   v[11]=p->cal("Gov_expenses",1);
   
res=max(0,v[11]);

goto end;
}

EQUATION("Wage_Gov")
/*
Comment
*/
v[0]= fmod((double) t,4);
   if(v[0]==0)
   {
   v[12]=p->cal("Switch_Superavit_target", 0);
          if(v[12]==0)
          {
          v[1]=p->cal("Gov_expenses", 0);
          v[2]=p->cal("Gov_wage_rate", 0);
          v[3]=v[1]*v[2];
          }
          else
          {
          v[1]=p->cal("Gov_expenses_ini", 0);
          v[2]=p->cal("Gov_wage_rate", 0);
          v[3]=v[1]*v[2];
          }
   }
   else
   v[3]=p->cal("Wage_Gov", 1);


RESULT(v[3])

EQUATION("Gov_expenses_ini")
/*
Comment
*/
v[0]= fmod((double) t,4);
   if(v[0]==0)
   {
   v[1]=p->cal("Gov_expenses_ini", 1);
   v[2]=p->cal("W_G_growth", 0);
   v[3]=p->cal("IGP", 1);
   v[4]=p->cal("IGP", 5);
   v[5]=v[1]*(1+v[2]+(v[3]-v[4]));
   }
   else
   v[5]=p->cal("Gov_expenses_ini", 1);


RESULT(v[5])




if(!strcmp(label,"Pg_juros_gov"))
{
/*
O pagamento de juros do governo é determinado pela incidência da taxa de juros sobre o estoque de dívida pública.  
*/

v[0]=p->cal("Pub_Debt",1);
v[1]=p->cal("INTERESTS_RATE",0);
res=v[0]*v[1];
goto end;
}


if(!strcmp(label,"Income_taxes"))
{
/*
Os impostos diretos são calculados a partir da aplicação de uma alíquota de imposto direto sobre o valor agregado da economia (total dos excedentes mais salários).
*/
v[0]=p->cal("WAGE_TOT",0);
v[1]=p->cal("DISTRIB_PROFITS",0);
v[2]=p->cal("imp_dirP_A",0);
v[3]=p->cal("imp_dirP_B",0);
v[4]=p->cal("imp_dirP_C",0);
v[5]=p->cal("imp_dirP_D",0);
v[6]=p->cal("Prop_S_A",0);
v[7]=p->cal("Prop_S_B",0);
v[8]=p->cal("Prop_S_C",0);
v[9]=p->cal("Prop_S_D",0);
v[10]=p->cal("Prop_W_A",0);
v[11]=p->cal("Prop_W_B",0);
v[12]=p->cal("Prop_W_C",0);
v[13]=p->cal("Prop_W_D",0);
v[14]=(v[0]*v[10]+v[1]*v[6])*v[2];
v[15]=(v[0]*v[11]+v[1]*v[7])*v[3];
v[16]=(v[0]*v[12]+v[1]*v[8])*v[4];
v[17]=(v[0]*v[13]+v[1]*v[9])*v[5];
v[18]=p->cal("Pg_juros_gov",0);
res=v[14]+v[15]+v[16]+v[17]+v[18]*v[2];
goto end;
}


if(!strcmp(label,"ind_taxes"))
{
/*
Os impostos indiretos são calculados a partir da aplicação de uma alíquota de imposto indireto sobre o valor das vendas observadas de cada setor.
*/

v[0]=p->cal("REVENUE",0);
v[2]=p->cal("ind_taxesP",0);
res=v[0]*v[2];
goto end;
}


if(!strcmp(label,"indirect_taxes"))
{
/*
Os impostos indiretos são obtidos pela soma dos impostos arrecadados sobre a venda de cada setor.
*/
for(v[0]=0, cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 {
	for(v[1]=0, cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
 {
  v[2]=cur1->cal("ind_taxes",0);
  v[1]=v[1]+v[2];
 }
 v[0]=v[0]+v[1];
 }

res=v[0];
goto end;
}


if(!strcmp(label,"TOT_taxes"))
{
/*
Soma dos impostos diretos e indiretos, que determina a receita total do governo.
*/
v[1]=p->cal("Income_taxes",0);
v[2]=p->cal("indirect_taxes",0);
res=v[1]+v[2];
goto end;
}


if(!strcmp(label,"Superavit_Primario"))
{
/*
O déficit público é calculado pela soma do total dos gastos do governo no período com o pagamento dos juros da dívida pública menos o total de sua receita (impostos diretos e indiretos).
*/
v[0]=p->cal("Gov_expenses",0);
v[1]=p->cal("TOT_taxes",0);
res=v[1]-v[0];

goto end;
}


if(!strcmp(label,"Public_Deficit"))
{
/*
O déficit público é calculado pela soma do total dos gastos do governo no período com o pagamento dos juros da dívida pública menos o total de sua receita (impostos diretos e indiretos).
*/
v[0]=p->cal("Gov_expenses",0);
v[1]=p->cal("TOT_taxes",0);
v[2]=p->cal("Pg_juros_gov",0);
res=v[0]-v[1]+v[2];
goto end;
}


if(!strcmp(label,"Pub_Debt"))
{
/*
O estoque de dívida pública do período é calculado somando o estoque passado com o déficit público corrente.  
*/
v[0]=p->cal("Pub_Debt",1);
v[1]=p->cal("Public_Deficit",0);
res=max(0,v[0]+v[1]);
goto end;
}


if(!strcmp(label,"INTERESTS_RATE"))
{
/*
Nesta versão, há uma alteração na determinação da taxa de juros
Modelo Multissetorial da Tese da Tita
TAXA DE JUROS REFERENCIAL DA ECONOMIA - títulos públicos do governo nacional.
*/

	
	v[1]=p->cal("EXP_INFLA",0);
	v[2]=p->cal("inf_target",0);
	v[3]=p->cal("impact_inf_interest",0);	
	v[4]=p->cal("min_interest",0);	

	v[5]=max(v[1],0);
	v[6]=max(v[3]*(v[5]-v[2]),0);
	
  if(v[5]<=v[2])
  v[11]=v[4]+v[5];
  else
  v[11]=v[4]+v[5]+v[6];
	
	
	res=v[11];
	goto end;
}

/*************************************** SETOR EXTERNO *********************************************/


if(!strcmp(label,"EXTERNAL_INCOME"))
{

v[2]=p->cal("EXTERNAL_INCOME",1);
v[3]=p->cal("EXCHANGE_RATE",0);

v[4]=(double)t;
v[5]=V("External_shock");
v[6]=V("Per_ext_shock");
v[7]=V("Dur_ext_shock");

if(v[4]>v[6]&&v[4]<(v[6]+v[7]))
res=(1+v[5])*v[2];
else
res=v[2];
goto end;
}

EQUATION("External_shock")
/*
Comment
*/
v[0]=V("External_shockP");
v[1]= fmod((double) t,4);
if(v[1]==0)
{
v[2]=UNIFORM(-0.5,1.5);
v[3]=v[0]*v[2];
}
else
v[3]=VL("External_shock",1);
RESULT(v[3])


if(!strcmp(label,"EXPORTS"))
{
/*
As exportações são definidas para cada setor a partir da aplicação de um coeficiente de exportação sobre a renda externa, e estarão sujeitas a choques aleatórios (relacionados, por ex., a políticas econômicas).  A divisão pelo preço observado no período passado permite transformar o valor das exportações em unidades de produtos exportados.
O cálculo das exportações do setor Agrícola será apresentado a seguir em "Export_agr".
*/
v[0]=p->cal("EXTERNAL_INCOME",0);
v[1]=p->cal("exp_coef",0);
v[4]=p->cal("Avg_PRICE",0);
v[7]=p->cal("P_F",0);
v[8]=p->cal("elast_X_income",0);
v[9]=p->cal("elast_X_PRICE",0);
v[10]=p->cal("EXCHANGE_RATE",0);
v[6]=v[1]*pow((v[7]*v[10])/v[4],v[9])*pow(v[0],v[8]);
v[5]=v[6];
//v[5]=norm(v[6],v[6]/100);
v[3]=v[5]/v[4]; //23/02
res=v[3];
goto end;
}

if(!strcmp(label,"exp_coef"))
{
/*
Como uma das hipóteses de simulação o coeficiente de exportações pode ser alterado em algum momento da simulação, como efeito de um aumento ou redução da competitividade, considerado exógeno devido a ausência da parte micro.
Como é variável setorial, o choque também será setorial.  
*/
v[0]=(double)t;
v[1]=V("Competitivness_shock");
v[2]=V("Per_comp_shock");
v[3]=VL("exp_coef",1);
v[4]=V("Dur_comp_shock");

   if(v[0]>v[2]&&v[0]<(v[2]+v[4]))
   res=(1+v[1])*v[3];
   else
   res=v[3];
goto end;
}

if(!strcmp(label,"EXPORTS_TOT"))
{
/*
As exportações totais da economia em valor são definidas a partir da soma das exportações de cada setor multiplicadas pelo preço cobrado no período.  
*/

for(v[0]=0, cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 {

	v[1]=cur->cal("EXPORTS",0);
	v[2]=cur->cal("Avg_PRICE",0);
	v[3]=cur->cal("Dem_atend",0);
	v[4]=v[1]*v[2]*v[3];
	v[0]=v[0]+v[4];
 }
res=v[0];
goto end;
}


if(!strcmp(label,"IMPORT"))
{
/*
Firm Variable
A importação de insumos é determinada com base na produção programada de cada setor e de seu coeficiente-técnico de importação de bens intermediários.
*/
  	v[0]=p->cal("PP",0);
   v[1]=p->cal("A_M",0);
  	v[2]=p->cal("GAMA",0); //GAMA(<=1)PROJEÇÃO REFLETE O ESTADO DAS EXPECTATIVAS
   		v[3]=p->cal("EFOR", 1);
   		v[4]=p->cal("EFOR", 2);
   		v[5]=p->cal("EFOR", 3);
   		v[6]=p->cal("EFOR", 4);
   		v[7]=(v[3]+v[4]);
   		v[8]=(v[5]+v[6]);
   		
   				if(v[8]!=0)
   				v[9]=1+(v[2]*((v[7]-v[8])/v[8]));// extrapolação da taxa de crescimento
   				else
   				v[9]=1;
   		
v[10]=v[0]*v[1]*v[9];
    
res=max(v[10],0);
goto end;
}

					



if(!strcmp(label,"IMPORTS_intermidiate"))
{
/*
O total importado de cada tipo de insumo é determinado pela soma para todos os setor da economia da importação do respectivo insumo. 
*/
last_update--;//repeat the computation any time is requested
if(c==NULL)//Avoids to be computed when the system activates the equation
{
res=-1;
goto end;
}
else
{
v[0]=c->cal("Ibi",0);
if(v[0]==1)
{
	v[1]=c->cal("Id1",0);
	for(v[2]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
  {
   		for(v[3]=0,cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
     {
      cur2=cur1->search_var_cond("Id3",v[1], 0);
     	v[4]=cur2->cal("IMPORT",0);
     	v[3]=v[3]+v[4];
     }
  v[2]=v[2]+v[3];
  }
}
else
v[2]=0;
}   
res=v[2];
goto end;
}


if(!strcmp(label,"IMPORTACAO_extra"))
{
/*
A importação extra, realizada se o setor não conseguir atender sua demanda interna, é determinada pela diferença entre as encomendas efetivas do setor e sua produção efetiva somada ao estoque disponível de produtos.  O valor destas importações é obtido multiplicando-se o resultado anterior pelo preço externo dos insumos do setor em questão.
Modificação Tita - Calculada apenas em função da demanda interna não atendida e sem contar parte da exportação não atendida
*/


v[0]=p->cal("DomConsDem",0);
v[1]=p->cal("DomBKDem",0);
v[2]=p->cal("DomIntDem",0);
v[3]=p->cal("Dem_atend",0);
v[4]=(v[0]+v[1]+v[2])*(1-v[3]);
v[5]=p->cal("Reserve",1);
if(v[4]>0)
{
   if(v[5]>0)
   v[6]=v[4];
   else
   v[6]=0;
   
   if(v[5]>0)
   v[7]=v[6]/v[4];
   else
   v[7]=1;
   
p->write("Dem_atend_M_P",v[7], 0);
}
else
v[6]=0;

res=v[6];
//res=v[3];

goto end;
}

if(!strcmp(label,"Dem_atend_M"))
{
/*
Essa variável assume valores 0 ou 1
*/
p->cal("IMPORTACAO_extra",0);
v[0]=p->cal("Dem_atend_M_P",0);
res=v[0];
goto end;
}


if(!strcmp(label,"OBS_IMPORTS"))
{
/*
A importação do setor de bens intermediários é definida na variável do nível macro â€œIMPORTAÇAO_insâ€, que é então transformada em uma variável do primeiro nível.

A importação do setor de bens de consumo é definida como a soma para todas as classes do produto da propensão a importar de cada classe de renda aplicada sobre a média da renda defasada da classe. 

A importação do setor de bens de capital é definida através do produto do coeficiente de importação pela demanda interna por bens de capital. 
*/
v[20]=p->cal("Ibc",0);
v[21]=p->cal("Ibi",0);
v[18]=p->cal("IMPORTACAO_extra",0); //22/03/04
if(v[21]==1)//Se for setor intermediário
{
v[19]=p->cal("IMPORTS_intermidiate",0);
}
else
{
		if(v[20]==1)//Se for setor de consumo e não for setor agrícola
		{
    v[0]=p->cal("CLASS_A", 1);
    v[1]=p->cal("CLASS_A", 2);
    v[2]=p->cal("CLASS_A", 3);
    v[3]=p->cal("CLASS_A", 4);
    v[10]=(v[0]+v[1]+v[2]+v[3])/4;
    v[4]=p->cal("CLASS_B", 1);
    v[5]=p->cal("CLASS_B", 2);
    v[6]=p->cal("CLASS_B", 3);
    v[11]=(v[4]+v[5]+v[6])/3;
    v[7]=p->cal("CLASS_C", 1);
    v[8]=p->cal("CLASS_C", 2);
    v[12]=(v[7]+v[8])/2;
    v[9]=p->cal("CLASS_D", 1);
    v[14]=p->cal("M_A", 0);
    v[15]=p->cal("M_B", 0);
    v[16]=p->cal("M_C", 0);
    v[17]=p->cal("M_D", 0);
    v[26]=p->cal("elast_M_income", 0);// para simplificar assumimos inicialmente a mesma elasticidade para todas as classes de renda, mas essa é uma hipótese forte.
    v[27]=p->cal("elast_M_price", 0);
    v[28]=p->cal("Avg_PRICE",0);
    v[29]=p->cal("P_F",0);
    v[30]=p->cal("EXCHANGE_RATE",0);
    v[31]=v[14]*pow(v[10],v[26]);
    v[32]=v[15]*pow(v[11],v[26]);
    v[33]=v[16]*pow(v[12],v[26]);
    v[34]=v[17]*pow(v[9],v[26]);
    v[19]=pow(v[28]/(v[29]*v[30]),v[27])*(v[31]+v[32]+v[33]+v[34]);
    		}
		else //Se for setor de BK
		{
		v[23]=p->cal("M_BK",0);	
		v[24]=p->cal("DomBKDem",0);
		v[35]=p->cal("Inv_gov",0);
		v[36]=p->cal("Avg_PRICE",1);
		v[19]=v[23]*((v[24]-(v[35]/v[36]))/(1-v[23]));
		}
}
res=v[19]+v[18];
goto end;
}


if(!strcmp(label,"TOT_IMPORTS"))
{
/*
As importações totais são obtidas a partir da soma das importações de todos os setores multiplicadas pelos respectivos preços internacionais, e convertidas para moeda nacional pela taxa de câmbio.
*/
v[0]=p->whg_av("OBS_IMPORTS", "P_F", 0);
v[1]=p->cal("EXCHANGE_RATE",0);
res=v[0]*v[1];
goto end;
}


if(!strcmp(label,"TRADE_BALANCE"))
{
/*
O saldo da balança comercial é obtido pela diferença entre o total das exportações e o total das importações.  
*/
v[1]=p->cal("EXPORTS_TOT",0);
v[2]=p->cal("TOT_IMPORTS",0);
res=v[1]-v[2];
goto end;
}



if(!strcmp(label,"BAL_Payments"))
{
/*
O saldo da balança de pagamentos será determinado pela soma do saldo da conta de transações correntes com a conta de capital.
*/
v[0]=p->cal("TRADE_BALANCE",0);
res=v[0];
goto end;
}


if(!strcmp(label,"Reserve"))
{
/*
O estoque de divisas no período será calculado somando-se ao estoque do período passado o saldo corrente da balança de pagamentos.  
*/
v[0]=p->cal("Reserve",1);
v[1]=p->cal("BAL_Payments",0);
res=v[0]+v[1];
goto end;
}


if(!strcmp(label,"EXCHANGE_RATE"))
{

v[0]=p->cal("EXCHANGE_RATE",1);
v[1]= fmod((double) t,10);
v[2]=VL("Reserve",1);
     if(v[1]==0&&v[2]<0)
     {
     v[3]=V("e_rate");
     v[4]=(1+v[3])*v[0];
     }
     else
     v[4]=v[0];
res=v[4];//fixa
goto end;
}

/*
if(!strcmp(label,"INTERESTS_RATE_EXT"))
{
v[0]=p->cal("INTERESTS_RATE_EXT",1);
res=v[0];
goto end;
}
*/




/********************************** PRICE EQUATION *******************************************/

if(!strcmp(label, "PRICE") )
{
/*price*/
v[0]=p->cal("PRICE",1);
v[1]=p->cal("PRICE_DES",0);//variable cost.CUSTO VARIµVEL
v[4]=p->cal("PAR1",0);
//v[5]=p->cal("PAR2",0);
v[6]=p->cal("Avg_PRICE",1);
//v[7]=p->cal("EM",1);
v[8]=v[4]*(v[1])+(1-v[4])*(v[6]);
if(v[1]>0)
res=max(0.01,v[8]); //o menor preço possível é 0.01.(isso é arbitrário,mas tinha que ser maior que 0)
else
res=v[0];

goto end;
}

if(!strcmp(label, "DES_MARKUP") )
{

//This is used on the desired Price - antigo K no modelo setorial

v[0]=p->cal("DES_MARKUP",1);
v[1]=p->cal("CVAR",0);
v[2]=p->cal("CVAR",1);
v[3]=v[0]*(v[2]/v[1]);//Des_MARKUPt*CVARt<=Des_MARKUPt-1*CVARt-1 <=> Des_MARKUPt<=Des_MARKUPt-1*(CVARt-1/CVARt)
v[4]=p->cal("K_DES",0);
v[5]=p->cal("K_DES",1);
v[6]=p->cal("SWITCH_KDES",0);
//p->write("K_max",v[3],0);
    if(v[6]==1)
    res=v[4];
    
    else
    {
         if(v[4]<v[5]) //se o nível de aspiração foi reduzido K é imediatamente ajustado
         res=v[4];
         
         else
         {
             if(v[2]>v[1]) //houve uma queda no custo variável unitário
             {
               if(v[4]>v[0])
               res=v[4];
               else 
               res=v[0];
             }
             else
             res=v[0];
           
         }
    }
goto end;
}

FUNCTION("CVAR")
/*
Firm Variable
*/
v[0]=VS(c,"IntG_Cost");
v[1]=VS(c,"WAGE");
v[2]=VLS(c,"AVG_PROD",1);
v[3]=(v[1]/v[2])+v[0];//Price

RESULT(v[3] )





if(!strcmp(label, "K_ef") )
{
/*effective markup */
v[0]=p->cal("PRICE",0);
v[1]=p->cal("CVAR",0);
if(v[1]!=0)
res=v[0]/v[1];
else
res=0;
goto end;
}


if(!strcmp(label, "PAR1") )
{
v[0]= fmod((double) t-1,8);

if(v[0]==0)
  {
  v[1]=p->cal("MS_MED",1);
  v[2]=p->cal("MS_DES",0);
  v[3]=p->cal("expandi",0);
  v[4]=val[0]*(1+v[3]*(v[1]-v[2])/v[2]);//If the value achieved is greater than the desired, the weight on the desired price is increased. 
  res=max(min(1,v[4]),0);
  }
else 
res=p->cal("PAR1",1);

goto end;
}

if(!strcmp(label, "MS_DES") )
{
v[0]=p->cal("MS_DES", 1);
v[1]= fmod((double) t-1,8);
if(v[1]==0)
 {
  v[2]=p->cal("MS_MED", 1);//desired mark-up
    
  res=(v[0]+v[2])/2;
  }
  else
  res=v[0];
  goto end;
}


if(!strcmp(label, "MS_MED") )
{
/*price desired*/
v[1]=p->cal("MS",1);
v[2]=p->cal("MS",2);
v[3]=p->cal("MS",3);
v[4]=p->cal("MS",4);
v[5]=p->cal("MS",5);
v[6]=p->cal("MS",6);
v[7]=p->cal("MS",7);
v[8]=p->cal("MS",0);
v[9]=(v[1]+v[2]+v[3]+v[4]+v[5]+v[6]+v[7]+v[8])/8;
  res=v[9];
  goto end;
}

if(!strcmp(label, "K_potMED") )
{
/*price desired*/
v[1]=p->cal("K_pot",1);
v[2]=p->cal("K_pot",2);
v[3]=p->cal("K_pot",3);
v[4]=p->cal("K_pot",4);
v[5]=p->cal("K_pot",5);
v[6]=p->cal("K_pot",6);
v[7]=p->cal("K_pot",7);
v[8]=p->cal("K_pot",0);
v[0]=(v[1]+v[2]+v[3]+v[4]+v[5]+v[6]+v[7]+v[8])/8;
  res=v[0];
  goto end;
}

if(!strcmp(label, "K_pot") )
{
/*markup desejado*/
v[0]=p->cal("Avg_PRICE",0);
v[1]=p->cal("CVAR",0);
if(v[1]!=0)
res=v[0]/v[1];
else
res=0;
goto end;
}


/************************************* Capital Good Variables *****************************************/

if(!strcmp(label, "Q") )
{
 p->cal("EFPR",0);
 v[1]=p->cal("Q_P",0);
 res=v[1];
 goto end;
}
/*talvez seja mais adequando utilizar uma defasagem de três períodos na reposição uma vez que só na decisão
de produção do próximo período é que o novo equipamento será utilizado*/



if(!strcmp(label, "CQ") )
{
/*Produção acumulada num bem de capital.calculado no meio do período*/
v[0]=p->cal("Q",0);
v[2]=p->cal("CQ",1);
v[1]=p->cal("DataNasc",0);
if(v[1]==(double)t)
res=0;
else
res=v[2]+v[0];/*caso contrário sua produção acumulada é a produção corrente(Q) + a produção acumulada anterior*/
goto end;
}

if(!strcmp(label, "SKILL") )
{
v[1]=p->cal("BONUS",0);/*determina o limite assintótico do skill(em termos percentuais - porcentagem da produtividade inicial), quanto ele vai atingir quando a produção acumulada crescer muito*/
v[2]=p->cal("V_SKILL",0);/*taxa a que cresce o skill em função da produção acumulada*/ 
v[3]=p->cal("CQ",1);/*produção acumulada*/
res=1+v[1]*(1-exp(-v[2]*v[3]));
 goto end;
}

if(!strcmp(label, "A_BK") )
{
v[0]=p->cal("a_bk",0);//a_bk é atualizado ao fim do período em CP
v[1]=p->cal("SKILL",0);
v[2]=p->cal("DataNasc",0);
if((double)t==v[2])
res=v[0];
else
res=v[0]*v[1]; 
goto end;
}

if(!strcmp(label, "reposicao") )
{
p->cal("REPO2",0);
v[0]=p->cal("reposicao_P",0);
res=v[0];
goto end;
}




/********** Outras Variáveis importantes **************/

if(!strcmp(label, "AVG_PROD") )
{
    v[4]=p->cal("EFPR",0);
    v[3]=p->cal("AVG_PROD",1);
   for(v[0]=0,v[5]=0,cur=p->search("B_K"); cur!=NULL; cur=go_brother(cur) )
    {
v[1]=cur->cal("A_BK",0);
v[2]=cur->cal("Q",0);
v[0]=v[0]+(v[1])*v[2];
v[5]=v[5]+v[2];
   }
   if(v[5]!=0)
   {
     res=v[0]/v[5];
   }
   else
   {
  res=v[3];
   plog("\nERROR: soma Q igual a zero ver A_MEDIO");
   }
  goto end;
}

if(!strcmp(label,"AVG_PROD_SET"))
{
/*
Average sector productivity
*/
v[0]=p->whg_av("AVG_PROD", "MS", 0); 
res=v[0];
goto end;
}



if(!strcmp(label, "CP_REP") )
{
p->cal("CP",0); 
v[0]=p->cal("CP_REP_P",0);
res=v[0];
 goto end;
}

if(!strcmp(label, "cp_depre") )
{
//quantidade de capacidade produtiva depreciada

p->cal("CP_apendix",0);
v[0]=p->cal("cp_depre_P",0);
res=v[0];
   goto end;
}

if(!strcmp(label, "A_BK_MAX"))/*estou reestruturando o código. ver cabeçalho*/
{
    p->stat("A_BK", v);
    res=v[3];
  goto end;
}

if(!strcmp(label, "a_bk_MAX"))/*estou reestruturando o código. ver cabeçalho*/
{
p->cal("IdA2",0);/* a única função é garantir que IdA2 seja calculada antes de A_BK_MAX */
p->stat("a_bk", v);
res=v[3];
goto end;
}

if(!strcmp(label, "Sum_IdA3") )
{
p->cal("DELTACP",0);
v[0]=p->cal("IdA3",0);
v[1]=p->cal("Sum_IdA3",1);
res=v[1]+v[0];
goto end;
}

if(!strcmp(label, "Sum_IdA2") )
{
p->cal("REPO2",0);
v[0]=p->cal("IdA2",0);
v[1]=p->cal("Sum_IdA2",1);
res=v[1]+v[0];
goto end;
}

if(!strcmp(label, "REPO") )
{
   v[0]=p->sum("reposicao",0);
   res=v[0];
   goto end;
}

if(!strcmp(label, "REPO_TOT") )
{
   res=p->sum("REPO",0);

   goto end;
}


/************************************* NEW FINANCIAL RESTRICTION ***************************/

EQUATION("FUNDS")
/*
a hipótese implícita envolvida no mecanismo abaixo é de que a restrição não é 
negativa em geral devido a necessidades de liquidez(pelo menos não preponderantemente)
Por isso toda vez que tenho problemas atribuo ou a prejuízos ou a dívida em excesso e recorro
ao caixa de ativos líquidos para sanar esses problemas.(amortecendo o impacto de prejuízos sobre
o endividamento ou contribuindo junto com o fluxo de caixa corrente para reduzir dívidas)
PROBLEMA PARA RESOLVER:DÍVIDA ESTÁ FICANDO NEGATIVA!!!!!!!!18/05/00
*/

v[1]=p->cal("Int_Fin",0);
v[2]=p->cal("POOL_AF",0);
v[3]=p->cal("POOL_D",0);
v[6]=p->cal("DEBT",1);
v[5]=p->cal("APLIC_FIN",1);
v[7]=max(v[1],-v[5]);// só será usado se v[1]<=0 e v[5]>0,portanto sempre <0
v[8]=p->cal("RETURN_RATE",0);
v[9]=p->cal("INTERESTS_RATE_firm",0);
   if(v[1]-v[2]+v[3]>0) //tenho recursos para investir
   {
   p->write("aplic_fin1",0,0);/**/
   p->write("divida1",0,0);
   } 
   else  /*não existem recursos suficientes para manter as metas de liquidez e endividamento no 
   atual período. Ver situação 1 em GASTO_INV1*/
   {
      if(v[5]+v[1]<0 ||(v[9]>v[8] && v[6]-v[5]-v[1]>=0)) /*se existirem recursos financeiros excedentes, ele será usado para reduzir dívidas*/
      {/*possível problema: a utilização dos recursos financeiros for mais do que necessária para zerar as dívidas*/
       p->write("aplic_fin1",-v[5],0); /*fluxo negativo de aplicação financeira:firma fica sem recursos líquidos*/
       p->write("divida1",-v[5]-v[1],0); /*dívidas se reduzem em v[5], impacto do lucro depende do sinal de v[1]:prejuízos aumentam a dívida*/
      }
      else //v[5]+v[1]>=0 && (v[9]<=v[8]||v[6]-v[5]-v[1]<0)
      {
      p->write("aplic_fin1",v[1],0);
      p->write("divida1",0,0);
      }
   /*observe que em ambos os caso, sendo o lucro positivo ou negativo ele vai influenciar a dívida*/
   }   

RESULT(v[1]-v[2]+v[3])


if(!strcmp(label,"Int_Fin"))
{
/*
Comment
*/
v[0]=p->cal("retained_profit",0);
v[1]=p->cal("Depre_Expenses",0);
res=v[0]+v[1];
goto end;
}

if(!strcmp(label, "POOL_AF") )
{
/*
Minimum liquid fianancial aplication in order to keep the desired amount, if the amount is already larger than desired the excess will be avilable for investment expenses.
taxa de liquidez estipulada : determinada pela 
"expectativa quanto à extensão dos déficits futuros a curto prazo da conta de captital em relação
a disponibilidade de facilidade de obtenção de crédito a curto prazo"(A. Wood p.)
*/

v[0]=p->cal("CAPITAL",1);
v[1]=p->cal("TX_APLIC_DES",0);
v[2]=p->cal("APLIC_FIN",1);/*valor corrente do estoque inicial de ativos financeiros*/
    if(v[1]*v[0]-v[2]>=0)//Se for menor do que é desejado 
    v[3]=(1/4)*((v[1]*v[0])-v[2]);//positive value
    else 
    v[3]=v[1]*(v[0])-v[2];// negative value (reduce liquid assets) increasing available funds.
res=v[3];
goto end;
}



if(!strcmp(label, "POOL_D") )
{
/*Maximum External funds available */
v[0]=p->cal("CAPITAL",1);
v[1]=p->cal("DES_DEBT_RATE", 0);
v[2]=p->cal("DEBT",1);
v[3]=p->cal("APLIC_FIN",1);
if(v[1]*(v[0]+v[3])-v[2]<=0)//If Debt is higher than desired the adjustment is done gradually (1/4) towards the target. 
v[4]=(1/4)*(v[1]*(v[0])-v[2]);//negative value (try to pay part of the debt)
else
v[4]=v[1]*(v[0]+v[3])-v[2];//positive value (increase debt)

res=v[4];
goto end;
}

if(!strcmp(label, "DEBT") )
{
/*DEBT STOCK*/
v[0]=p->cal("divida",0);
v[1]=p->cal("DEBT",1);
v[2]=v[1]+v[0];
v[16]=p->cal("Switch_debt",0);
if(v[16]==0)
{
v[14]=p->cal("Id2",0);
v[15]= fmod((double) t,6); //reposição também só ocorre nos períodos de investimento.
  if(v[14]==v[15]+1||v[14]==(v[15]+7)||v[14]==(v[15]+13)||v[14]==(v[15]+19))
	{
	v[3]=p->cal("CAPITAL",1);
	v[4]=p->cal("APLIC_FIN",1);
	v[5]=p->cal("DES_DEBT_RATE_2",0);
	v[6]=v[2]/(v[3]+v[4]);
      if(v[6]<=v[5])
      {
         if(v[2]>=0)
         res=v[2];
         else
         {
         res=0;
         plog("\nERROR: DEBT lower than 0");
         }
      }
      else
      {
      plog("\nERROR: DEBT_RATE greater than desiered 2");
         v[11]=p->cal("CP",0);
         v[7]=v[5]*(v[3]+v[4]);// Desiered Debt level 
         v[8]=p->cal("PRICE_BK",0);
         
         v[9]=p->cal("Desagio",0);
         p->lsdqsort("B_K","A_BK","UP");
         
           for(v[10]=0, cur=p->search("B_K"); cur!=NULL; cur=go_brother(cur) )
           {
              if((v[2]-v[10])>=v[7])
              {
              cur->write("to_die_BK",1, 0);
              v[10]=v[10]+v[8]*(1-v[9]);
              }
              else
              {
              cur->write("to_die_BK",0, 0);
              v[10]=v[10];
              }
           }
                
        res=v[2]-v[10];
      }
  }
  else
  res=v[2];
}
else
res=v[2];
goto end;
}


if(!strcmp(label, "APLIC_FIN") )
{
/*valor corrente do estoque de ativos financeiros*/
v[0]=p->cal("aplic_fin",0);
v[1]=p->cal("rest",0);
v[2]=p->cal("APLIC_FIN",1);
res=v[0]+v[1]+v[2];
goto end;

}

if(!strcmp(label, "INV_EXPENSES1") )
{
v[0]=p->cal("DES_INV_EXPENSES",0);
v[1]=p->cal("FUNDS", 0);
   if(v[1]<=0)/*1*/
   //não existem recursos suficientes para manter as metas de liquidez e endividamento no 
   //atual período.Logo também não tenho recursos para investir em expansão ou reposição
   {   
   p->write("RECUR_REPO_P",0,0);
   res=0;
   }  
   else 
   {
      if(v[1]-v[0]>=0) /*2*/
      //existem recursos para investimento e eles são suficientes para a expansão desejada
      {
      p->write("RECUR_REPO_P",v[1]-v[0],0); 
      res=v[0];
      }
      else /*3*/
      //existem recursos para investimento mas eles não são suficientes para a expansão desejada.
      //Logo não existem recursos para reposição pois assumimos que a prioridade é a expansão.
      {
      p->write("RECUR_REPO_P",0,0);
      res=0;
      }
   }
  goto end;
} 

if(!strcmp(label, "INV_EXPENSES2") )
{

   v[0]=p->cal("INV_EXPENSES1", 0);
   v[1]=p->cal("DES_INV_EXPENSES",0);
   v[2]=p->cal("FUNDS",0);
   v[3]=p->cal("POOL_D",0);
   v[4]=p->cal("POOL_AF",0);
   
if(v[0]==0 && v[1]>0)
/*ou seja não aconteceu( 2 acima) v[1]-v[0]>=0 na variável acima.Existem duas
possibilidades para explicar o que aconteceu:a restrição financeira é negativa ou desejado maior que ela*/
{
   if(v[2]<=0)/* aconteceu 1 acima. Nesse caso GASTO_INV=0+0 */
   {
    p->write("aplic_fin2",0,0);
    p->write("divida2",0,0);
    res=0;  
   }
   else /* aconteceu 3 acima: v[1]-v[0] < 0 */
   {
   /*nesse caso aplicamos a restrição financeira e o valor virtual dos fluxos financeiros passa a
    ser o valor  efetivo.Nesse caso GASTO_INV=0+GASTO_INV2*/
   res=v[2];
   p->write("aplic_fin2",v[4],0);
   p->write("divida2",v[3],0);
   }
} 
else 
/*aconteceu 2 acima:existem recursos para investimento e eles são suficientes para a expansão 
desejada.Nesse caso GASTO_INV=GASTO_INV1+0. O valor dos fluxos financeiros tem que esperar
a decisão de reposição */
{
    p->write("aplic_fin2",0,0);/**/
    p->write("divida2",0,0);
    res=0; 
}
 
 goto end;
}

if(!strcmp(label, "RECUR_REPO") )
{
    p->cal("INV_EXPENSES1", 0);
    v[0]=p->cal("RECUR_REPO_P", 0);
    res=v[0];
  goto end;
}



if(!strcmp(label, "REPO2") )
{

/* 
REPOSIÇÃO: GASTO REALIZADO PELA FIRMA NA AQUISIÇÃO DE NOVOS EQUIPAMENTOS DESTINADOS A REPOR
EQUIPAMENTOS CONSIDERADOS OBSOLETOS, PELA REGRA DE PAYBACK
*/

p->cal("CP", 0);
p->cal("INV_EXPENSES1", 0);
v[0]=p->cal("RECUR_REPO_rest", 0);
v[2]=p->cal("POOL_AF",0);
v[3]=p->cal("POOL_D",0);
v[4]=p->cal("DES_INV_EXPENSES",0);
v[5]=p->cal("FUNDS", 0);     
v[6]=p->cal("DEBT",1);
v[7]=p->cal("DEPRE",0);
v[8]=p->cal("PAYBACK", 0);
v[9]=p->cal("PROD", 0);/*PRODUTIVIDADE NA FRONTEIRA TECNOLÓGICA DA FIRMA*/
v[10]=p->cal("WAGE", 0);/*SALÁRIO médio NOMINAL*/
v[11]=p->cal("PRICE_BK",0);
cur1=p->search_var_cond("Id3",2,0);
v[24]=cur1->cal("B",0);
v[12]=p->cal("A_BK_MAX", 0);
v[31]=p->cal("BONUS",0);
v[32]=p->cal("Antecipation",0);
v[13]=max(v[9]*(1+v[32]*v[31]),v[12]);



v[14]=p->cal("Id2",0);
v[15]= fmod((double) t,6); //reposição também só ocorre nos períodos de investimento.
  if(v[14]==v[15]||v[14]==(v[15]+6)||v[14]==(v[15]+12)||v[14]==(v[15]+18))
  {
  v[16]=0;
  v[21]=v[0];
  p->lsdqsort("B_K","A_BK","UP");  
   for(cur=p->search("B_K"); cur!=NULL; cur=go_brother(cur) )
   {
      v[19]=cur->cal("DataNasc",0);
     /*aplicação da regra de payback para decidir equipamento que deve ser sucateado*/
     if((double)t!=v[19])
     {
     v[17]=cur->cal("A_BK",0);//Current Productivity of the capital good
     v[18]=cur->cal("CP_BK",0);//productive capacity that must be replaced if the capital good is scrapped
     v[20]=v[18]*v[24]*v[11];/*New BK price*/
     v[21]=v[0]-v[16];/*Quando o ciclo se encerrar: recursos que permanecem disponíveis após a decisão de sucateamento*/
         if(v[13]>v[17])
         { 
         v[22]=(1/(v[17]))-(1/(v[13]));//For sure is greater than zero.
         v[23]=v[11]/(v[10]*v[22]); 
         }
         else
         {
         v[22]=0;
         v[23]=0;
         }
         
       
      cur->write("pay_teste",v[22],0);
      cur->write("pay_teste2",v[23],0);
   
         if(v[22]!=0 && v[20]<=v[21]&& v[23]<=v[8]  && (double)t < v[7]+v[19]-6)
         {
         cur->write("IdA2",1,0);
         v[16]=v[16]+v[20];
         cur->write("reposicao_P",v[18],0);         
         }
         else
         {
         cur->write("reposicao_P",0,0);
         v[16]=v[16];
         }
      }
      else
      {
      cur->write("IdA2",0,0);
      cur->write("reposicao_P",0,0);
      }   
   }
  }
  else
  {
  v[16]=v[0];      
  v[21]=v[0];  
  }
   /*END OF THE CYCLE*/
     
  if(v[0]>0)//if there were resources for modernization 
  {
  if(v[14]==v[15]||v[14]==(v[15]+6)||v[14]==(v[15]+12)||v[14]==(v[15]+18))
  v[1]=v[21];// what is left after pay-back period calculus
  else
  v[1]=v[0];//It was not an investment period, therefore the extra amount was not expended

  /*
  dada a prioridade de usar recursos internos, duas
  situações são relevantes se a firma está acima ou abaixo do limite de endividamento.
  NO primeiro caso os recursos externos só seram usados na medida em que sejam necessários
  para complementar os recursos internos. No segundo caso a firma vai usar os recursos disponíveis 
  para reduzir o máximo possível sua dívida.
  */  
    
    
    if(v[3]>=0)//May increase debt
     {
       if(v[1]>=v[3])/*v[1] is the available resources after replacement*/
       {
         v[25]=0;//there is no increase in the debt.
         v[26]=v[2]+(v[1]-v[3]);//se o excedente foi positivo v[2] está assegurado.
       // ou seja o excedente é liquido da necessidade de liquidez. 
       }
       else
       {
         v[25]=v[3]-v[1];/*A PRIORIDADE É NÃO SE ENDIVIDAR*/
         v[26]=v[2];/*APLICAÇÃO FINANCEIRA ESTÁ GARANTIDA*/
       }
    
     }
    else //v[3]<0
    {
     if(v[6]+v[3]-v[1]>=0)// antes era v[6]-v[3]-v[1]>=0 11/08/03
      {
      v[25]=v[3]-v[1];
      v[26]=v[2];
      }
      else
      {
     v[25]=-v[6];
     v[26]=v[2]+v[1]-v[3]-v[6];//antes era v[2]+v[1]+v[3]-v[6] 11/08/03
     } 
    } 
    p->write("aplic_fin3",v[26],0);
    p->write("divida3",v[25],0);
   	}
	else //v[0]<=0
	{
 	p->write("aplic_fin3",0,0);
 	p->write("divida3",0,0);
	}

	if(v[14]==v[15]||v[14]==(v[15]+6)||v[14]==(v[15]+12)||v[14]==(v[15]+18))
	{
	res=v[16];
	}
	else
	{
	res=0;
	}
goto end;
}


if(!strcmp(label, "INV_EXPENSES") )
{

v[0]=p->cal("INV_EXPENSES1", 0);
v[1]=p->cal("INV_EXPENSES2", 0);
res=v[0]+v[1];
goto end;
}

if(!strcmp(label, "TOT_INV_EXPENSES") )
{
/*Sector Variable - delete firms*/
  p->cal("AVG_PROD_SET",0);
  for(v[2]=0,v[3]=0,v[5]=0,cur=p->search("Firm"); cur!=NULL; )
  {
     v[0]=cur->cal("CP",0);
     v[1]=cur->cal("MS",0);
     v[6]=cur->cal("EF_MS",1);
     if(v[1]<=0.001||v[0]<=1)
     {
      v[2]=v[2];
      v[3]=v[3]+v[0];
      v[5]=v[5]+v[6];
      plog("\nFirm Deleted - MS small");
      cur1=go_brother(cur); //record the next object
      cur->delete_obj(); //kill the current object
      cur=cur1; //continue the cycle
     }
     else
     {
     v[10]=cur->cal("DEBT_RATE",0);
     v[11]=cur->cal("DEBT_RATE",1);
     v[12]=cur->cal("DEBT_RATE",2);
     v[13]=cur->cal("DEBT_RATE",3);
     v[14]=cur->cal("DEBT_RATE",4);
     v[15]=cur->cal("DEBT_RATE",5);
     v[16]=cur->cal("DEBT_RATE",6);
     v[4]=(v[10]+v[11]+v[12]+v[13]+v[14]+v[15]+v[16])/7;
        if(v[4]>1&&(v[10]-v[11])>0&&v[11]-v[12]>0)
        {
        v[2]=v[2]+1;
        v[3]=v[3]+v[0];
        v[5]=v[5]+v[6];
        plog("\nFirm Deleted - High Debt");
        cur1=go_brother(cur); //record the next object
        cur->delete_obj(); //kill the current object
        cur=cur1; //continue the cycle
        }
        else
        {
        v[2]=v[2];
        v[3]=v[3];
        v[5]=v[5];
        cur=go_brother(cur); //next object to control
        }
     }
  }
  
 p->write("Num_ExitP",v[2], 0);
 p->write("CP_ExitP",v[3], 0);
 p->write("EF_MS_ExitP",v[5], 0);
  
 res=p->sum("INV_EXPENSES",0);
   goto end;
}


if(!strcmp(label,"Num_Exit"))
{
/*
Sector_Variable
*/

p->cal("TOT_INV_EXPENSES",0);
v[0]=p->cal("Num_ExitP",0);
v[1]=p->cal("Num_ExitP_2",0);
v[2]=p->cal("Num_Exit",1);
res=v[2]+v[0]+v[1];
goto end;
}

if(!strcmp(label,"Num_Entry"))
{
/*
Sector_Variable
*/
v[0]=p->cal("To_Entry",0);
v[1]=p->cal("Num_Entry",1);
res=v[0]+v[1];
goto end;
}

EQUATION("To_Entry")
/*
Comment
*/
v[14]=p->cal("Id1",0);
v[15]= fmod((double) t,6); //reposição também só ocorre nos períodos de investimento.
  if(v[14]==v[15]||v[14]==(v[15]+6)||v[14]==(v[15]+12))
  {
  v[2]=VL("EFOR_Sector",1);
  v[3]=VL("EFOR_Sector",2);
  v[4]=VL("EFOR_Sector",3);
  v[5]=VL("EFOR_Sector",8);
  v[6]=v[2]-v[5];
  v[7]=(v[2]-v[3])/v[3];
  v[8]=(v[3]-v[4])/v[4];
  
     
     if(v[6]>0&&v[7]>0&&v[8]>0)
     {
     v[9]=V("Num_Exit");
     v[10]=VL("Num_Entry",1);
     v[11]=v[9]-v[10];
     }
     else
     v[11]=0;
     
     if(v[11]>0)
     v[12]=1;
     else
     v[12]=0;
  }
  else
  v[12]=0;
   
RESULT(v[12])

if(!strcmp(label,"EF_MS_Exit"))
{
/*
Sector_Variable
*/
p->cal("TOT_INV_EXPENSES",0);
v[0]=p->cal("EF_MS_ExitP",0);
v[1]=p->cal("EF_MS_ExitP_2",0);
p->write("EF_MS_ExitP",0, 0);
p->write("EF_MS_ExitP_2",0, 0);
res=v[0]+v[1];
goto end;
}



if(!strcmp(label,"CP_Exit"))
{
/*
Sector_Variable
*/
p->cal("TOT_INV_EXPENSES",0);
v[0]=p->cal("CP_ExitP",0);
v[1]=p->cal("CP_ExitP_2",0);
p->write("CP_ExitP",0, 0);
p->write("CP_ExitP_2",0, 0);
v[2]=p->cal("CP_Exit",1);
res=v[0]+v[1]+v[2];
goto end;
}

if(!strcmp(label,"CP_To_Entry"))
{
/*
Sector_Variable
*/
v[14]=p->cal("Id1",0);
v[15]= fmod((double) t,6); //reposição também só ocorre nos períodos de investimento.
  if(v[14]==v[15]||v[14]==(v[15]+6)||v[14]==(v[15]+12))
  {
  v[0]=V("Num_Exit");
  v[1]=VL("Num_Entry",1);
  v[2]=p->cal("To_Entry",0);
  v[3]=p->cal("CP_Exit",0);
  v[4]=p->cal("CP_Entry",1);
  v[5]=v[0]-v[1];//Number of firms that wil eventually enter
  v[6]=v[3]-v[4];//Productive capacity lost
     if(v[5]>0)
     v[7]=(v[6]/v[5])*v[2];
     else
     v[7]=0;
  }
  else
  v[7]=0;
  
  res=v[7];
goto end;
}

if(!strcmp(label,"CP_Entry"))
{
/*
Sector_Variable
*/
v[0]=p->cal("CP_Entry",1);
v[1]= fmod((double) t,6);
v[2]=p->cal("Id1",0);
  if(v[2]==v[1]||v[2]==(v[1]+6)||v[2]==(v[1]+12))
  {
  v[3]=V("CP_To_Entry");
  v[4]=v[3]+v[0];
  }
  else
  v[4]=v[0];
  
res=v[4];
goto end;
}


if(!strcmp(label,"TOT_SECTOR_INVESTMENT"))
{
/*
Does not make sense once we change the investment decision period.
*/
v[0]=p->cal("Id1",0);
v[1]= fmod((double) t,6); //armazena em v[1] o resto da divisao de t(período corrente) por 6. reposição também só ocorre nos períodos de investimento: só tenho recursos para reposição de 6 em 6.
  if(v[0]==v[1]||v[0]==(v[1]+6)||v[0]==(v[1]+12))
  {
  v[2]=p->cal("REPO_TOT",0);
  v[3]=p->sum("CP_DEM",0);
  v[4]=v[2]+v[3];
  }
	else
	v[4]=p->cal("TOT_SECTOR_INVESTMENT",1);
res=v[4];
goto end;
}

if(!strcmp(label, "aplic_fin") )
{
p->cal("FUNDS", 0);
p->cal("INV_EXPENSES2", 0);
p->cal("REPO2", 0);
v[0]=p->cal("aplic_fin1", 0);
v[1]=p->cal("aplic_fin2", 0);
v[2]=p->cal("aplic_fin3", 0);
res=v[0]+v[1]+v[2];
goto end;
}

if(!strcmp(label, "divida") )
{
p->cal("FUNDS", 0);
p->cal("INV_EXPENSES2", 0);
p->cal("REPO2", 0);
v[0]=p->cal("divida1", 0);
v[1]=p->cal("divida2", 0);
v[2]=p->cal("divida3", 0);
res=v[0]+v[1]+v[2];
goto end;
}

if(!strcmp(label,"Entry"))
{
/*
Sector_Variable
*/
v[0]=p->cal("Entry_P",0);
  if(v[0]==1)
  {
   p->cal("SumMS",0);
   v[1]=p->cal("To_Entry",0);
      if(v[1]>0)
      {
      v[20]=p->cal("EFOR_Sector",0);
      v[32]=p->cal("RIM_Sector",0);
      v[33]=v[32]/2;
      v[34]=p->cal("CP_To_Entry",0);
      v[36]=p->cal("Avg_PRICE",0);
      v[38]=p->cal("DEPRE",0);
      v[39]=p->cal("AVG_PROD_SET",0);
      
      v[41]=p->cal("Switch_Id2",0);
      if(v[41]==1)
      v[42]=rnd_integer(1, 6);
      else
      v[42]=p->cal("Id1",0);
      
      v[4]=(double) t;
           for(v[5]=0,v[6]=0,cur3=p->search("Firm"); cur3!=NULL; cur3=go_brother(cur3) )
           {
           v[5]=v[5]+1;
           v[7]=cur3->cal("MS",0);
           v[6]=v[6]+v[7];
           }
      v[8]=v[6]/v[5];
      //cur=cur1->search_var_cond("MS",v[2],0);// Is used if I want to copy the best imitator
      //The next cycle is to discover the firm that is closer to the average market-share
           for(v[10]=1,v[12]=0,cur4=p->search("Firm"); cur4!=NULL; cur4=go_brother(cur4) )
           {
           v[9]=cur4->cal("MS",0);
           v[11]=abs(v[9]-v[8]);
           v[10]=min(v[11],v[10]);
               if(v[11]==v[10])
               v[12]=v[9];
               else
               v[12]=v[12];
           }
      		   v[25]=round(v[34]/v[1])+1;//CP of each entrant, in order to keep the same sector productive capacity
             for(v[15]=v[1],v[14]=0,v[31]=1; v[15]>0; v[15]=v[14] )
             {
              plog("\nFirm Created");
              v[14]=v[15]-1;
              cur=p->search_var_cond("MS",v[12],0);// Copy the average firm
              v[22]=cur->cal("ALFA",0);
              v[23]=cur->cal("SIGMA",0);
              v[35]=(v[22]*v[25])/v[20];//New MS
              cur=ADDOBJ_EX("Firm",cur);
//              cur=p->add_an_object("Firm",cur);
              cur->write("DataNasc_firm",v[4],0);
              cur->write("Id2",v[42],0);
              cur->write("MS",v[35],v[4]);
              cur->write("DEBT",0.2*1.33*v[25],v[4]);
              cur->write("APLIC_FIN",0.33*v[25],v[4]);
              cur->write("MS",v[35],v[4]);
              cur->write("EF_MS",v[35],v[4]);
              cur->write("MS_DES",v[35],v[4]);
              cur->write("MS_MED",v[35],v[4]);
              cur->write("EFOR",v[25]*v[22],v[4]);
              cur->write("STOCK",v[25]*v[22]*v[23],v[4]);
              cur->write("PRICE",v[36],v[4]);
              cur->write("A_BK_MAX",v[39],v[4]);
              cur->write("PROD",v[39],v[4]);
                   if(v[31]==1)
                   {
                   cur->write("Inn",1,0);
                   cur->write("RIN",v[33],0);
                   cur->write("RIM",v[32],0);
                   v[31]=v[31]-1;
                   }
                   else
                   {
                   v[31]=v[31]+1;
                   cur->write("Inn",0,0);
                   cur->write("RIN",0,0);
                   cur->write("RIM",v[32],0);
                   }
              										for(v[26]=0,v[37]=0,cur1=cur->search("B_K"); cur1!=NULL;)
                        {
                           v[26]=v[26]+1;
                             if(v[26]<=v[25])
                             {
                             cur1->write("to_die_BK",0,0);
                             cur1->write("DataNasc",v[4]-v[37],0);
                             cur1->write("IdA2",0,0);
                             cur1->write("a_bk",v[39],0);
                             cur1->write("reposicao_P",0,0);
                             cur1->write("Sum_IdA2",0,v[4]);
                             cur1->write("CQ",0,v[4]);
                             cur1->write("pay_teste",0,0);
                             cur1->write("pay_teste2",0,0);
                             cur1=go_brother(cur1);
                             v[37]=v[37]+6;
                             }
                             else
                             {
                             cur2=go_brother(cur1);
                             cur1->delete_obj(); //kill the current object
                             cur1=cur2;
                             v[37]=v[37];
                             }
                                if(v[37]>=v[38])
                                v[37]=0;
                                else
                                v[37]=v[37];
                         }
                  
                  
                        if(v[26]<v[25])//if there are less B_K than should have
                        {
                         plog("\nAdded B_K");
                         
                            v[27]=v[25]-v[26];
                                 for(v[37]=0,v[28]=v[27],v[29]=0; v[28]>0; v[28]=v[29],v[37]=v[40])
                            					{
                                 cur2=cur->search("B_K");// Copy the average firm
                              	 cur2=ADDOBJS_EX(cur,"B_K",cur2);		
                                 //cur2=cur->add_an_object("B_K",cur2);
                              			cur2->write("DataNasc",v[4]-v[37],0);
                                 cur2->write("a_bk",v[39],0);
                                 cur2->write("Sum_IdA2",0,v[4]);
                                 cur2->write("IdA2",0,0);
                                 cur2->write("to_die_BK",0,0);
                                 cur2->write("reposicao_P",0,0);
                                 cur2->write("CQ",0,v[4]);
                                 cur2->write("pay_teste",0,0);
                                 cur2->write("pay_teste2",0,0);
                                 v[29]=v[28]-1;
                                 v[37]=v[37]+6;
                                    if(v[37]>=v[38])
                                    v[40]=0;
                                    else
                                    v[40]=v[37];          
                             				}
                             
                        }
                  } //fim do ciclo se há quatro ou mais entrantes
               //}//fim do else se há quatro ou mais entrantes
            p->write("Num_ExitP",0, 0);
            res=v[1];
       }//fim do se há entrada
       
       else//Num_Entry=0
       res=0;
  }//fim do Se o modelo inclui entrada
  else //modelo não inclui entrada
  res=0;

goto end;
}

EQUATION("P_F")
/*
Pode ser endógeno ou exógeno. Em geral, para os setores de bens intermediários a taxa de crescimento é exógena, para os setores em que há inovação de produto é endoógena. O Parametro "Price_Comp" determina se há ganhos (perdas) de competitividade via preço para estes setores se o parâmetro for maior (menor) do que 1.   
*/
v[1]=VL("P_F",1);
v[2]= fmod((double) t,4);
v[4]=V("P_F_rate");
   if(v[4]!=0)
   {
      if(v[2]==0)
      v[3]=(1+v[4])*v[1];
      else
      v[3]=v[1];
   }
   else
   {     
   v[5]=VL("Avg_PRICE",2);
   v[6]=VL("Avg_PRICE",1);
   v[7]=VL("Price_Comp",0);
   v[3]=v[1]*(1+v[7]*((v[6]-v[5])/v[5]));
   }
   
RESULT(v[3])

   


/************************************* Some Variables for Analyses ************************************/



if(!strcmp(label, "INV_INDUZIDO") )
{
v[0]= fmod((double) t,6);
for(v[1]=0,v[2]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 {
 v[5]=cur->cal("Id2", 0);
     for(v[11]=0,v[12]=0,cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
    {
    cur2=cur1->search_var_cond("Id3",2, 0);
    v[3]=cur2->cal("B",0);

        	if(v[5]==(v[0]-1)||v[5]==(v[0]+5)||v[5]==(v[0]+11)||v[5]==(v[0]+17))
        	{
        	v[6]=cur1->cal("REPO",1);
        	v[7]=cur1->cal("CP_Dem_quality",1); 
        	v[8]=cur1->cal("CP_DEM", 1);//inclui investimento autonomo
         v[9]=cur1->cal("DELTACP", 1);
         v[10]=((v[8]-v[9])+v[6]+v[7])/6;
         }
        	if(v[5]==(v[0]-2)||v[5]==(v[0]+4)||v[5]==(v[0]+10)||v[5]==(v[0]+16))
        	{
        	v[6]=cur1->cal("REPO",2);
        	v[7]=cur1->cal("CP_Dem_quality",2); 
        	v[8]=cur1->cal("CP_DEM", 2);//inclui investimento autonomo
         v[9]=cur1->cal("DELTACP", 2);
         v[10]=((v[8]-v[9])+v[6]+v[7])/6;
        	}
        	if(v[5]==(v[0]-3)||v[5]==(v[0]+3)||v[5]==(v[0]+9)||v[5]==(v[0]+15))
        	{
        	v[6]=cur1->cal("REPO",3);
        	v[7]=cur1->cal("CP_Dem_quality",3); 
        	v[8]=cur1->cal("CP_DEM", 3);//inclui investimento autonomo
         v[9]=cur1->cal("DELTACP", 3);
         v[10]=((v[8]-v[9])+v[6]+v[7])/6;
        	}
        	if(v[5]==(v[0]-4)||v[5]==(v[0]+2)||v[5]==(v[0]+8)||v[5]==(v[0]+14))
        	{
        	v[6]=cur1->cal("REPO",4);
        	v[7]=cur1->cal("CP_Dem_quality",4); 
        	v[8]=cur1->cal("CP_DEM", 4);//inclui investimento autonomo
         v[9]=cur1->cal("DELTACP", 4);
         v[10]=((v[8]-v[9])+v[6]+v[7])/6;
        	}
        	if(v[5]==(v[0]-5)||v[5]==(v[0]+1)||v[5]==(v[0]+7)||v[5]==(v[0]+13))
        	{
        	v[6]=cur1->cal("REPO",5);
        	v[7]=cur1->cal("CP_Dem_quality",5); 
        	v[8]=cur1->cal("CP_DEM", 5);//inclui investimento autonomo
         v[9]=cur1->cal("DELTACP", 5);
         v[10]=((v[8]-v[9])+v[6]+v[7])/6;
        	}
        	if(v[5]==v[0]||v[5]==(v[0]+6)||v[5]==(v[0]+12)||v[5]==(v[0]+18))
        	{
        	v[6]=cur1->cal("REPO",6);
        	v[7]=cur1->cal("CP_Dem_quality",6); 
        	v[8]=cur1->cal("CP_DEM", 6);//inclui investimento autonomo
         v[9]=cur1->cal("DELTACP", 6);
         v[10]=((v[8]-v[9])+v[6]+v[7])/6;
        	}
    v[11]=v[11]+v[9]*v[3]/6;//induzido setor
    v[12]=v[12]+v[10]*v[3];//autônomo setor
    }
  cur->write("I_ind_sector_P",v[11], 0);
  cur->write("I_aut_sector_P",v[12], 0);
  v[1]=v[1]+v[11];//induzido macro
  v[2]=v[2]+v[12];//autônomo macro 
 }
p->write("I_aut_P",v[2], 0);
res=v[1];
goto end;
}

if(!strcmp(label,"INV_AUTONOMO"))
{

p->cal("INV_INDUZIDO",0);
v[0]=p->cal("I_aut_P",0);
res=v[0];
goto end;
}

if(!strcmp(label,"I_ind_sector"))
{
/*
Comment
*/
p->cal("INV_INDUZIDO",0);
v[0]=p->cal("I_ind_sector_P",0);
res=v[0];
goto end;
}

if(!strcmp(label,"I_aut_sector"))
{
/*
Comment
*/
p->cal("INV_INDUZIDO",0);
v[0]=p->cal("I_aut_sector_P",0);
res=v[0];
goto end;
}

if(!strcmp(label,"GASTOS_CLASS_A"))
{
/*
Gastos de Cada Classe
*/
 v[0]=p->cal("CLASS_A", 1);
 v[1]=p->cal("CLASS_A", 2);
 v[2]=p->cal("CLASS_A", 3);
 v[3]=p->cal("CLASS_A", 4);
 v[4]=(v[0]+v[1]+v[2]+v[3])/4;
 v[5]=p->cal("CLASS_B", 1);
 v[6]=p->cal("CLASS_B", 2);
 v[7]=p->cal("CLASS_B", 3);
 v[8]=(v[5]+v[6]+v[7])/3;
 v[9]=p->cal("CLASS_C", 1);
 v[10]=p->cal("CLASS_C", 2);
 v[11]=(v[9]+v[10])/2;
 v[12]=p->cal("CLASS_D", 1);
 v[25]=p->cal("EXCHANGE_RATE",0);
 
 	for(v[13]=0,v[14]=0,v[15]=0,v[16]=0,v[34]=0,v[35]=0,v[36]=0,v[37]=0, cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 	{
		v[17]=cur->cal("P_A",0);
		v[18]=cur->cal("M_A",0);
		v[19]=cur->cal("P_B",0);
		v[20]=cur->cal("M_B",0);
		v[21]=cur->cal("P_C",0);
		v[22]=cur->cal("M_C",0);
		v[23]=cur->cal("P_D",0);
		v[24]=cur->cal("M_D",0);
		v[26]=cur->cal("P_F",0);
   		v[27]=cur->cal("Dem_atend",0);
   	 v[28]=cur->cal("Dem_atend_M",0);
   		v[29]=cur->cal("Avg_PRICE",0);
     v[30]=cur->cal("C_aut_A",0);
     v[31]=cur->cal("C_aut_B",0);
     v[32]=cur->cal("C_aut_C",0);
     v[33]=cur->cal("C_aut_D",0);
   		v[13]=v[13]+v[17]*v[27]*v[29]+(v[17]*(1-v[27])*v[28]*1.1+v[18])*v[25]*v[26];
   		v[14]=v[14]+v[19]*v[27]*v[29]+(v[19]*(1-v[27])*v[28]*1.1+v[20])*v[25]*v[26];
   		v[15]=v[15]+v[21]*v[27]*v[29]+(v[21]*(1-v[27])*v[28]*1.1+v[22])*v[25]*v[26];
   		v[16]=v[16]+v[23]*v[27]*v[29]+(v[23]*(1-v[27])*v[28]*1.1+v[24])*v[25]*v[26];
     v[34]=v[34]+v[30]*v[27]*v[29]+v[30]*(1-v[27])*v[28]*1.1*v[25]*v[26];
     v[35]=v[35]+v[31]*v[27]*v[29]+v[31]*(1-v[27])*v[28]*1.1*v[25]*v[26];
     v[36]=v[36]+v[32]*v[27]*v[29]+v[32]*(1-v[27])*v[28]*1.1*v[25]*v[26];
     v[37]=v[37]+v[33]*v[27]*v[29]+v[33]*(1-v[27])*v[28]*1.1*v[25]*v[26];
   }
WRITE("GASTOS_CLASS_B_P",v[14]*v[8]+v[35]);
WRITE("GASTOS_CLASS_C_P",v[15]*v[11]+v[36]);
WRITE("GASTOS_CLASS_D_P",v[16]*v[12]+v[37]);




res=v[4]*v[13]+v[34];
goto end;
}


if(!strcmp(label,"GASTOS_CLASS_B"))
{
/*
Gastos de Cada Classe
*/
p->cal("GASTOS_CLASS_A", 0);
v[0]=p->cal("GASTOS_CLASS_B_P", 0);
res=v[0];
goto end;
}


if(!strcmp(label,"GASTOS_CLASS_C"))
{
/*
Gastos de Cada Classe
*/
p->cal("GASTOS_CLASS_A", 0);
v[0]=p->cal("GASTOS_CLASS_C_P", 0);
res=v[0];

goto end;
}


if(!strcmp(label,"GASTOS_CLASS_D"))
{
/*
Gastos de Cada Classe
*/
p->cal("GASTOS_CLASS_A", 0);
v[0]=p->cal("GASTOS_CLASS_D_P", 0);
res=v[0];

goto end;
}


if(!strcmp(label,"propcons_CLASS_A"))
{
/*
Variável de Análise para determinar se as classes estão ou não se endividando. Se o valor for maior do que 1 
a classe está se endividando no período.
*/
v[0]=p->cal("CLASS_A_nom",0);
v[1]=p->cal("GASTOS_CLASS_A",0);
res=v[1]/v[0];
goto end;
}

if(!strcmp(label,"propcons_CLASS_B"))
{
/*
Variável de Análise para determinar se as classes estão ou não se endividando. Se o valor for maior do que 1 
a classe está se endividando no período.
*/
v[0]=p->cal("CLASS_B_nom",0);
v[1]=p->cal("GASTOS_CLASS_B",0);
res=v[1]/v[0];
goto end;
}


if(!strcmp(label,"propcons_CLASS_C"))
{
/*
Variável de Análise para determinar se as classes estão ou não se endividando. Se o valor for maior do que 1 
a classe está se endividando no período.
*/
v[0]=p->cal("CLASS_C_nom",0);
v[1]=p->cal("GASTOS_CLASS_C",0);
res=v[1]/v[0];
goto end;
}


if(!strcmp(label,"propcons_CLASS_D"))
{
/*
Variável de Análise para determinar se as classes estão ou não se endividando. Se o valor for maior do que 1 
a classe está se endividando no período.
*/
v[0]=p->cal("CLASS_D_nom",0);
v[1]=p->cal("GASTOS_CLASS_D",0);
res=v[1]/v[0];
goto end;
}

if(!strcmp(label,"Emprego_set"))
{
/*
Emprego no setor em horas trabalhadas.
*/
for(v[0]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=cur->cal("EFPR",0);
  v[2]=cur->cal("AVG_PROD",1);
  v[0]=v[0]+v[1]/v[2];
 }
res=v[0];
goto end;
}



if(!strcmp(label,"Q_GDP"))
{
/*
O valor agregado é calculado como a soma do excedente total da economia mais os salários totais.
*/
v[0]=p->cal("SURPLUS_TOT",0);
v[1]=p->cal("WAGE_TOT",0);
v[2]=p->cal("indirect_taxes",0);
res=v[0]+v[1]+v[2];
goto end;
}

EQUATION("PIB")
/*
PIB anual
*/
v[0]=V("Q_GDP");
v[1]=VL("Q_GDP",1);
v[2]=VL("Q_GDP",2);
v[3]=VL("Q_GDP",3);

RESULT(v[0]+v[1]+v[2]+v[3])




if(!strcmp(label,"Q_GDP_real"))
{
/*
O valor agregado é calculado como a soma do excedente total da economia mais os salários totais.
*/
v[0]=p->cal("Q_GDP",0);
v[1]=p->cal("IGP",0);
if(v[1]!=0)
res=v[0]/v[1];
else
res=v[0];
goto end;
}


if(!strcmp(label,"Growth_rate"))
{
/*
A taxa de crescimento anual é calculada com base no valor agregado dos últimos quatro períodos e dos quatro períodos anteriores a estes.  
*/
v[12]= fmod((double) t,4);
if(v[12]==0)
{
v[0]=p->cal("Q_GDP",7);
v[1]=p->cal("Q_GDP",6);
v[2]=p->cal("Q_GDP",5);
v[3]=p->cal("Q_GDP",4);
v[4]=(v[0]+v[1]+v[2]+v[3]);
v[5]=p->cal("Q_GDP",3);
v[6]=p->cal("Q_GDP",2);
v[7]=p->cal("Q_GDP",1);
v[8]=p->cal("Q_GDP",0);
v[9]=(v[5]+v[6]+v[7]+v[8]);
v[10]=(v[9]-v[4])/v[4];
}
else
v[10]=0;

res=v[10];
goto end;
}


if(!strcmp(label,"Accumulated_Growth_rate"))
{
/*
A taxa de crescimento acumulada é calculada ao final do ano, isto é, de quatro em quatro períodos, com base na soma do valor agregado dos últimos quatro períodos em relação aos quatro primeiros (ano base). 
*/
v[12]= fmod((double) t,4);
if(v[12]==0)
{
v[5]=p->cal("Q_GDP",3);
v[6]=p->cal("Q_GDP",2);
v[7]=p->cal("Q_GDP",1);
v[8]=p->cal("Q_GDP",0);
v[9]=(v[5]+v[6]+v[7]+v[8]);
v[4]=p->cal("Q_GDP_anualt0",0);
v[10]=(v[9]-v[4])/v[4];
}
else
v[10]=0;

res=v[10];
goto end;
}


if(!strcmp(label,"Inv_VA"))
{
/*
Comment
*/
v[0]=p->cal("INVESTIMENTO_TRIM", 0);
v[1]=p->cal("Q_GDP", 0);
res=v[0]/v[1];
goto end;
}


if(!strcmp(label,"CONSUMO"))
{
/*
Anual Consumption
*/
v[0]=p->cal("CONSUMO_TRIM",0);
v[1]=p->cal("CONSUMO_TRIM",1);
v[2]=p->cal("CONSUMO_TRIM",2);
v[3]=p->cal("CONSUMO_TRIM",3);
res=v[0]+v[1]+v[2]+v[3];
goto end;
}

if(!strcmp(label,"INVESTIMENTO"))
{
/*
Anual Investment
*/
v[0]=p->cal("INVESTIMENTO_TRIM",0);
v[1]=p->cal("INVESTIMENTO_TRIM",1);
v[2]=p->cal("INVESTIMENTO_TRIM",2);
v[3]=p->cal("INVESTIMENTO_TRIM",3);
res=v[0]+v[1]+v[2]+v[3];
goto end;
}


EQUATION("G_anual")
/*
Comment
*/
v[0]=V("Gov_expenses");
v[1]=VL("Gov_expenses",1);
v[2]=VL("Gov_expenses",2);
v[3]=VL("Gov_expenses",3);

RESULT(v[0]+v[1]+v[2]+v[3] )


/***************************************** New Aggregated Series ********************************************/


EQUATION("Aggreg_rate_Capacity_Utilization")
/*
Macro Variable
*/

for(v[3]=0,v[5]=0,v[8]=0,v[11]=0,v[13]=0,v[16]=0,v[17]=0,v[19]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 {
  v[0]=VLS(cur,"CP_Sector",1);
  v[1]=VS(cur,"EFPR_Sector");
  v[2]=V("VBP");
  v[6]=VS(cur,"SALES_Sector");
  v[7]=VS(cur,"Avg_PRICE");
  v[3]=v[3]+((v[6]*v[7])/v[2])*(v[1]/v[0]);
  
  v[4]=VS(cur,"STOCK_Sector");
  
  v[5]=v[5]+v[4]*v[7];
  
  v[9]=cur->cal("Ibc",0);
     if(v[9]==1)
     v[11]=v[11]+v[6]*v[7];
     else
     v[11]=v[11];
  
  v[12]=cur->cal("Ibk",0);
     if(v[12]==1)
     v[13]=v[13]+v[6]*v[7];
     else
     v[13]=v[13];
  
  v[15]=cur->cal("Avg_PRICE_t0",0);
  v[16]=v[16]+v[6]*v[7];
  v[17]=v[17]+v[6]*v[15];
  
  v[18]=cur->cal("Emprego_set",0);
  v[19]=v[19]+v[18];
 }
WRITE("Aggreg_STOCKS_P",v[5]);
WRITE("CONSUMO_TRIM_P",v[11]);
WRITE("INVESTIMENTO_TRIM_P",v[13]);
  if(v[17]==0)
  v[14]=p->cal("IGP",1);
  else
  v[14]=v[16]/v[17];

WRITE("IGP_P",v[14]);
WRITE("Emprego_tot_P",v[19]);


RESULT(v[3])


EQUATION("Aggreg_STOCKS")
/*
Macro Variable
*/
V("Aggreg_rate_Capacity_Utilization");
v[0]=V("Aggreg_STOCKS_P");

RESULT(v[0])

if(!strcmp(label, "VBP") )
{
/*
Um cálculo aproximado do valor bruto da produção é feito a partir da multiplicação das vendas observadas pelo preço cobrado no período.  
*/
for(v[0]=0,cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=VS(cur,"Avg_PRICE");
  v[2]=VS(cur,"SALES_Sector");
  v[0]=v[0]+v[1]*v[2];
 }
res=v[0];
goto end;
}


if(!strcmp(label,"CONSUMO_TRIM"))
{
/*
Aggregate Consumption
*/

p->cal("Aggreg_rate_Capacity_Utilization",0);
v[0]=V("CONSUMO_TRIM_P");
res=v[0];
goto end;
}

if(!strcmp(label,"INVESTIMENTO_TRIM"))
{
/*
Aggregate Investiment
*/
p->cal("Aggreg_rate_Capacity_Utilization",0);
v[0]=V("INVESTIMENTO_TRIM_P");
res=v[0];
goto end;
}


if(!strcmp(label,"IGP"))
{
/*
O índice geral de preço é calculado com base no índice de Paasche, tendo como referência os preços observados no primeiro ano.  O cálculo será dado pela razão da soma para todos os setores das vendas observadas multiplicadas pelo preço do setor sobre a soma das vendas observadas vezes o preço básico.  
*/
p->cal("Aggreg_rate_Capacity_Utilization",0);
v[0]=V("IGP_P");
res=v[0];
goto end;
}

if(!strcmp(label,"Emprego_TOT"))
{
/*
Emprego total na economia em horas trabalhadas
*/
p->cal("Aggreg_rate_Capacity_Utilization",0);
v[0]=V("Emprego_tot_P");
res=v[0];
goto end;
}

EQUATION("InvHerf")
/*
Inverse Herfindal Index
*/

for(v[0]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=cur->cal("MS",0);
  v[0]=v[0]+v[1]*v[1];
 }

  if(v[0]!=0)
  v[2]=1/v[0];
  else
  v[2]=0;
  
RESULT(v[2])




/****************************************  CLASSES DE RENDA  ***********************************************/




if(!strcmp(label,"ENDIV_ACUM_A"))
{
/*
Endividamento ou acumulação de recursos da classe no período.
*/

	v[0]=p->cal("CLASS_A_nom",0);
	v[1]=p->cal("GASTOS_CLASS_A",0);

	v[2]=v[0]-v[1];
	res=v[2];
	goto end;
}


if(!strcmp(label,"ENDIV_ACUM_B"))
{
/*
Endividamento ou acumulação de recursos da classe no período.
*/

	v[0]=p->cal("CLASS_B_nom",0);
	v[1]=p->cal("GASTOS_CLASS_B",0);

	v[2]=v[0]-v[1];
	res=v[2];
	goto end;
}


if(!strcmp(label,"ENDIV_ACUM_C"))
{
/*
Endividamento ou acumulação de recursos da classe no período.
*/

	v[0]=p->cal("CLASS_C_nom",0);
	v[1]=p->cal("GASTOS_CLASS_C",0);
	
	v[2]=v[0]-v[1];
	res=v[2];
	goto end;
}


if(!strcmp(label,"ENDIV_ACUM_D"))
{
/*
Endividamento ou acumulação de recursos da classe no período.
*/

	v[0]=p->cal("CLASS_D_nom",0);
	v[1]=p->cal("GASTOS_CLASS_D",0);

	v[2]=v[0]-v[1];
	res=v[2];
	goto end;
}


if(!strcmp(label,"aplic_fin_A"))
{
/*
Aplicações financeiras de cada classe.
	*/
	
v[0]=p->cal("aplic_fin_A",1);
v[1]=p->cal("ENDIV_ACUM_A",0);
v[3]=p->cal("PG_DIVIDA_A",1);
v[4]=p->cal("Ret_aplicfin_A",0);
v[10]=p->cal("DIVIDA_A",1);
v[11]=p->cal("INTERESTS_RATE",0);
v[5]=max(0,v[10]*v[11]);
v[8]=p->cal("imp_dirP_A",0);
v[13]=p->cal("Pg_juros_gov",0);
v[6]=max((v[4]+v[13])*(1-v[8])-v[5],0);
     
     if(v[1]>0)
     v[12]=v[1];
     else
     v[12]=0;
	
v[7]=v[0]+v[12]+v[6]-v[3];
	
res=max(v[7],0);
goto end;
}


if(!strcmp(label,"aplic_fin_B"))
{
/*
Aplicações financeiras de cada classe.
	*/

	v[0]=p->cal("aplic_fin_B",1);
	v[1]=p->cal("ENDIV_ACUM_B",0);
	v[3]=p->cal("PG_DIVIDA_B",1);
	v[4]=p->cal("Ret_aplicfin_B",0);
	v[10]=p->cal("DIVIDA_B",1);
	v[11]=p->cal("INTERESTS_RATE",0);
	v[5]=max(0,v[10]*v[11]);
	v[8]=p->cal("imp_dirP_B",0);

	v[6]=max(v[4]*(1-v[8])-v[5],0);

		if(v[1]>0)
     v[12]=v[1];
     else
     v[12]=0;
	
	v[7]=v[0]+v[12]+v[6]-v[3];
	
	//if(v[7]<0)
	//plog("\nERROR: aplic_fin_B menor que zero - ver aplic_fin_B");

	res=max(v[7],0);
	goto end;
}


if(!strcmp(label,"aplic_fin_C"))
{
/*
Aplicações financeiras de cada classe.
	*/
	
	v[0]=p->cal("aplic_fin_C",1);
	v[1]=p->cal("ENDIV_ACUM_C",0);
	v[3]=p->cal("PG_DIVIDA_C",1);
	v[4]=p->cal("Ret_aplicfin_C",0);
	v[10]=p->cal("DIVIDA_C",1);
	v[11]=p->cal("INTERESTS_RATE",0);
	v[5]=max(0,v[10]*v[11]);
	v[8]=p->cal("imp_dirP_C",0);

	v[6]=max(v[4]*(1-v[8])-v[5],0);

		if(v[1]>0)
     v[12]=v[1];
     else
     v[12]=0;
	
	v[7]=v[0]+v[12]+v[6]-v[3];
	
	//if(v[7]<0)
	//plog("\nERROR: aplic_fin_C menor que zero - ver aplic_fin_C");

	res=max(v[7],0);
	goto end;
}


if(!strcmp(label,"aplic_fin_D"))
{
/*
Aplicações financeiras de cada classe.
	*/
	
	v[0]=p->cal("aplic_fin_D",1);
	v[1]=p->cal("ENDIV_ACUM_D",0);
	v[3]=p->cal("PG_DIVIDA_D",1);
	v[4]=p->cal("Ret_aplicfin_D",0);
	v[10]=p->cal("DIVIDA_D",1);
	v[11]=p->cal("INTERESTS_RATE",0);
	v[5]=max(0,v[10]*v[11]);
	v[8]=p->cal("imp_dirP_D",0);

	v[6]=max(v[4]*(1-v[8])-v[5],0);

    	if(v[1]>0)
     v[12]=v[1];
     else
     v[12]=0;
	
	v[7]=v[0]+v[12]+v[6]-v[3];
	
	//if(v[7]<0)
	//plog("\nERROR: aplic_fin_D menor que zero - ver aplic_fin_D");

	res=max(v[7],0);
	goto end;
}


if(!strcmp(label,"Ret_aplicfin_A"))
{
/*
Retorno sobre aplicação financeira da classe de renda.
	*/
	
	v[0]=p->cal("aplic_fin_A",1);
	v[1]=p->cal("RETURN_RATE",0);
	
	v[2]=v[0]*v[1];
	
	res=max(v[2],0);
	goto end;
}


if(!strcmp(label,"Ret_aplicfin_B"))
{
/*
Retorno sobre aplicação financeira da classe de renda.
	*/
	
	v[0]=p->cal("aplic_fin_B",1);
	v[1]=p->cal("RETURN_RATE",0);
	
	v[2]=v[0]*v[1];
	
	res=max(v[2],0);
	goto end;
}


if(!strcmp(label,"Ret_aplicfin_C"))
{
/*
Retorno sobre aplicação financeira da classe de renda.
	*/
	
	v[0]=p->cal("aplic_fin_C",1);
	v[1]=p->cal("RETURN_RATE",0);
	
	v[2]=v[0]*v[1];
	
	res=max(v[2],0);
	goto end;
}


if(!strcmp(label,"Ret_aplicfin_D"))
{
/*
Retorno sobre aplicação financeira da classe de renda.
	*/
	
	v[0]=p->cal("aplic_fin_D",1);
	v[1]=p->cal("RETURN_RATE",0);
	
	v[2]=v[0]*v[1];
	
	res=max(v[2],0);
	goto end;
}


if(!strcmp(label,"DIVIDA_A"))
{
/*
Estoque de dívida acumulada de cada classe de renda.
	*/
	
	v[0]=p->cal("DIVIDA_A",1);
	v[2]=p->cal("ENDIV_ACUM_A",0);
	v[3]=p->cal("PG_DIVIDA_A",1);
	v[4]=p->cal("Ret_aplicfin_A",0);
	v[10]=p->cal("DIVIDA_A",1);
	v[11]=p->cal("INTERESTS_RATE",0);
	v[5]=max(0,v[10]*v[11]);
	v[8]=p->cal("imp_dirP_A",0);

	v[6]=-min(v[4]*(1-v[8])-v[5],0);
     
     if(v[2]>0)
     v[12]=0;
     else
     v[12]=-v[2];

	v[7]=v[0]+v[12]-v[3]+v[6];

	//if(v[7]<0)
	//plog("\nERROR: DIVIDA_A menor que zero - ver DIVIDA_A");

	res=max(v[7],0);
	goto end;
}


if(!strcmp(label,"DIVIDA_B"))
{
/*
Estoque de dívida acumulada de cada classe de renda.
	*/
	
	v[0]=p->cal("DIVIDA_B",1);
	v[2]=p->cal("ENDIV_ACUM_B",0);
	v[3]=p->cal("PG_DIVIDA_B",1);
	v[4]=p->cal("Ret_aplicfin_B",0);
	v[10]=p->cal("DIVIDA_B",1);
	v[11]=p->cal("INTERESTS_RATE",0);
	v[5]=max(0,v[10]*v[11]);
	v[8]=p->cal("imp_dirP_B",0);

	v[6]=-min(v[4]*(1-v[8])-v[5],0);

     if(v[2]>0)
     v[12]=0;
     else
     v[12]=-v[2];

	v[7]=v[0]+v[12]-v[3]+v[6];

	//if(v[7]<0)
	//plog("\nERROR: DIVIDA_B menor que zero - ver DIVIDA_B");

	res=max(v[7],0);
	goto end;
}


if(!strcmp(label,"DIVIDA_C"))
{
/*
Estoque de dívida acumulada de cada classe de renda.
	*/
	
	v[0]=p->cal("DIVIDA_C",1);
	v[2]=p->cal("ENDIV_ACUM_C",0);
	v[3]=p->cal("PG_DIVIDA_C",1);
	v[4]=p->cal("Ret_aplicfin_C",0);
	v[10]=p->cal("DIVIDA_C",1);
	v[11]=p->cal("INTERESTS_RATE",0);
	v[5]=max(0,v[10]*v[11]);
	v[8]=p->cal("imp_dirP_C",0);

	v[6]=-min(v[4]*(1-v[8])-v[5],0);

     if(v[2]>0)
     v[12]=0;
     else
     v[12]=-v[2];

	v[7]=v[0]+v[12]-v[3]+v[6];

	//if(v[7]<0)
	//plog("\nERROR: DIVIDA_C menor que zero - ver DIVIDA_C");

	res=max(v[7],0);
	goto end;
}


if(!strcmp(label,"DIVIDA_D"))
{
/*
Estoque de dívida acumulada de cada classe de renda.
	*/
	
	v[0]=p->cal("DIVIDA_D",1);
	v[2]=p->cal("ENDIV_ACUM_D",0);
	v[3]=p->cal("PG_DIVIDA_D",1);
	v[4]=p->cal("Ret_aplicfin_D",0);
	v[10]=p->cal("DIVIDA_D",1);
	v[11]=p->cal("INTERESTS_RATE",0);
	v[5]=max(0,v[10]*v[11]);
	v[8]=p->cal("imp_dirP_D",0);

	v[6]=-min(v[4]*(1-v[8])-v[5],0);

     if(v[2]>0)
     v[12]=0;
     else
     v[12]=-v[2];

	v[7]=v[0]+v[12]-v[3]+v[6];

	//if(v[7]<0)
	//plog("\nERROR: DIVIDA_D menor que zero - ver DIVIDA_D");

	res=max(v[7],0);
	goto end;
}


if(!strcmp(label,"grau_endiv_A"))
{
/*
Grau de endividamento de cada classe.
*/

	v[0]=p->cal("DIVIDA_A",0);
	v[1]=p->cal("aplic_fin_A",0);

		if(v[1]!=0)
			v[2]=v[0]/v[1];
		else
			{
			v[2]=0;
			//plog("\nERROR: aplic_fin_A igual a zero - ver grau_endiv_A");
			}

	res=v[2];
	goto end;
}


if(!strcmp(label,"grau_endiv_B"))
{
/*
Grau de endividamento de cada classe.
*/

	v[0]=p->cal("DIVIDA_B",0);
	v[1]=p->cal("aplic_fin_B",0);
	
		if(v[1]!=0)
			v[2]=v[0]/v[1];
		else
			{
			v[2]=0;
			//plog("\nERROR: aplic_fin_B igual a zero - ver grau_endiv_B");
			}
	
	res=v[2];
	goto end;
}


if(!strcmp(label,"grau_endiv_C"))
{
/*
Grau de endividamento de cada classe.
*/

	v[0]=p->cal("DIVIDA_C",0);
	v[1]=p->cal("aplic_fin_C",0);
	
		if(v[1]!=0)
			v[2]=v[0]/v[1];
		else
			{
			v[2]=0;
			//plog("\nERROR: aplic_fin_C igual a zero - ver grau_endiv_C");
			}
	
	res=v[2];
	goto end;
}


if(!strcmp(label,"grau_endiv_D"))
{
/*
Grau de endividamento de cada classe.
*/

	v[0]=p->cal("DIVIDA_D",0);
	v[1]=p->cal("aplic_fin_D",0);
	
		if(v[1]!=0)
			v[2]=v[0]/v[1];
		else
			{
			v[2]=0;
			//plog("\nERROR: aplic_fin_D igual a zero - ver grau_endiv_D");
			}
	
	res=v[2];
	goto end;
}


if(!strcmp(label,"PG_DIVIDA_A"))
{
/*
Define prioridades entre pagamento de dívida com aplicação financeira, desfazendo-se de propriedade e possibilidade de consumo autônomo.
*/

	v[0]=p->cal("grau_endiv_A",0);
	v[1]=p->cal("min_grau_endiv_A",0);
	v[2]=p->cal("max_grau_endiv_A",0);
	v[3]=p->cal("aplic_fin_A",0);
	v[7]=p->cal("DIVIDA_A",0);

	v[10]=v[7]-v[1]*v[3];
	v[11]=max(min(v[3],v[10]),0);
		
	if(v[0]<=v[1])
		v[15]=1;
	
	if(v[1]<v[0]&&v[0]<v[2])
		v[15]=0.5;

	if(v[2]<=v[0])
		v[15]=0;

	
	//p->write("prop_cons_aut_AP",v[15], 0);

	res=v[11];
	goto end;
}


if(!strcmp(label,"PG_DIVIDA_B"))
{
/*
Define prioridades entre pagamento de dívida com aplicação financeira, desfazendo-se de propriedade e possibilidade de consumo autônomo.
*/

	v[0]=p->cal("grau_endiv_B",0);
	v[1]=p->cal("min_grau_endiv_B",0);
	v[2]=p->cal("max_grau_endiv_B",0);
	v[3]=p->cal("aplic_fin_B",0);
	v[7]=p->cal("DIVIDA_B",0);

	v[10]=v[7]-v[1]*v[3];
	v[11]=max(min(v[3],v[10]),0);
		
	if(v[0]<=v[1])
		v[15]=1;
	
	if(v[1]<v[0]&&v[0]<v[2])
		v[15]=0.5;

	if(v[2]<=v[0])
		v[15]=0;

	
	//p->write("prop_cons_aut_BP",v[15], 0);

	res=v[11];
	goto end;
}


if(!strcmp(label,"PG_DIVIDA_C"))
{
/*
Define prioridades entre pagamento de dívida com aplicação financeira, desfazendo-se de propriedade e possibilidade de consumo autônomo.
*/

	v[0]=p->cal("grau_endiv_C",0);
	v[1]=p->cal("min_grau_endiv_C",0);
	v[2]=p->cal("max_grau_endiv_C",0);
	v[3]=p->cal("aplic_fin_C",0);
	v[7]=p->cal("DIVIDA_C",0);

	v[10]=v[7]-v[1]*v[3];
	v[11]=max(min(v[3],v[10]),0);
		
	if(v[0]<=v[1])
		v[15]=1;
	
	if(v[1]<v[0]&&v[0]<v[2])
		v[15]=0.5;

	if(v[2]<=v[0])
		v[15]=0;

	
	//p->write("prop_cons_aut_CP",v[15], 0);

	res=v[11];
	goto end;
}


if(!strcmp(label,"PG_DIVIDA_D"))
{
/*
Define prioridades entre pagamento de dívida com aplicação financeira, desfazendo-se de propriedade e possibilidade de consumo autônomo.
*/

	v[0]=p->cal("grau_endiv_D",0);
	v[1]=p->cal("min_grau_endiv_D",0);
	v[2]=p->cal("max_grau_endiv_D",0);
	v[3]=p->cal("aplic_fin_D",0);
	v[7]=p->cal("DIVIDA_D",0);

	v[10]=v[7]-v[1]*v[3];
	v[11]=max(min(v[3],v[10]),0);
		
	if(v[0]<=v[1])
		v[15]=1;
	
	if(v[1]<v[0]&&v[0]<v[2])
		v[15]=0.5;

	if(v[2]<=v[0])
		v[15]=0;

	
	//p->write("prop_cons_aut_DP",v[15], 0);

	res=v[11];
	goto end;
}

/****************************** NÃO INSERI daqui para baixo ************************************/

if(!strcmp(label,"prop_cons_aut_A"))
{
/*
Proporção da riqueza destinada ao consumo autônomo em função do grau de endividamento.
	*/

	p->cal("PG_DIVIDA_A",0);

	v[0]=p->cal("prop_cons_aut_AP",0);
	
	res=v[0];
	goto end;
}


if(!strcmp(label,"prop_cons_aut_B"))
{
/*
Proporção da riqueza destinada ao consumo autônomo em função do grau de endividamento.
	*/

	p->cal("PG_DIVIDA_B",0);

	v[0]=p->cal("prop_cons_aut_BP",0);
	
	res=v[0];
	goto end;
}


if(!strcmp(label,"prop_cons_aut_C"))
{
/*
Proporção da riqueza destinada ao consumo autônomo em função do grau de endividamento.
	*/
	
	p->cal("PG_DIVIDA_C",0);

	v[0]=p->cal("prop_cons_aut_CP",0);
	
	res=v[0];
	goto end;
}


if(!strcmp(label,"prop_cons_aut_D"))
{
/*
Proporção da riqueza destinada ao consumo autônomo em função do grau de endividamento.
	*/
	
	p->cal("PG_DIVIDA_D",0);	

	v[0]=p->cal("prop_cons_aut_DP",0);
	
	res=v[0];
	goto end;
}


if(!strcmp(label,"IMPORTACAO_Classe_A"))
{
/*
Importação de bens de consumo por cada classe de renda.  
*/

	v[0]=p->cal("M_A",0);
	v[1]=p->cal("CLASSE_A",1);
	v[2]=p->cal("CLASSE_A",2);
	v[3]=p->cal("CLASSE_A",3);
	v[4]=p->cal("CLASSE_A",4);
	v[5]=p->cal("CAimp_A",0);
	v[17]=p->cal("Rec_CAut_A",0);
	v[18]=p->cal("IPC_P_A",1);
	
	v[7]=(v[1]+v[2]+v[3]+v[4])/4;
	v[8]=v[0]*v[7];

	if(v[18]!=0)
		v[9]=v[5]*(v[17]/v[18]);
	else
	{
		v[9]=v[5]*v[17];
		plog("\nERROR: IPC_P_A igual a zero - ver IMPORTACAO_Classe_A");
	}
	
	v[10]=v[8]+v[9];
	
	res=max(v[10],0);
	goto end;
}


if(!strcmp(label,"IMPORTACAO_Classe_B"))
{
/*
Importação de bens de consumo por cada classe de renda.  
*/

	v[0]=p->cal("M_B",0);
	v[1]=p->cal("CLASSE_B",1);
	v[2]=p->cal("CLASSE_B",2);
	v[3]=p->cal("CLASSE_B",3);
	v[5]=p->cal("CAimp_B",0);
	v[17]=p->cal("Rec_CAut_B",0);
	v[18]=p->cal("IPC_P_B",1);
	
	v[7]=(v[1]+v[2]+v[3])/3;
	v[8]=v[0]*v[7];

	if(v[18]!=0)
		v[9]=v[5]*(v[17]/v[18]);
	else
	{
		v[9]=v[5]*v[17];
		plog("\nERROR: IPC_P_B igual a zero - ver IMPORTACAO_Classe_B");
	}
	
	v[10]=v[8]+v[9];
	
	res=max(v[10],0);
	goto end;
}


if(!strcmp(label,"IMPORTACAO_Classe_C"))
{
/*
Importação de bens de consumo por cada classe de renda.  
*/

	v[0]=p->cal("M_C",0);
	v[1]=p->cal("CLASSE_C",1);
	v[2]=p->cal("CLASSE_C",2);
	v[5]=p->cal("CAimp_C",0);
	v[17]=p->cal("Rec_CAut_C",0);
	v[18]=p->cal("IPC_P_C",1);
	
	v[7]=(v[1]+v[2])/2;
	v[8]=v[0]*v[7];

	if(v[18]!=0)
		v[9]=v[5]*(v[17]/v[18]);
	else
	{
		v[9]=v[5]*v[17];
		plog("\nERROR: IPC_P_C igual a zero - ver IMPORTACAO_Classe_C");
	}
	
	v[10]=v[8]+v[9];
	
	res=max(v[10],0);
	goto end;
}


if(!strcmp(label,"IMPORTACAO_Classe_D"))
{
/*
Importação de bens de consumo por cada classe de renda.  
*/

	v[0]=p->cal("M_D",0);
	v[1]=p->cal("CLASSE_D",1);
	v[5]=p->cal("CAimp_D",0);
	v[17]=p->cal("Rec_CAut_D",0);
	v[18]=p->cal("IPC_P_D",1);
	
	v[8]=v[0]*v[1];

	if(v[18]!=0)
		v[9]=v[5]*(v[17]/v[18]);
	else
	{
		v[9]=v[5]*v[17];
		plog("\nERROR: IPC_P_A igual a zero - ver IMPORTACAO_Classe_A");
	}
	
	v[10]=v[8]+v[9];
	
	res=max(v[10],0);
	goto end;
}

/*************************************** PRODUCT INNOVATION ********************************/

if(!strcmp(label, "QUALITY_pot"))
{
v[0]=p->cal("QUALITY_IN",0);
v[1]=p->cal("QUALITY_IM",0);
v[2]=p->cal("QUALITY_pot",1);   
v[3]=max(v[0],v[1]);
res=max(v[3],v[2]);     
goto end;
}
if(!strcmp(label, "QUALITY_IN"))
 {

   v[0]=p->cal("REVENUE", 1);
   v[1]=p->cal("RQN", 0);
   v[3]=p->cal("aQn",0);
   v[4]=v[0]*v[1];//P&D em inovaçao de produto.
   v[5]=p->cal("QUALITY_ini",0);
   v[6]=p->cal("DesvPad_Q",0);
   v[8]=p->cal("OPORT_TECN_Q",0);
   v[9]=p->cal("REGIM_TECN_Q",0);
   v[10]=p->cal("QUALITY_pot",1);
   v[12]=(1-exp(-v[4]*v[3]));
     if(v[9]==1) //CORRECTED used to be v[9]=1
     v[11]=log(v[5])+(double)t*(v[8]);
     else
     v[11]=log(v[10]);
   
   
        if(RND<v[12])
        {
        v[13]=exp(norm(v[11],v[6]));
        }
        else
       	{
       	v[13]=0;
       	}
res=v[13];     
goto end;
}

if(!strcmp(label, "QUALITY_IM"))
 {
v[0]=p->cal("REVENUE", 1);
v[1]=p->cal("RQM", 0);
v[2]=p->cal("QUALITY_MAX", 1);
v[3]=p->cal("aQm",0);
v[4]=(v[0]*v[1]);//P&D em imitação
v[5]=(1-exp(-v[4]*v[3]));//1029
//p->write("Prob_Q_IM",v[5],0);
   if(RND<v[5])
   {
   res=v[2];    
   //p->write("sucesso_q_im",1,0);
   }
   else
   {
   //p->write("sucesso_q_im",0,0);
   res=0;
   } 
goto end;
}

EQUATION("QUALITY")
/*
Comment
*/
v[0]=VL("QUALITY",1);
v[10]=p->cal("Id2",0);
v[1]= fmod((double) t,6); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
  
  if(v[10]==v[1]||v[10]==(v[1]+6)||v[10]==(v[1]+12)||v[10]==(v[1]+18))
  {
   v[2]=VL("pay_teste_Q",6);
   v[3]=VL("QUALITY_pot",6);
     
     if(v[2]==1)
     {
       v[5]=VL("I_aut_quality_des",6);
       v[6]=VL("I_aut_quality",6);
          if(v[5]==0)
          v[7]=0;
          else
          v[7]=v[6]/v[5];
       v[4]=v[7]*(v[3]-v[0])+v[0];
     }
     else
     v[4]=v[0];
     
   }
   else
   v[4]=v[0];

RESULT(v[4])

EQUATION("QUALITY_MAX")
/*
Maximum Quality of the market
*/

for(v[1]=0,v[3]=0,v[4]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[0]=cur->cal("QUALITY",0);
  v[1]=max(v[1],v[0]);
  v[2]=cur->cal("EF_MS",0);
  v[3]=v[3]+v[2]*v[0];
  v[4]=v[4]+v[2];
 }

WRITE("AVG_QUALITY_SET_P",v[3]/v[4]);
WRITE("SUM_EF_MS_P",v[4]);

RESULT(v[1])

EQUATION("AVG_QUALITY_SET")
/*
Sector Variable
*/

V("QUALITY_MAX");
v[0]=V("AVG_QUALITY_SET_P");

RESULT(v[0])

EQUATION("SUM_EF_MS")
/*
Sector Variable
*/

V("QUALITY_MAX");
v[0]=V("SUM_EF_MS_P");

RESULT(v[0])


EQUATION("pay_teste_Q")
/*
try to find the equivalent to pay_test for quality increase
*/

v[0]=p->cal("PRICE",1);
v[1]=p->cal("Ep",0);
v[2]=p->cal("QUALITY_pot",0);
v[3]=p->cal("Eq",0);
v[4]=p->cal("E",1);
v[5]=p->cal("D_D",1);
v[6]=p->cal("Ed",0);
v[8]=p->cal("QUALITY",0); 
  

    if(v[2]>v[8]&&v[0]!=0&&v[5]!=0)//quality_pot greater than actual one.
    {
    v[9]=(pow(v[2],v[3]))*(1/pow(v[0],v[1]))*(1/pow(v[5],v[6]));
    v[10]=-(((pow(v[8],(v[3]/v[1])))*(1/pow(v[9],(1/v[1])))*(1/pow(v[5],(v[6]/v[1]))))-v[0]);
    v[11]=p->cal("PRICE_BK",0);
    v[15]=p->cal("QUALITY_I_rate",0);
    v[12]=(v[15]*v[11])/v[10];
    v[13]=p->cal("PAYBACK", 0);
       if(v[12]<=v[13])
       v[14]=1;
       else
       v[14]=0;
    }
    else
    {
    v[10]=0;
    v[14]=0;
    }

p->write("var_price_equiv_P",v[10], 0);
p->write("var_quality_P",v[2]-v[8], 0);

RESULT(v[14])

if(!strcmp(label,"var_price_equiv"))
{
/*
Comment
*/
p->cal("pay_teste_Q",0);
v[0]=p->cal("var_price_equiv_P",0);
res=v[0];
goto end;
}


if(!strcmp(label,"var_quality"))
{
/*
Comment
*/
p->cal("pay_teste_Q",0);
v[0]=p->cal("var_quality_P",0);
res=v[0];
goto end;
}


EQUATION("I_aut_quality_des")
/*
Desired Autonomous Investment to obtain the gains of quality increase
*/
v[10]=p->cal("Id2",0);
v[0]= fmod((double) t,6); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
  
  if(v[10]==v[0]||v[10]==(v[0]+6)||v[10]==(v[0]+12)||v[10]==(v[0]+18))
  {
  v[1]=V("RECUR_REPO");
  v[2]=V("pay_teste_Q");
     if(v[1]>0&&v[2]==1)//Se há recursos para reposição
     {
     v[3]=p->cal("QUALITY_I_rate",0);
     v[6]=p->cal("CP",0);
     cur=p->search_var_cond("Id3",2, 0);
     v[7]=cur->cal("B",0);
     v[8]=p->cal("PRICE_BK",0);
     v[9]=v[3]*v[6]*v[7]*v[8];
     }
     else
     v[9]=0;
  }
  else
  v[9]=0;

RESULT(v[9])

EQUATION("I_aut_quality")
/*
Autonomous Investment to obtain the gains of quality increase
*/
v[10]=p->cal("Id2",0);
v[0]= fmod((double) t,6); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
  if(v[10]==v[0]||v[10]==(v[0]+6)||v[10]==(v[0]+12)||v[10]==(v[0]+18))
  {
  v[1]=V("RECUR_REPO");
  v[2]=V("I_aut_quality_des");
  v[3]=min(v[1],v[2]);
  }
  else
  v[3]=0;

RESULT(v[3])

EQUATION("RECUR_REPO_rest")
/*
Autonomous Investment to obtain the gains of quality increase
*/
v[10]=p->cal("Id2",0);
v[0]= fmod((double) t,6); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
v[1]=V("RECUR_REPO");
  if(v[10]==v[0]||v[10]==(v[0]+6)||v[10]==(v[0]+12)||v[10]==(v[0]+18))
  {
  v[2]=V("I_aut_quality");
  v[3]=v[1]-v[2];
  }
  else
  v[3]=v[1];

RESULT(v[3])

EQUATION("CP_Dem_quality")
/*
Autonomous Investment to obtain the gains of quality increase
*/
v[10]=p->cal("Id2",0);
v[0]= fmod((double) t,6); //armazena em v[7] o resto da divisao de t(período corrente) por 6.
  
  if(v[10]==v[0]||v[10]==(v[0]+6)||v[10]==(v[0]+12)||v[10]==(v[0]+18))
  {
  v[1]=V("I_aut_quality");
  v[2]=V("PRICE_BK");
  cur=p->search_var_cond("Id3",2, 0);
  v[4]=cur->cal("B",0);
  v[3]=round(v[1]/(v[2]*v[4]));
  }
  else
  v[3]=0;

RESULT(v[3])



if(!strcmp(label, "E") )
{
/*competitiveness*/

v[0]=p->cal("PRICE",1);
v[1]=p->cal("Ep",0);
v[2]=p->cal("QUALITY",0);
v[3]=p->cal("Eq",0);
v[4]=p->cal("E",1); //14/10/2003
v[5]=p->cal("D_D",1);
v[6]=p->cal("Ed",0);
v[7]=p->cal("Switch_E_DD",0);

      if(v[7]==0)
      {    
          if(v[0]!=0)
          {
          res=(pow(v[2],v[3]))*(1/pow(v[0],v[1]));
          }	
          else
          {
          res=v[4];
          plog("\nERROR: preco igual a zero");
          }
      }
      else
      {    
          if(v[0]!=0&&v[2]!=0)
          {
          res=(pow(v[2],v[3]))*(1/pow(v[0],v[1]))*(1/pow(v[5],v[6]));
          }	
          else
          {
          res=v[4];
          plog("\nERROR: preco igual a zero");
          }
      }
  goto end;
}


if(!strcmp(label, "K_DES") )
{
v[0]=p->cal("K_DES",1);
v[1]= fmod((double) t-1,8);

if(v[1]==0)
{
v[16]=p->cal("SWITCH_KDES",0);
         if(v[16]==1)
         { 
         v[2]=p->cal("K_potMED",1);
         v[3]=p->cal("expandi",0);
         v[4]=p->cal("apropri",0); 
         v[6]=p->cal("DES_MARKUP",1);
         v[7]=p->cal("E",1);
         v[8]=p->cal("EM",1);
         v[9]=v[3]*((v[7]-v[8])/v[8]);
         v[17]=p->cal("MS_DES",0); 
         v[18]=p->cal("MS_MED",1);
            if(v[2]*(1+v[9])>v[0]&&v[18]>v[17])
                  {
          				v[10]=v[6]+v[4]*(v[2]*(1+v[9])-v[0]);
          				res=v[10];
          			  }
          			else
                		res=v[0];   
         }
         else
         {
         v[2]=p->cal("K_potMED",1);
         v[5]=p->cal("expandi",0);
         v[3]=p->cal("apropri",0); 
         v[6]=p->cal("DES_MARKUP",1);
         v[7]=p->cal("MS_DES",0); 
         v[8]=p->cal("MS_MED",1);
         
         v[11]=p->cal("rule_K_DES",0);
             if(v[11]==1)
             {
                if(v[2]>v[0])
                {
                v[4]=v[6]+v[3]*(v[2]-v[6]);
                res=v[4];
                }
                else
                res=v[0];   
             }
             else
             {
                if(v[2]>v[0]||v[8]>v[7])
                {
                v[4]=v[6]+v[3]*((v[2]-v[6])*(v[5]*(v[8]-v[7])/v[7]));
                res=v[4];
                }
                else
                res=v[0];   
             }  
          
         } 
}
else
res=v[0];
 
goto end;
}

/********************************* Expectations ****************************/

EQUATION("GAMA")
/*
Comment
*/
v[0]=VL("GAMA",1);
v[1]= fmod((double) t-1,8);
if(v[1]==0)
{
v[2]=VL("EFOR_Sector",1);
v[3]=VL("EFOR_Sector",2);
v[4]=VL("EFOR_Sector",3);
v[5]=VL("EFOR_Sector",8);
v[6]=v[2]-v[5];
v[7]=(v[2]-v[3])/v[3];
v[8]=(v[3]-v[4])/v[4];
   if(v[6]>0&&v[7]>0&&v[8]>0&&v[7]>v[8])
   {
   v[9]=V("Delta_GAMA");
   v[10]=V("GAMA_Max");
   v[11]=min(v[10],v[0]+v[9]);
   }
   else
   {
      if(v[6]<0&&v[7]<0&&v[8]<0)
      {
      v[9]=V("Delta_GAMA");
      v[10]=V("GAMA_Min");
      v[11]=max(v[10],v[0]-v[9]);
      }
      else
      v[11]=v[0];
   }
}
else
v[11]=v[0];
RESULT(v[11])

/********************************* Variables Analysis Dosi Marsili et al. ****************************/

EQUATION("Degree_Compet")
/*
Firm Variable
*/
v[0]=V("E");
v[1]=V("EM");
if(v[1]>0)
v[2]=v[0]/v[1];
else
v[2]=0;
RESULT(v[2])

EQUATION("Degree_Asymmetry")
/*
Sector Variable
*/
STAT("Degree_Compet");
if(v[2]>0)
v[7]=pow(v[2],0.5);
else
v[7]=0;
WRITE("Numb_Firms_P",v[0]);
RESULT(v[7])



EQUATION("Turbulence")
/*
Sector Variable - alterada em relação ao Original
*/
for(v[0]=0,cur=p->search("Firm"); cur!=NULL; cur=go_brother(cur) )
 {
  v[1]=VS(cur,"DataNasc_firm");
  if(v[1]==(double)t)
  v[4]=0;
  else
  {
  v[2]=VS(cur,"EF_MS");
  v[3]=VLS(cur,"EF_MS",1);
  v[4]=abs(v[2]-v[3]);
  }
 v[0]=v[0]+v[4];
 }
v[5]=p->cal("EF_MS_Exit",0);
v[6]=v[0]+v[5];

RESULT(v[6])


EQUATION("Numb_Firms")
/*
Sector Variable
*/

V("Degree_Asymmetry");
v[0]=V("Numb_Firms_P");

RESULT(v[0])

/**************************************** Variaveis para a Determinacao da Taxa de Juros **********************/

if(!strcmp(label,"EXP_INFLA"))
{
/*
Cálculo da extrapolativo de expectativa de inflação.
*/

v[0]=p->cal("IGP",1);
v[1]=p->cal("IGP",2);
v[2]=p->cal("IGP",3);
v[3]=p->cal("IGP",4);
v[4]=p->cal("IGP",5);

v[5]=p->cal("GAMA_ma",0);

v[6]=v[0]-1;
v[7]=v[1]-1;
v[8]=v[2]-1;
v[9]=v[3]-1;
v[10]=v[4]-1;

  
  v[12]=v[6]-v[7];
  v[13]=v[7]-v[8];
  v[14]=v[8]-v[9];
  v[15]=v[9]-v[10];
  
v[16]=(v[12]+v[13]+v[14]+v[15])/4;

res=v[16];
goto end;
}

EQUATION("spread_firm")
/*
Comment
*/
v[1]=p->cal("Id2",0);
v[0]=fmod((double) t,6); //armazena em v[0] o resto da divisao de t(período corrente) por 6.
   if(v[1]==v[0]||v[1]==(v[0]+6)||v[1]==(v[0]+12)||v[1]==(v[0]+18))
   {
      v[2]=V("percent_spread");
      v[10]=p->cal("DEBT_RATE",1);
      v[11]=p->cal("DEBT_RATE",2);
      v[12]=p->cal("DEBT_RATE",3);
      v[13]=p->cal("DEBT_RATE",4);
      v[14]=p->cal("DEBT_RATE",5);
      v[15]=p->cal("DEBT_RATE",6);
      v[3]=(v[10]+v[11]+v[12]+v[13]+v[14]+v[15])/6;
          if(v[3]>0.5)
          v[4]=1+v[3]*v[2];
          else
          v[4]=VL("spread_firm",1);
   }
   
   else
   v[4]=VL("spread_firm",1);


RESULT(v[4])

EQUATION("INTERESTS_RATE_firm")
/*
Comment
*/
v[0]=V("INTERESTS_RATE");
v[1]=V("spread_firm");
v[2]=v[0]*v[1];
RESULT(v[2])

if(!strcmp(label,"RETURN_RATE"))
{
/*
Acompanha a inflação
*/

	
	v[1]=p->cal("EXP_INFLA",0);
	v[2]=p->cal("inf_target",0);
	v[3]=p->cal("impact_inf_interest",0);	
	v[4]=p->cal("min_return",0);	

	v[5]=max(v[1],0);
	v[6]=max(v[3]*(v[5]-v[2]),0);
	
  if(v[5]<=v[2])
  v[11]=v[4]+v[5];
  else
  v[11]=v[4]+v[5]+v[6];
	
	
	res=v[11];
	goto end;
}


/****************************************STOCK and FLOWS Consistency **************************************/

EQUATION("Gastos_Classes_tot")
/*
Inclui consumo interno e importação
*/
v[0]=V("GASTOS_CLASS_A");
v[1]=V("GASTOS_CLASS_B");
v[2]=V("GASTOS_CLASS_C");
v[3]=V("GASTOS_CLASS_D");
v[4]=v[0]+v[1]+v[2]+v[3];
RESULT(v[4])


EQUATION("DELTA_Aplicfin_classes_tot")

v[0]=V("aplic_fin_A");
v[1]=V("aplic_fin_B");
v[2]=V("aplic_fin_C");
v[3]=V("aplic_fin_D");
v[4]=VL("aplic_fin_A",1);
v[5]=VL("aplic_fin_B",1);
v[6]=VL("aplic_fin_C",1);
v[7]=VL("aplic_fin_D",1);
v[8]=v[0]-v[4]+v[1]-v[5]+v[2]-v[6]+v[3]-v[7];
RESULT(v[8])

EQUATION("DELTA_DEBT_classes_tot")

v[0]=V("DIVIDA_A");
v[1]=V("DIVIDA_B");
v[2]=V("DIVIDA_C");
v[3]=V("DIVIDA_D");
v[4]=VL("DIVIDA_A",1);
v[5]=VL("DIVIDA_B",1);
v[6]=VL("DIVIDA_C",1);
v[7]=VL("DIVIDA_D",1);
v[8]=v[0]-v[4]+v[1]-v[5]+v[2]-v[6]+v[3]-v[7];
RESULT(v[8])

EQUATION("Ret_aplicfin_Classes_tot")

v[0]=V("Ret_aplicfin_A");
v[1]=V("Ret_aplicfin_B");
v[2]=V("Ret_aplicfin_C");
v[3]=V("Ret_aplicfin_D");
v[4]=v[0]+v[1]+v[2]+v[3];
RESULT(v[4])

EQUATION("Pg_juros_Classes_tot")

v[0]=VL("DIVIDA_A",1);
v[1]=VL("DIVIDA_B",1);
v[2]=VL("DIVIDA_C",1);
v[3]=VL("DIVIDA_D",1);
v[4]=v[0]+v[1]+v[2]+v[3];
v[5]=V("INTERESTS_RATE");
RESULT(v[4]*v[5])


if(!strcmp(label,"DELTA_Aplicfin_firmas_tot"))
{
/*
Os impostos indiretos são obtidos pela soma dos impostos arrecadados sobre a venda de cada setor.
*/
v[3]=V("RETURN_RATE");

for(v[9]=0,v[10]=0,v[11]=0,v[12]=0, cur=p->search("Sector"); cur!=NULL; cur=go_brother(cur) )
 {
	for(v[13]=0,v[14]=0,v[15]=0,v[16]=0, cur1=cur->search("Firm"); cur1!=NULL; cur1=go_brother(cur1) )
{
   v[4]=VS(cur1,"INTERESTS_RATE_firm");
   v[5]=VS(cur1,"divida");
   v[6]=VS(cur1,"aplic_fin");
   v[7]=VLS(cur1,"APLIC_FIN",1);
   v[8]=VLS(cur1,"DEBT",1);
   
   v[13]=v[13]+v[5];//sum delta debt 
   v[14]=v[14]+v[6];//sum delta aplic fin
   v[15]=v[15]+v[7]*v[3];//sum return on aplic fin 
   v[16]=v[16]+v[8]*v[4];//sum interest payment 

 }
 v[9]=v[9]+v[13];
 v[10]=v[10]+v[14];
 v[11]=v[11]+v[15];
 v[12]=v[12]+v[16];
 }
WRITE("DELTA_DEBT_firmas_tot_P",v[9]); 
WRITE("Ret_aplicfin_firmas_tot_P",v[11]);
WRITE("Pg_juros_firmas_tot_P",v[12]);

res=v[10];
goto end;
}


EQUATION("DELTA_DEBT_firmas_tot")
V("DELTA_Aplicfin_firmas_tot");
v[0]=V("DELTA_DEBT_firmas_tot_P");
RESULT(v[0])

EQUATION("Ret_aplicfin_firmas_tot")
V("DELTA_Aplicfin_firmas_tot");
v[0]=V("Ret_aplicfin_firmas_tot_P");
RESULT(v[0])

EQUATION("Pg_juros_firmas_tot")
V("DELTA_Aplicfin_firmas_tot");
v[0]=V("Pg_juros_firmas_tot_P");
RESULT(v[0])


EQUATION("Saldo_Set_Fin")
/*
Comment
*/
v[0]=V("Ret_aplicfin_Classes_tot");
v[1]=V("Ret_aplicfin_firmas_tot");
v[2]=V("Pg_juros_firmas_tot");
v[3]=V("Pg_juros_Classes_tot");
v[4]=V("Pg_juros_gov");
v[5]=v[2]+v[3]+v[4]-v[0]-v[1];
RESULT(v[5])

EQUATION("Saldo_Set_Fin_II")
/*
Comment
*/
v[0]=V("DELTA_DEBT_classes_tot");
v[1]=V("DELTA_DEBT_firmas_tot");
v[2]=V("Public_Deficit");
v[3]=V("DELTA_Aplicfin_classes_tot");
v[4]=V("DELTA_Aplicfin_firmas_tot");
v[5]=v[0]+v[1]+v[2]-v[3]-v[4];
RESULT(v[5])


MODELEND




void close_sim(void)
{

}





END_EQ_FILE
